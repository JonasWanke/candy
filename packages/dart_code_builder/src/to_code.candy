use ..nodes

trait ToCode {
  fun toCode(): String
}

impl File: ToCode {
  fun toCode(): String {
    (parts as Iterable<Directive | Declaration>)
      .map<String>({ (it as ToCode).toCode() })
      .join("\n")
  }
}

impl Annotation: ToCode {
  fun toCode(): String { "@{(expression as ToCode).toCode()}" }
}

impl Directive: ToCode

impl Import: ToCode {
  fun toCode(): String {
    mut let s = "import '{path}'"
    if alias is Some {
      s = "{s} as {alias.unwrap()}"
    }
    if (show as Iterable).isNotEmpty() {
      s = "{s} show {(show as Iterable).join(", ")}"
    }
    if (hide as Iterable).isNotEmpty() {
      s = "{s} hide {(hide as Iterable).join(", ")}"
    }
    "{s};"
  }
}

impl Part: ToCode {
  fun toCode(): String { "part '{path}';" }
}

impl PartOf: ToCode {
  fun toCode(): String { "part of '{path}';" }
}

let a = 3

impl Declaration: ToCode
impl Class: ToCode {
  fun toCode(): String {
    let annotationsCode = (annotations as Iterable<Annotation>)
      .map<String>({ (it as ToCode).toCode() })
      .join("\n")
    mut let s = "{annotationsCode}\nclass {name}"
    if extends_ is Some {
      s = "{s} extends {(extends_.unwrap() as ToCode).toCode()}"
    }
    if (implements_ as Iterable).isNotEmpty() {
      let implementsCode = (implements_ as Iterable<DartType>)
        .map<String>({ (it as ToCode).toCode() })
        .join(", ")
      s = "{s} implements {implementsCode}"
    }
    if (with_ as Iterable).isNotEmpty() {
      let withCode = (with_ as Iterable<DartType>)
        .map<String>({ (it as ToCode).toCode() })
        .join(", ")
      s = "{s} with {withCode}"
    }
    let bodyCode = (body as Iterable<Field | Getter | Setter | Function>)
      .map<String>({ "  {(it as ToCode).toCode()}" })
      .join("\n")
    "{s} \üëç\n{bodyCode}\n}"
  }
}
impl Function: ToCode {
  fun toCode(): String {
    mut let s = name
    if _returns is Some {
      s = "{(_returns.unwrap() as ToCode).toCode()} {s}"
    }
    mut let parameters = (requiredParameters as Iterable<Parameter>)
      .map<String>({ (it as ToCode).toCode() })
      .join(", ")
    let positionalParameters = (positionalParameters as Iterable<Parameter>)
      .map<String>({ (it as ToCode).toCode() })
      .join(", ")
    let namedParameters = (namedParameters as Iterable<Parameter>)
      .map<String>({ (it as ToCode).toCode() })
      .join(", ")
    if !(parameters == "") && (!(positionalParameters == "") || !(namedParameters == "")) {
      parameters = "{parameters}, "
    }
    if !(positionalParameters == "") {
      parameters = "{parameters}[{positionalParameters}]"
    }
    if !(namedParameters == "") {
      parameters = "{parameters}\üëç{namedParameters}}"
    }
    s = "{s}({parameters})"
    if body is Some {
      s = "{s} {body}"
    } else {
      s = "{s};"
    }
    s
  }
}
impl Parameter: ToCode {
  fun toCode(): String {
    "Parameter" // TODO(marcelgarus): Implement.
  }
}
impl Field: ToCode {
  fun toCode(): String {
    "Field" // TODO(marcelgarus): Implement.
  }
}

impl Mutability: ToCode
impl Var: ToCode {
  fun toCode(): String { "var" }
}
impl Final: ToCode {
  fun toCode(): String { "final" }
}
impl Const: ToCode {
  fun toCode(): String { "const" }
}

impl Getter: ToCode {
  fun toCode(): String {
    "Getter" // TODO(marcelgarus): Implement.
  }
}
impl Setter: ToCode {
  fun toCode(): String {
    "Setter" // TODO(marcelgarus): Implement.
  }
}

impl Body: ToCode
impl InlineBody: ToCode {
  fun toCode(): String {
    "=> {expression}"
  }
}
impl BlockBody: ToCode {
  fun toCode(): String {
    "ü¶Ñ{(statements as Iterable).join("\n")}ü¶Ñ"
  }
}

impl DartType: ToCode
impl UserType: ToCode {
  fun toCode(): String {
    mut let s = name
    if prefix is Some {
      s = "{prefix.unwrap()}.{s}"
    }
    if (parameters as Iterable).isNotEmpty() {
      s = "{s}<{(parameters as Iterable).join(", ")}>"
    }
    s
  }
}
impl FunctionType: ToCode {
  fun toCode(): String {
    mut let s = "Function"
    // if returns is Some {
    //   s = "{returns} {s}"
    // }
    s = "{s}("
    // s = "{s}{(parameters as Iterable).map<String>({ "{it}," }).join("")}"
    // for parameter in parameters {
    //   s = "{s}{parameter},"
    // }
    // if positionalParameters.isNotEmpty() {
    //   s = "{"
    // }
    s = "{s})"
    s
  }
}

impl Expression: ToCode
impl Identifier: ToCode {
  fun toCode(): String {
    mut let s = name
    if prefix is Some {
      print("f")
      s = "{prefix}.{s}"
    }
    s
  }
}
impl Literal: ToCode {
  fun toCode(): String {
    "{this}"
  }
}
impl Call: ToCode {
  fun toCode(): String {
    mut let s = (target as ToCode).toCode()
    if (typeArguments as Iterable).isNotEmpty() {
      s = "{s}<{(typeArguments as Iterable).join(", ")}>"
    }
    let arguments = (positionalArguments as Iterable<Expression>)
      .map<String>({ "{it}, " })
      .followedBy(
        namedArguments
          .entries()
          .map<String>({ "{it.first}: {it.second}" })
      )
      .join(", ")
    s = "{s}({arguments})"
  }
}
impl Navigation: ToCode {
  fun toCode(): String { "{target}.{property}" }
}
impl BinaryOperator: ToCode {
  fun toCode(): String { "{left} {operator} {right}" }
}
impl PrefixOperator: ToCode {
  fun toCode(): String { "{operator}{target}" }
}
impl Assignment: ToCode {
  fun toCode(): String {
    "{left} = {right}"
  }
}
impl Closure: ToCode {
  fun toCode(): String {
    "Closure" // TODO(marcelgarus): Implement.
  }
}

impl Statement: ToCode
impl ExpressionStatement: ToCode {
  fun toCode(): String { "{expression};" }
}
impl If: ToCode {
  fun toCode(): String {
    let thenCode = (then as Iterable<Statement>)
      .map<String>({ it: Statement => "{it}ü¶Ñ" })
      .join("")
    let elseCode = (else_ as Iterable<Statement>)
      .map<String>({ it: Statement => "{it}ü¶Ñ" })
      .join("")
    "if ({condition}) ü¶Ñ{thenCode}ü¶Ñ else ü¶Ñ{elseCode}ü¶Ñ"
  }
}
impl While: ToCode {
  fun toCode(): String {
    "While" // TODO(marcelgarus): Implement.
  }
}
