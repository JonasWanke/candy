use ...operators
use ...primitives
use ..list
use ...todo

public trait Iterator<Item> {
  fun next(): Maybe<Item>
}

public trait Iterable<Item> {
  fun /* let */ iterator(): Iterator<Item>

  // Getters

  fun get(index: Int /* UInt */): Maybe<Item> {
    /// Returns the [index]th element.
    
    let iter = iterator()
    mut let i = 0
    mut let element: Maybe<Item> = None<Item>()
    while i <= index {
      element = iter.next()
      i = i + 1
    }
    element
  }

  fun first(): Maybe<Item> { get(0) }
  fun second(): Maybe<Item> { get(1) }
  fun third(): Maybe<Item> { get(2) }
  fun fourth(): Maybe<Item> { get(3) }
  fun fifth(): Maybe<Item> { get(4) }
  fun sixth(): Maybe<Item> { get(5) }
  fun seventh(): Maybe<Item> { get(6) }

  fun nthLast(index: Int): Maybe<Item> {
    // TODO(marcelgarus): Implement this.
    // TODO(marcelgarus): Make this way more efficient.
    // let list = ArrayList.empty<Item>()
    // let iter = iterator()
    // loop {
    //   let element = iter.next()
    //   if element is None { break }
    //   list.append(element.unwrap())
    //   if list.length() > index {
    //     list.removeFirst()
    //   }
    // }
    // if list.length() == index { list.first() } else { None<Item>() }
    todo("Implement nthLast.")
  }

  fun last(): Maybe<Item> { nthLast(0) }
  fun secondLast(): Maybe<Item> { nthLast(1) }
  fun thirdLast(): Maybe<Item> { nthLast(2) }

  fun single(): Maybe<Item> {
    let iter = iterator()
    let first = iter.next()
    if first is None {
      return None<Item>()
    }
    if iter.next() is Some<Item> {
      return None<Item>()
    }
    first
  }

  // Properties.

  // fun length(): Int {
  //   let iter = iterator()
  //   mut let length = 0
  //   while iter.next() is More<Item> {
  //     length = length + 1
  //   }
  //   length
  // }

  // Boolean checks.

  fun isEmpty(): Bool { first() is None }
  fun isNotEmpty(): Bool { !isEmpty() }

  // TODO(marcelgarus): Implement these as soon as for-loops work:
  // TODO(marcelgarus): all
  // TODO(marcelgarus): any
  // TODO(marcelgarus): contains

  // Reductions.

  // TODO(marcelgarus): foldLeft
  // TODO(marcelgarus): foldRight
  // TODO(marcelgarus): reduceLeft
  // TODO(marcelgarus): reduceRight

  // Searching.

  // TODO(marcelgarus): firstWhere
  // TODO(marcelgarus): lastWhere
  // TODO(marcelgarus): singleWhere
  // TODO(marcelgarus): firstIndexWhere
  // TODO(marcelgarus): lastIndexWhere

  // Mapping transformations.
  // These return an `Iterable` with the same length, but a different type.

  fun map<Out>(mapper: (Item) => Out): Iterable<Out> {
    MappedIterable<Item, Out>(this, mapper)
  }

  fun cast<Type>(): Iterable<Type> {
    map<Type>({ it as Type })
  }

  // // TODO(marcelgarus): Maybe rename this to `indexed`?
  // fun enumerate(): Iterable<(Int, Item)> {
  //   mut let index = 0
  //   map<(Int, Item)>({
  //      let result = (index, it)
  //      index = index + 1
  //      result
  //   })
  // }

  // Selection transformations.
  // These return an `Iterable` with a subset of the items.

  fun where(checker: (Item) => Bool): Iterable<Item> {
    WhereIterable<Item>(this, checker)
  }

  fun whereNot(checker: (Item) => Bool): Iterable<Item> {
    where({ !checker(it) })
  }

  fun whereType<Result>(): Iterable<Item & Result> {
    where({ it is Result }).cast<Item & Result>()
  }

  fun skip(n: Int): Iterable<Item> {
    mut let counter = 0
    where({
      counter = counter + 1
      counter > n
    })
  }

  fun skipWhile(checker: (Item) => Bool): Iterable<Item> {
    mut let skipping = true
    where({
      if !skipping {
        return true
      }
      skipping = checker(it)
      return skipping
    })
  }

  fun slice(start: Int, end: Int): Iterable<Item> {
    skip(start).take(end - start)
  }

  fun take(n: Int): Iterable<Item> {
    mut let counter = 0
    where({
      counter = counter + 1
      counter <= n
    })
  }

  fun takeWhile(checker: (Item) => Bool): Iterable<Item> {
    // TODO(marcelgarus): Implement more efficiently.

    mut let taking = true
    where({
      if !taking {
        return false
      }
      taking = checker(it)
      return taking
    })
  }

  // // Conversion transformations.
  // // These do more complicated stuff.

  // fun maybeMap<Out>(maybeMapper: (Item) => Maybe<Out>): Iterable<Out> {
  //   // TODO(marcelgarus): As soon as implicit casts are available, maybe make the checker return a
  //   // `MaybeMapResult`, which can be either `Map(value)` or `Drop`?

  //   // TODO: Use `whereSome` as soon as that's available.
  //   map<Maybe<Out>>(maybeMapper).whereType<Some>().map<Out>({ it.value })
  // }

  // TODO(marcelgarus): distinctBy
  // TODO(marcelgarus): expand
  // TODO(marcelgarus): flatMap
  // TODO(marcelgarus): groupBy
  // TODO(marcelgarus): reversed
  // TODO(marcelgarus): zip

  // Conversions.

  fun toList(): List<Item> {
    toMutableList()
  }

  fun toMutableList(): MutableList<Item> {
    let iter = iterator()
    let list = MutableList.empty<Item>()

    loop {
      let element = iter.next()
      if element is None {
        return list
      } else {
        list.append(element.unwrap())
      }
    }
  }

  // TODO(marcelgarus): toSet
  // TODO(marcelgarus): toMutableSet

  // Extras:

  // TODO(marcelgarus): + operator for joining Iterables

  // TODO(marcelgarus): for Iterable<(A, B)>: map with 2 args, unzip
  // TODO(marcelgarus): for Iterable<Iterable<T>>: flatten
  // TODO(marcelgarus): for Iterable<Number>: average, sum, min, max, minBy, maxBy
  // TODO(marcelgarus): for Iterable<Maybe<T>>: whereSome, unwrapAll
}

class MappedIterable<In, Out> {
  let parent: Iterable<In>
  let mapper: (In) => Out
}
impl<In, Out> MappedIterable<In, Out>: Iterable<Out> {
  fun iterator(): Iterator<Out> {
    MappedIterator<In, Out>(parent.iterator(), mapper)
  }
}
class MappedIterator<In, Out> {
  let parent: Iterator<In>
  let mapper: (In) => Out
}
impl<In, Out> MappedIterator<In, Out>: Iterator<Out> {
  fun next(): Maybe<Out> {
    parent.next().map<Out>(mapper)
  }
}

// TODO(marcelgarus): As soon as implicit casts are available, maybe make the checker return a
// `WhereResult`, which can be either `Keep` or `Drop`?
class WhereIterable<Item> {
  let parent: Iterable<Item>
  let checker: (Item) => Bool
}
impl<Item> WhereIterable<Item>: Iterable<Item> {
  fun iterator(): Iterator<Item> {
    WhereIterator<Item>(parent.iterator(), checker)
  }
}
class WhereIterator<Item> {
  let parent: Iterator<Item>
  let checker: (Item) => Bool
}
impl<Item> WhereIterator<Item>: Iterator<Item> {
  fun next(): Maybe<Item> {
    loop {
      let element = parent.next()
      if element is None {
        return element
      } else {
        if checker(element.unwrap()) {
          return element
        }
      }
    }
  }
}

trait EqualsIterable<Item: Equals>: Iterable<Item> {
  fun contains(item: Item): Bool {
    todo("Implement Iterable<Equals>.contains")
  }
  
  // TODO(marcelgarus): Implement distinct, indexOf, lastIndexOf
}
// impl<Item: Equals> Iterable<Item>: EqualsIterable<Item>
