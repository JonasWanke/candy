use ....primitives
use ...list

builtin class Array<Blub> {
  /// A builtin structure that holds a fixed number of `Blub`s.
  
  static fun filled<Blub>(length: Int /* UInt */, item: Blub): Array<Blub>
  /// Creates a new `Array` of the given `length`, where every slot is filled with the same `item`.

  let length: Int

  fun get(index: Int /* UInt */): Blub
  fun set(index: Int /* UInt */, item: Blub)
}

// TODO(marcelgarus): For now, this never shrinks. We should implement that later, although a very
// conservative shrinking heuristic is probably enough (we don't want to shrink too early).
public class ArrayList<Item> {
  /// A wrapper around `Array` that can grow dynamically.

  static fun empty<Item>(): ArrayList<Item> {
    create<Item>(8)
  }
  // public static fun of1<Item>(first: Item): ArrayList<Item> {
  //   let list = create<Item>(1)
  //   list.add(first)
  //   list
  // }
  // public static fun of2<Item>(first: Item, second: Item): ArrayList<Item> {
  //   let list = create(2)
  //   list.add(first)
  //   list.add(second)
  //   list
  // }
  // public static fun of3<Item>(first: Item, second: Item, third: Item): ArrayList<Item> {
  //   let list = create(3)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list
  // }
  // public static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): ArrayList<Item> {
  //   let list = create(4)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list.add(fourth)
  //   list
  // }
  // public static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): ArrayList<Item> {
  //   let list = create(5)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list.add(fourth)
  //   list.add(fifth)
  //   list
  // }

  static fun create<Item>(capacity: Int /* Uint */): ArrayList<Item> {
    /// Creates a new, empty `ArrayList` with the given capacity.

    ArrayList<Item>(
      Array.filled<Option<Item>>(capacity, None<Item>()),
      0,
    )
  }

  mut let items: Array<Option<Item>>
  mut let length_: Int /* UInt */

  // TODO(marcelgarus): Getterize!
  fun capacity(): Int /* UInt */ {
    items.length
  }

  fun grow() {
    /// Increases the capacity.

    let newItems = Array.filled<Option<Item>>(2 * capacity(), None<Item>())
    mut let index = 0

    while index < length() {
      newItems.set(index, items.get(index))
      index = index + 1
    }
  }
}

impl<Item> ArrayList<Item>: List<Item> {
  fun length(): Int { length_ }
  fun isEmpty(): Bool { length_ == 0 }

  fun get(index: Int /* UInt */): Item {
    if index < length_ {
      // TODO(marcelgarus): Error.
    }
    items.get(index).unwrap()
  }
}

impl<Item> ArrayList<Item>: MutableList<Item> {
  fun set(index: Int /* UInt */, item: Item) {
    items.set(index, Some<Item>(item))
  }

  fun add(item: Item) {
    if length_ == capacity() {
      grow()
    }
    set(length_, item)
    length_ = length_ + 1
  }

  fun removeAt(index: Int /* UInt */): Item {
    mut let index = index
    mut let removed = items.get(index).unwrap()
    while index < length_ - 1 {
      items.set(index, items.get(index))
    }
    items.set(index, None<Item>())
    length_ = length_ - 1
    removed
  }
  
  fun removeLast(): Item {
    removeAt(length_ - 1)
  }
  
  fun clear() {
    mut let index = 0
    while index < length_ {
      items.set(index, None<Item>())
    }
    length_ = 0
  }
}
