use ....primitives
use ...list

builtin class Array<Blub> {
  /// A builtin structure that holds a fixed number of `Blub`s.
  
  static fun fill<Blub>(length: Int /* UInt */, item: Blub): Array<Blub>
  /// Creates a new `Array` of the given `length`, where every slot is filled with the same `item`.

  let length: Int

  fun get(index: Int /* UInt */): Blub
  fun set(index: Int /* UInt */, item: Blub)
}

// TODO(marcelgarus): For now, this never shrinks. We should implement that later, although a very
// conservative shrinking heuristic is probably enough (we don't want to shrink too early).
public class ArrayList<Item> {
  /// A wrapper around `Array` that can grow dynamically.

  // static fun empty<Item>(): ArrayList<Item> {
  //   create()
  // }
  // public static fun of1<Item>(first: Item): ArrayList<Item> {
  //   let list = create(1)
  //   list.add(first)
  //   list
  // }
  // public static fun of2<Item>(first: Item, second: Item): ArrayList<Item> {
  //   let list = create(2)
  //   list.add(first)
  //   list.add(second)
  //   list
  // }
  // public static fun of3<Item>(first: Item, second: Item, third: Item): ArrayList<Item> {
  //   let list = create(3)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list
  // }
  // public static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): ArrayList<Item> {
  //   let list = create(4)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list.add(fourth)
  //   list
  // }
  // public static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): ArrayList<Item> {
  //   let list = create(5)
  //   list.add(first)
  //   list.add(second)
  //   list.add(third)
  //   list.add(fourth)
  //   list.add(fifth)
  //   list
  // }

  static fun create<Item>(capacity: Int /* Uint */ = 8): ArrayList<Item> {
    /// Creates a new, empty `ArrayList` with the given capacity.

    ArrayList<Item>(
      Array.fill<Option<Item>>(capacity, None<Item>()),
      0,
    )
  }

  mut let items: Array<Option<Item>>
  mut let length_: Int /* UInt */

  // TODO(marcelgarus): Getterize!
  fun capacity(): Int /* UInt */ {
    items.length
  }

  // fun grow() {
  //   /// Increases the capacity.

  //   let newItems: Array.fill<Option<Item>>(2 * capacity(), None)
  //   mut let index = 0
  //   while index < length {
  //     newItems.set(items.get(index))
  //     index = index + 1
  //   }
  // }
}

impl<Item> ArrayList<Item>: List<Item> {
  fun length(): Int { length_ }
  fun isEmpty(): Bool { length() == 0 }

  fun get(index: Int /* UInt */): Item {
    if index < length() {
      // TODO(marcelgarus): Error.
    }
    let a: Int = items.get(index)
    a.unwrap()
  }
}
