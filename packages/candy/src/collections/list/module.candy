use ...primitives
use ..iterable
public use .array

public trait List<Item>: Iterable<Item> {
  // builtin static fun of1<Item>(first: Item): ArrayList<Item>
  // builtin static fun of2<Item>(first: Item, second: Item): ArrayList<Item>
  // builtin static fun of3<Item>(first: Item, second: Item, third: Item): ArrayList<Item>
  // builtin static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): ArrayList<Item>
  // builtin static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): ArrayList<Item>

  // TODO(marcelgarus): Getterize!
  fun length(): Int /* UInt */
  // TODO(marcelgarus): Getterize!
  fun isEmpty(): Bool {
    // TODO(marcelgarus): Enable as soon as == is supported.
    // length == 0
    true
  }

  fun get(index: Int /* UInt */): Item
}

// impl<Item> List<Item>: GetOperator<Int, Item> /* GetOperator<UInt, Item> */
// TODO(JonasWanke): impl List<Item>: GetOperator<Range<UInt>, List<Item>>

public trait MutableList<Item>: List<Item> {
  fun set(index: Int /* UInt */, item: Item)
  fun add(item: Item)
  fun removeAt(index: Int /* UInt */): Item
  fun removeLast(): Item
  fun clear()
}
