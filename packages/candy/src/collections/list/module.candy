use ...primitives
use ..iterable
public use .array

public trait List<Item>: Iterable<Item> {
  // builtin static fun of1<Item>(first: Item): ArrayList<Item>
  // builtin static fun of2<Item>(first: Item, second: Item): ArrayList<Item>
  // builtin static fun of3<Item>(first: Item, second: Item, third: Item): ArrayList<Item>
  // builtin static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): ArrayList<Item>
  // builtin static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): ArrayList<Item>

  // TODO(marcelgarus): Getterize!
  fun length(): Int /* UInt */
  // TODO(marcelgarus): Getterize!
  fun isEmpty(): Bool {
    length() == 0
  }
  fun isNotEmpty(): Bool {
    !isEmpty()
  }

  fun get(index: Int /* UInt */): Item
}

// impl<Item> List<Item>: GetOperator<Int, Item> /* GetOperator<UInt, Item> */
// TODO(JonasWanke): impl List<Item>: GetOperator<Range<UInt>, List<Item>>

public trait MutableList<Item>: List<Item> {
  fun set(index: Int /* UInt */, item: Item)
  // TODO(marcelgarus): Rename to add as soon as the naming conflict with + is resolved.
  fun append(item: Item)
  fun removeAt(index: Int /* UInt */): Item
  fun removeLast(): Item
  fun clear()
}
