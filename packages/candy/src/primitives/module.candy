use ..operators
public use .maybe
public use .result

public builtin trait Any
/// Could be anything, from an `Int8` to a `String` to a pancake with raspberries.
///
/// All types are assignable to `Any`.

// builtin impl Any: ToString

// public builtin trait ToString {
//   fun toString(): String
// }

public builtin class Unit
/// The default type for expressions that don't have an explicit result.
///
/// Has only one instance, `unit`. Because there's only one instance, instances of this type carry
/// no information.
///
/// Here are a few examples of expressions that evaluate to `Unit`:
///
/// * assignments like `let a = 5`
/// * function calls of functions without an explicit return value like `print("Hello, world!")`
/// * the explicit unit instance: `unit`

public builtin class Never
/// Can never be created. It's still useful to specify that an expression will never evaluate. More
/// specifically, this is the case in the following cases:
///
/// * An expression runs endlessly.
/// * An expression aborts the current control flow.
///
/// Here are a few examples for expressions that evaluate to `Never`:
///
/// * `return 5`
/// * `break`
/// * `throw "blub"`
/// * `loop {}`
///
/// There are no instances of `Never`. That's why we can claim that all (zero) instances can be
/// converted to all other types loslessly â€“ you can assign `Never` to anything:
/// `let a: Int = return 5` works, because the result of `return 5` is never created.

public builtin class Bool
/// A type that can be either `true` or `false`.
builtin impl Bool: Equals & And & Or & Opposite & Implies

public builtin trait Number

public builtin class Int
builtin impl Int: Number
builtin impl Int: Equals & Comparable
builtin impl Int: Add & Subtract & Negate & Multiply & Divide & DivideTruncating & Modulo
// builtin impl Int: Number

public builtin class Float
builtin impl Float: Number
builtin impl Float: Equals & Comparable
builtin impl Float: Add & Subtract & Negate & Multiply & Divide & DivideTruncating & Modulo
// builtin impl Float: Number

public builtin class String
// builtin impl String: PlusOperator<This, This>

fun run<T>(code: () => T): T {
  /// A function that simply runs the given lambda with no arguments.
  ///
  /// Calling this function is the same like calling the `code` by adding parnethesis at the end,
  /// but it looks nicer:
  ///
  /// ```
  /// let a = run {
  ///   // Some code that can create local variables without cluttering the surrounding namespace.
  /// }
  /// ```

  code()
}

fun doNotRun(code: () => Unit) {
  /// A function that doesn't run the given lambda.
  ///
  /// This function is useful during the development phase do mark `code` that's not ready to run
  /// yet. In contrast to commenting out the `code`, the `code` is still part of the analyzed
  /// program. This has the following effects:
  ///
  /// * Refactorings, like renaming of classes, also affect the `code`.
  /// * Candy stops reporting linter warnings for fields and functions in the outer scope that are
  ///   only used in the `code`.
  /// * Making the `code` invalid (for example, by deleting needed classes, functions, or
  ///   properties) results in compiler errors.
}
