use ....parsers

impl<Item, Output> Parser<Item, Output> {
  fun star(): Parser<Item, List<Output>> { repeat(0, None<Int>()) }
  fun plus(): Parser<Item, List<Output>> { repeat(1, None<Int>()) }
  fun times(count: Int): Parser<Item, List<Output>> { repeat(count, Some<Int>(count)) }
  fun repeat(minimum: Int, maximum: Maybe<Int>): Parser<Item, List<Output>> {
    PossessiveRepeatingParser<Item, Output>(this, minimum, maximum)
  }
}

class PossessiveRepeatingParser<Item, Output> {
  let parser: Parser<Item, Output>
  let minimum: Int
  let maximum: Maybe<Int>
}
impl<Item, Output> PossessiveRepeatingParser<Item, Output>: Parser<Item, List<Output>> {
  fun parse(context: Context<Item>): Result<Success<List<Output>>, Failure> {
    let elements = MutableList.empty<Output>()

    mut let currentContext = context
    while (elements as Iterable<Output>).length() < minimum {
      let result = parser.parse(currentContext)
      if result is Error<Item, Output> { return result }
      let result = result.unwrap()

      elements.append(result.output)
      currentContext = Context<Item>(currentContext.buffer, result.offset)
    }

    let isUnbounded = maximum is None<Int>
    while isUnbounded || (elements as Iterable<Output>).length() < maximum.unwrap() {
      let result = parser.parse(currentContext)
      if result is Error<Item, Output> { return currentContext.success<List<Output>>(elements) }
      let result = result.unwrap()

      elements.append(result.output)
      currentContext = Context<Item>(currentContext.buffer, result.offset)
    }

    return Ok<Success<List<Output>>, Failure>(Success<List<Output>>(elements, currentContext.offset))
  }
}
