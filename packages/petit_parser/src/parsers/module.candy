public use .action
public use .combinator
public use .custom
public use .miscellaneous
public use .repeating

public class Context<Item> {
  public let buffer: List<Item>
  public let offset: Int

  public fun success<Output>(output: Output): Success<Output> { Success<Output>(output, offset) }
  public fun failure(message: String): Failure { Failure(message, offset) }
}

public class Success<Output> {
  public let output: Output
  public let offset: Int
}
public class Failure {
  public let message: String
  public let offset: Int
}

public trait Parser<Item, Output> {
  fun parse(context: Context<Item>): Result<Success<Output>, Failure>
  fun parseInput(input: List<Item>): Result<Success<Output>, Failure> {
    parse(Context<Item>(input, 0))
  }

  // TODO(JonasWanke): move the following function to `action/map.candy`
  fun map<NewOutput>(mapper: (Output) => NewOutput): Parser<Item, NewOutput> {
    MapParser<Item, Output, NewOutput>(this, mapper)
  }

  // TODO(JonasWanke): move the following function to `combinator/choice.candy`
  fun or<OutputB>(other: Parser<Item, OutputB>): Parser<Item, Output | OutputB> {
    let castedThis = this as Parser<Item, Output | OutputB>
    let castedOther = other as Parser<Item, Output | OutputB>
    ChoiceParser<Item, Output | OutputB>(List.of2<Parser<Item, Output | OutputB>>(castedThis, castedOther))
  }

  // TODO(JonasWanke): move the following function to `combinator/optional.candy`
  fun optional(): Parser<Item, Maybe<Output>> { OptionalParser<Item, Output>(this) }

  // TODO(JonasWanke): move the following function to `combinator/sequence.candy`
  fun sequence<OutputB>(other: Parser<Item, OutputB>): Parser<Item, (Output, OutputB)> {
    let parsers = List.of2<Parser<Item, Output | OutputB>>(
        this as Parser<Item, Output | OutputB>,
        other as Parser<Item, Output | OutputB>,
    )
    let sequenceParser = SequenceParser<Item, Output | OutputB>(parsers)
    let mappedParser = (sequenceParser as Parser<Item, List<Output | OutputB>>)
        .map<(Output, OutputB)>({
            let iterable = it as Iterable<Output | OutputB>
            Tuple(iterable.first().unwrap() as Output, iterable.second().unwrap() as OutputB)
        })
    mappedParser as Parser<Item, (Output, OutputB)>
  }

  // TODO(JonasWanke): move the following functions to `miscellaneous/end_of_input.candy`
  fun end(message: String): Parser<Item, Output> {
    let sequenceParser = sequence<Unit>(EndOfInputParser<Item>(message))
    sequenceParser.map<Output>({ it.first })
  }

  // TODO(JonasWanke): move the following functions to `repeating/possessive.candy`
  fun star(): Parser<Item, List<Output>> { repeat(0, None<Int>()) }
  fun plus(): Parser<Item, List<Output>> { repeat(1, None<Int>()) }
  fun times(count: Int): Parser<Item, List<Output>> { repeat(count, Some<Int>(count)) }
  fun repeat(minimum: Int, maximum: Maybe<Int>): Parser<Item, List<Output>> {
    PossessiveRepeatingParser<Item, Output>(this, minimum, maximum)
  }
}
