use compiler_utils
use dart_code
use hir
use incremental

use ...expressions
use ...types
use ..utils

public fun compileTypeInstantiationValueExpression(
  context: QueryContext<List<CompilerError>>,
  uri: HirValueExpressionUri,
  expression: HirTypeInstantiationValueExpression,
): List<DartStatement> {
  query<List<DartStatement>, List<CompilerError>>(
    context,
    "code_generator_dart.compileTypeInstantiationValueExpression",
    DataTuple2<HirValueExpressionUri, HirTypeInstantiationValueExpression>(uri, expression), {
    let statements = MutableList.empty<DartStatement>()
    statements.appendAll(compileValueExpression(context, expression.valueArgument))

    // TODO(soon, JonasWanke): use `compileNamedType` and supply type arguments when we can get the type of this expression
    let compiledType = DartNamedType(DartIdentifier("SomeType", None<String>()), List.empty<DartType>())
    statements.append(saveValueExpression(
      context,
      uri,
      expression,
      (compiledType as DartExpression)
        .call1(getValueExpressionResultIdentifier(context, expression.valueArgument)),
    ))
    Tuple(statements, List.empty<CompilerError>())
  })
}

public fun compileStructValueExpression(
  context: QueryContext<List<CompilerError>>,
  uri: HirValueExpressionUri,
  expression: HirStructValueExpression,
): List<DartStatement> {
  query<List<DartStatement>, List<CompilerError>>(
    context,
    "code_generator_dart.compileStructValueExpression",
    DataTuple2<HirValueExpressionUri, HirStructValueExpression>(uri, expression), {
    let statements = MutableList.empty<DartStatement>()
    statements.appendAll(
      (expression.fields.values() as Iterable<HirValueExpressionUri>)
        .expand<DartStatement>({ compileValueExpression(context, it) }),
    )

    // TODO(soon, JonasWanke): use `compileStructType` when we can get the struct type of this expression
    let compiledType = DartNamedType(DartIdentifier("Struct", None<String>()), List.empty<DartType>())
    statements.append(saveValueExpression(
      context,
      uri,
      expression,
      (compiledType as DartExpression).call(
        positionalArguments = (expression.fields.entries().toList()
          .sortedBy<String>({ it.first }) as Iterable<(String, HirValueExpressionUri)>)
          .map<DartExpression>({ getValueExpressionResultIdentifier(context, it.second) })
          .toList(),
        namedArguments = Map.empty<String, DartExpression>(),
        typeArguments = List.empty<DartType>(),
      ),
    ))
    Tuple(statements, List.empty<CompilerError>())
  })
}
