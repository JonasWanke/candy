use compiler_utils
use dart_code
use hir
use incremental

use ...expressions
use ...types
use ..body
use ..utils

let thisParameterName = "$this"

public fun compileLambdaExpression(
  context: QueryContext<List<CompilerError>>,
  expression: HirLambdaExpression,
): DartStatement {
  query<DartStatement, List<CompilerError>>(
    context,
    "code_generator_dart.compileLambdaExpression",
    expression, {
    mut let parameters = expression.parameters
    expression.receiverType.do({
      parameters = List.of1<HirLambdaParameter>(HirLambdaParameter(thisParameterName, it))
        .followedByList(parameters)
      unit
    })
    let parameters = (expression.parameters as Iterable<HirLambdaParameter>)
      .map<DartParameter>({
        DartParameter(
          name = it.name,
          isRequired = true,
          type = Some<DartType>(compileInlineType(context, it.type)),
          defaultValue = None<DartExpression>(),
        )
      })
      .toList()

    let expressions = (expression.expressions as Iterable<HirExpressionUri<HirExpression>>)
      .map<HirExpression>({ getExpression<HirExpression>(it) })
      .toList()

    let dartExpression = DartClosure(
      returns = Some<DartType>(compileInlineType(context, expression.returnType)),
      requiredParameters = parameters,
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = compileExpressionsToBody(context, expressions),
    )
    Tuple(saveExpression(context, expression, dartExpression), List.empty<CompilerError>())
  })
}
