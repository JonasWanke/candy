use ast
use compiler_utils
use dart_code
use hir
use incremental

use ...declarations
use ...expressions
use ...types
use ..utils

public fun compileFunctionCallValueExpression(
  context: QueryContext<List<CompilerError>>,
  uri: HirValueExpressionUri,
  expression: HirFunctionCallValueExpression,
): List<DartStatement> {
  query<List<DartStatement>, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunctionCallValueExpression",
    DataTuple2<HirValueExpressionUri, HirFunctionCallValueExpression>(uri, expression), {
    // TODO(soon, JonasWanke): Handle static function calls.
    let statements = MutableList.empty<DartStatement>()
    let receiver = expression.receiver
      .map<DartExpression>({
        if (it is HirTypeExpression) { todo("soon, JonasWanke: support type instantiations") }
        statements.appendAll(compileValueExpression(context, it as HirValueExpressionUri))
        // TODO(soon, JonasWanke): Cast the receiver to the correct trait.
        getValueExpressionResultIdentifier(context, it as HirValueExpressionUri)
      })
      .orElse({
        let moduleHir = (expression.function.parent as HirModule)
        DartIdentifier(
          mangleName(context, expression.function.name()),
          Some<String>(moduleHirToImportUrl(context, moduleHir)),
        )
      })

    let function = receiver.dot(expression.function.name())

    let declaredTypeParameters = (expression.function.typeParameters(context) as Iterable<HirParameterType>)
    assert(
      declaredTypeParameters.map<String>({ it.name }).toSet()
        .unsafeEquals(expression.typeArguments.keys().toSet()),
      "Supplied type parameters for a function call don't exactly match the function's declared type parameters."
    )
    let typeArgumentsInCorrectOrder = declaredTypeParameters
      .map<HirInlineType>({ expression.typeArguments.get(it.name).unwrap() })
    let typeArguments = typeArgumentsInCorrectOrder
      .map<DartType>({ compileInlineType(context, it) })
      .toList()

    let valueArgumentsInCorrectOrder = (expression.function.ast(context).valueParameters as Iterable<AstValueParameter>)
      .map<HirValueExpressionUri>({ expression.valueArguments.get(it.name.value).unwrap() })
    let valueArguments = typeArgumentsInCorrectOrder
    // TODO(soon, JonasWanke): Transform these types to the static instance classes.
      .map<DartExpression>({ DartIdentifier("SomeType", None<String>()) })
      .followedBy(
        valueArgumentsInCorrectOrder
          .map<DartExpression>({ getValueExpressionResultIdentifier(context, it ) }),
      )
      .toList()

    let result = function.call(
      positionalArguments = valueArguments,
      namedArguments = Map.empty<String, DartExpression>(),
      typeArguments = typeArguments,
    )
    statements.append(saveValueExpression(context, uri, expression, result))
    Tuple(statements, List.empty<CompilerError>())
  })
}


public fun getTypeParameterValueParameterName(
  context: QueryContext<List<CompilerError>>,
  typeParameter: HirParameterType,
): String {
  query<String, List<CompilerError>>(
    context,
    "code_generator_dart.getTypeParameterValueParameterName",
    typeParameter, {
    assert(
      typeParameter.declaration is HirFunction,
      "Value parameters for type parameters only work for function calls.",
    )

    Tuple("$type_{typeParameter.name}", List.empty<CompilerError>())
  })
}
