use compiler_utils
use dart_code
use hir
use incremental

use ...utils
use ..name_mangling
use ..type

public fun compileTrait(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<List<DartDeclaration>, List<CompilerError>>(
    context,
    "code_generator_dart.compileTrait",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let output = List
      .of1<DartDeclaration>(compileTraitValue(context, package, traitHir))
      .followedByList(compileInstanceFunctionFunctions(context, package, traitHir))
      .followedByList(compileImplImplFunctions(context, package, traitHir, true))
      .followedByList(List.of1<DartDeclaration>(compileTraitInlineType(context, package, traitHir)))
      .followedByList(compileStaticFunctionFunctions(context, package, traitHir))
      .followedByList(compileStaticUpperBoundImplFunctions(context, package, traitHir))
      .followedByList(compileImplImplFunctions(context, package, traitHir, false))
    Tuple(output, List.empty<CompilerError>())
  })
}

fun compileTraitValue(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileTraitValue",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let name = compileNamedType(
      context,
      HirNamedType(traitHir, List.empty<HirInlineType>()),
      "Value",
    ).name
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    let implFunctionTraits = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
      .cast<HirNamedType>()
      .toList()
    let functions = ((traitHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirFunction>()
      .where({ it.parentFunction(context) is None && !it.isStatic(context) })
      .toList()

    body.append(DartConstructor(
      className = name,
      name = Some<String>("_"),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List
        .of2<DartParameter | DartInitializingFormal>(
          DartInitializingFormal("inlineType", defaultValue = None<DartExpression>()),
          DartInitializingFormal("value", defaultValue = None<DartExpression>()),
        )
        // Impl functions
        .followedByList(
          (implFunctionTraits as Iterable<HirNamedType>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(
                getTraitUpperBoundImplFunctionName(context, it)),
                None<DartExpression>(),
              ),
            })
            .toList(),
        )
        // Function functions
        .followedByList(
          (functions as Iterable<HirFunction>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(mangleName(context, it.name_)), None<DartExpression>()),
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    // Reference to our inline type
    body.append(DartField(
      "inlineType",
      // TODO(never, JonasWanke): add `@override`
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(getDeclarationInlineTypeIdentifier(context, traitHir)),
      initialValue = None<DartExpression>(),
    ))

    // Reference to our value
    body.append(DartField(
      "value",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(valueType),
      initialValue = None<DartExpression>(),
    ))

    // Impl functions
    body.appendAll(
      (implFunctionTraits as Iterable<HirNamedType>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            getTraitUpperBoundImplFunctionName(context, it),
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(staticImplFunctionType),
            initialValue = None<DartExpression>(),
          )
        }),
    )

    // Function functions
    body.appendAll(
      (functions as Iterable<HirFunction>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          generateFieldForFunction(context, it)
        }),
    )

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(traitValueType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun compileInstanceFunctionFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  // ...
}

fun compileInstanceUpperBoundImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileInstanceUpperBoundImplFunctions",
    DataTuple2<Package, HirTrait>(package, traitHir), {
      let upperBounds = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
        .cast<HirNamedType>()
      let functions = upperBounds
        .map<DartFunction>({
          DartFunction(
            isStatic = false,
            name = getTraitUpperBoundImplFunctionName(context, traitHir, it, "Value"),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(valueType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = List.of1<DartParameter>(DartParameter(
              name = "$this",
              isRequired = true,
              type = Some<DartType>(valueType),
              defaultValue = None<DartExpression>(),
            )),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartInlineBody(
              (DartParenthesizedExpression(
                (DartIdentifier("$this", None<String>()) as DartExpression)
                  .as_(DartNamedType(compileNamedType(
                    context,
                    HirNamedType(traitHir, List.empty<HirInlineType>()),
                    "Value",
                  ))),
              ) as DartExpression)
                .dot(getTraitUpperBoundImplFunctionName(context, it))
                .call0(),
            )),
          )
        })
        .toList()
      Tuple(functions, List.empty<CompilerError>())
  })
}

fun compileTraitInlineType(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileTraitInlineType",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let name = compileNamedType(
      context,
      HirNamedType(traitHir, List.empty<HirInlineType>()),
      "InlineType",
    ).name
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    let implFunctionTraits = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
      .cast<HirNamedType>()
      .toList()
    let functions = ((traitHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirFunction>()
      .where({ it.parentFunction(context) is None && it.isStatic(context) })
      .toList()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .expand<DartParameter | DartInitializingFormal>({
          List.of2<DartParameter | DartInitializingFormal>(
            DartInitializingFormal(
              name = "typeArgument$trait${it.name}",
              defaultValue = None<DartExpression>(),
            ),
            DartInitializingFormal(
              name = getTypeArgumentUpperBoundImplFunctionName(context, it),
              defaultValue = None<DartExpression>(),
            ),
          )
        })
        .toList()
        // Impl functions
        .followedByList(
          (implFunctionTraits as Iterable<HirNamedType>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(
                getTraitUpperBoundImplFunctionName(context, it)),
                None<DartExpression>(),
              ),
            })
            .toList(),
        )
        // Function functions
        .followedByList(
          (functions as Iterable<HirFunction>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(mangleName(context, it.name_)), None<DartExpression>()),
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "create",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(valueType),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        name = "value",
        isRequired = true,
        type = Some<DartType>(valueType),
        defaultValue = None<DartExpression>(),
      )),
      // TODO(soon, JonasWanke): Integrate function functions.
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartBlock(List.of1<DartStatement | DartComment>(DartReturn(
        (getDeclarationValueIdentifier(context, traitHir) as DartExpression)
          .dot("_")
          .callPositional(
            List.of2<DartExpression>(dartThis, DartIdentifier("value", None<String>())),
          ),
        // TODO(soon, JonasWanke): Integrate function functions.
      )))),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "equals",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        name = "other",
        isRequired = true,
        type = Some<DartType>(inlineTypeType),
        defaultValue = None<DartExpression>(),
      )),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("isOfThisType", None<String>()) as DartExpression)
          .callPositional(
            (traitHir.typeParameters(context) as Iterable<HirParameterType>)
              .map<DartExpression>({ DartIdentifier("typeArgument$trait${it.name}", None<String>()) })
              .toList()
              .followedByList(List.of1<DartExpression>(DartIdentifier("other", None<String>()))),
          ),
      )),
    ))
    body.append(DartFunction(
      isStatic = true,
      name = "isOfThisType",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .map<DartParameter>({
          DartParameter(
            name = "typeArgument$trait${it.name}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(List.of1<DartParameter>(DartParameter(
          name = "inlineType",
          isRequired = true,
          type = Some<DartType>(inlineTypeType),
          defaultValue = None<DartExpression>(),
        ))),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartBlock(List.of1<DartStatement | DartComment>(DartReturn(
        (traitHir.typeParameters(context) as Iterable<HirParameterType>)
          .map<DartExpression>({
            let name = "typeArgument$trait${it.name}"
            (DartIdentifier(name, None<String>()) as DartExpression)
              .equals(DartIdentifier("inlineType", None<String>()).dot(name))
          })
          .foldLeft<DartExpression>(
            (DartIdentifier("inlineType", None<String>()) as DartExpression).is_(name),
            { result, item => result.and(item) },
          ),
      )))),
    ))

    body.appendAll(
      (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .expand<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          List.of2<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>(
            DartField(
              name = "typeArgument$trait${it.name}",
              docComment = None<String>(),
              isStatic = false,
              mutability = DartFinal(),
              type = Some<DartType>(inlineTypeType),
              initialValue = None<DartExpression>(),
            ),
            DartField(
              name = getTypeArgumentUpperBoundImplFunctionName(context, it),
              docComment = None<String>(),
              isStatic = false,
              mutability = DartFinal(),
              type = Some<DartType>(instanceImplFunctionType),
              initialValue = None<DartExpression>(),
            ),
          )
        }),
    )

    // Impl functions
    body.appendAll(
      (implFunctionTraits as Iterable<HirNamedType>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            getTraitUpperBoundImplFunctionName(context, it),
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(staticImplFunctionType),
            initialValue = None<DartExpression>(),
          )
        }),
    )

    // Function functions
    body.appendAll(
      (functions as Iterable<HirFunction>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          generateFieldForFunction(context, it)
        }),
    )

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(traitNamedInlineTypeType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

DartField generateFieldForFunction(
  context: QueryContext<List<CompilerError>>,
  function: HirFunction,
) {
  DartField(
    mangleName(context, it.name_),
    docComment = None<String>(),
    isStatic = false,
    mutability = DartFinal(),
    type = Some<DartType>(DartFunctionType(
      parameters = (it.first.typeParameters(context) as Iterable<HirParameterType>)
        .map<DartType | DartParameter>({
          DartParameter(
            name = "typeArgument$function${it.name}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(
          (it.first.valueParameters(context) as Iterable<HirValueParameter>)
            .map<DartType | DartParameter>({
              DartParameter(
                name = it.name,
                isRequired = true,
                type = Some<DartType>(valueType),
                defaultValue = None<DartExpression>(),
              )
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartType | DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      _returns = Some<DartType>(valueType),
    )),
    initialValue = None<DartExpression>(),
  )
}

fun compileStaticFunctionFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  // ...
}

fun compileStaticUpperBoundImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileStaticUpperBoundImplFunctions",
    DataTuple2<Package, HirTrait>(package, traitHir), {
      let upperBounds = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
        .cast<HirNamedType>()
      let functions = upperBounds
        .map<DartFunction>({
          DartFunction(
            isStatic = false,
            name = getTraitUpperBoundImplFunctionName(context, traitHir, it, "InlineType"),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(inlineTypeType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = List.of1<DartParameter>(DartParameter(
              name = "$staticThis",
              isRequired = true,
              type = Some<DartType>(inlineTypeType),
              defaultValue = None<DartExpression>(),
            )),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartInlineBody(
              (DartParenthesizedExpression(
                (DartIdentifier("$staticThis", None<String>()) as DartExpression)
                  .as_(DartNamedType(compileNamedType(
                    context,
                    HirNamedType(traitHir, List.empty<HirInlineType>()),
                    "InlineType",
                  ))),
              ) as DartExpression)
                .dot(getTraitUpperBoundImplFunctionName(context, it))
                .call0(),
            )),
          )
        })
        .toList()
      Tuple(functions, List.empty<CompilerError>())
  })
}

fun compileImplImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
  isStatic: Bool,
): List<DartDeclaration> {
  // TODO(soon): continue implementing this
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileImplImplFunctions",
    DataTuple3<Package, HirTrait, Bool>(package, traitHir, isStatic), {
      let isStaticString = if (isStatic) { "InlineType" } else { "Value" }
      let thisString = if (isStatic) { "$staticThis" } else { "$instanceThis" }
      let implFunctionType = if (isStatic) { staticImplFunctionType } else { instanceImplFunctionType }

      let impls = getImplImplFunctionName(context, traitHir, package)
        .items()
        .where({ it.implementedTrait(context) is Some })
      let functions = impls
        .map<DartDeclaration>({ implHir =>
          let baseType = implHir.baseType(context)
          let implementedTraitNamedType = (implHir.implementedTrait(context).unwrap() as HirNamedType)
          let implementedTrait = (implementedTraitNamedType.declaration as HirTrait)

          let overridingFunctions = ((implHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
            .whereType<HirFunction>()
            .where({ it.isStatic(context) == isStatic })
            .toList()
          let functionFunctionClosuresCommonTypeArgumentValueParameters = (implHir.typeParameters(context) as Iterable<HirParameterType>)
            .expand<DartParameter>({
              List.of2<DartParameter>(
                DartParameter(
                  name = "typeArgument$impl${it.name}",
                  isRequired = true,
                  type = Some<DartType>(inlineTypeType),
                  defaultValue = None<DartExpression>(),
                ),
                DartParameter(
                  name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                  isRequired = true,
                  type = Some<DartType>(implFunctionType),
                  defaultValue = None<DartExpression>(),
                ),
              )
            })
            .toList()
          let functionFunctionClosuresCommonTypeArgumentValueArguments = (implHir.typeParameters(context) as Iterable<HirParameterType>)
            .expand<DartExpression>({
              List.of2<DartExpression>(
                DartIdentifier("typeArgument$impl${it.name}", List.empty<String>()),
                DartIdentifier(getTypeArgumentUpperBoundImplFunctionName(context, it), None<String>()),
              )
            })
            .toList()

          let argumentTypeCheck = DartExpressionStatement(
            (dartAssert as DartExpression).call1(generateInlineTypeCheck(
              context,
              if (isStatic) {
                DartIdentifier(thisString, None<String>())
              } else {
                DartIdentifier(thisString, None<String>()).dot("inlineType")
              },
              baseType,
            )),
          )
          let body = DartBlock(
            if (isStatic) {
              List.of2<DartStatement | DartComment>(
                argumentTypeCheck,
                DartReturn(
                  (compileNamedType(context, implementedTraitNamedType) as DartExpression).callPositional(
                    (implementedTraitNamedType.parameterTypes as Iterable<HirInlineType>)
                      .zip<HirParameterType>(implementedTrait.typeParameters(context))
                      .expand<DartExpression>({
                        // Type arguments and impl functions for their upper bounds
                        let typeArgument = it.first
                        let typeParameter = it.second
                        let compiledInlineType = compileInlineType(context, typeArgument)
                        List.of2<DartExpression>(
                          compiledInlineType,
                          compileInlineTypeUpcast(
                            context,
                            compiledInlineType,
                            typeArgument,
                            typeParameter.upperBound(context),
                            package,
                            isStaticString,
                          ),
                        )
                      })
                      .toList()
                      // Impl functions for upper bounds
                      .followedByList(
                        (implementedTrait.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
                          .cast<HirNamedType>()
                          .map<DartExpression>({
                            compileInlineTypeUpcast(
                              context,
                              (DartIdentifier(thisString, None<String>()) as DartExpression),
                              baseType,
                              it,
                              isStaticString,
                            )
                          })
                          .toList(),
                      )
                      // Function functions
                      .followedByList(
                        ((implementedTrait as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
                          .whereType<HirFunction>()
                          .where({ it.parentFunction(context) is None && it.isStatic(context) })
                          .map<DartExpression>({ overriddenFunction =>
                            let overridingFunction = overridingFunctions
                              .singleWhere({
                                it.parentFunction(context).unwrap() == overriddenFunction
                              })
                              .unwrap()
                            DartClosure(
                              returns = Some<DartType>(valueType),
                              requiredParameters = functionFunctionClosuresCommonTypeArgumentValueParameters
                                .followedByList(
                                  (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                    .expand<DartParameter>({
                                      List.of2<DartParameter>(
                                        DartParameter(
                                          name = "typeArgument$function${it.name}",
                                          isRequired = true,
                                          type = Some<DartType>(inlineTypeType),
                                          defaultValue = None<DartExpression>(),
                                        ),
                                        DartParameter(
                                          name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                                          isRequired = true,
                                          type = Some<DartType>(implFunctionType),
                                          defaultValue = None<DartExpression>(),
                                        ),
                                      )
                                    })
                                    .toList(),
                                )
                                .followedByList(
                                  (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                    .map<DartParameter>({
                                      DartParameter(
                                        name = it.name,
                                        isRequired = true,
                                        type = Some<DartType>(valueType),
                                        defaultValue = None<DartExpression>(),
                                      )
                                    })
                                    .toList(),
                                ),
                              positionalParameters = List.empty<DartParameter>(),
                              namedParameters = List.empty<DartParameter>(),
                              body = DartInlineBody(
                                (DartIdentifier(
                                  getFunctionInImplName(context, overridingFunction),
                                  None<String>(),
                                ) as DartExpression)
                                  .callPositional(
                                    functionFunctionClosuresCommonTypeArgumentValueArguments
                                      .followedByList(
                                        (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                          .expand<DartExpression>({
                                            List.of2<DartExpression>(
                                              DartIdentifier("typeArgument$function${it.name}", None<String>()),
                                              DartIdentifier(getTypeArgumentUpperBoundImplFunctionName(context, it), None<String>()),
                                            )
                                          })
                                          .toList(),
                                      )
                                      .followedByList<DartExpression>(List.of1<DartExpression>(
                                        DartIdentifier(thisString, None<String>()),
                                      ))
                                      .followedByList(
                                        (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                          .map<DartExpression>({ DartIdentifier(it.name, None<String>()) })
                                          .toList(),
                                      )
                                  ),
                              ),
                            )
                          })
                          .toList(),
                      ),
                  ),
                ),
              )
            } else {
              List.of3<DartStatement | DartComment>(
                argumentTypeCheck,
                DartFieldStatement(DartField(
                  name = "staticInstance",
                  docComment = None<String>(),
                  isStatic = false,
                  mutability = DartFinal(),
                  type = Some<DartType>(inlineTypeType),
                  initialValue = Some<DartExpression>(
                    (DartIdentifier(getImplImplFunctionName(context, implHir, "InlineType"), None<String>()) as DartExpression)
                      .call1(
                        DartParenthesizedExpression(
                          (DartIdentifier(thisString, None<String>()) as DartExpression)
                            .as_(DartNamedType(
                              compileInlineTypeValue(context, implHir.baseType(context)),
                              List.empty<DartType>(),
                            )),
                        ).as_(DartNamedType(
                          compileInlineTypeInlineType(context, implHir.baseType(context)),
                          List.empty<DartType>(),
                        )),
                      ),
                  ),
                )),
                DartReturn(
                  DartParenthesizedExpression(
                    (DartIdentifier("staticInstance", None<String>()) as DartExpression)
                      .as_(DartType(
                        compileNamedType(context, implementedTraitNamedType),
                        List.empty<DartType>(),
                      )),
                  ).dot("create")
                    .callPositional(
                      (implementedTraitNamedType.parameterTypes as Iterable<HirInlineType>)
                        .zip<HirParameterType>(implementedTrait.typeParameters(context))
                        .map<DartExpression>({
                          // Impl functions for upper bounds of type arguments
                          let typeArgument = it.first
                          let typeParameter = it.second
                          compileInlineTypeUpcast(
                            context,
                            compileInlineType(context, typeArgument),
                            typeArgument,
                            typeParameter.upperBound(context),
                            package,
                            isStaticString,
                          )
                        })
                        .toList()
                        // Impl functions for upper bounds
                        .followedByList(
                          (implementedTrait.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
                            .cast<HirNamedType>()
                            .map<DartExpression>({
                              compileInlineTypeUpcast(
                                context,
                                (DartIdentifier(thisString, None<String>()) as DartExpression),
                                baseType,
                                it,
                                isStaticString,
                              )
                            })
                            .toList(),
                        )
                        // Function functions
                        .followedByList(
                          ((implementedTrait as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
                            .whereType<HirFunction>()
                            .where({ it.parentFunction(context) is None && it.isStatic(context) })
                            .map<DartExpression>({ overriddenFunction =>
                              let overridingFunction = overridingFunctions
                                .singleWhere({
                                  it.parentFunction(context).unwrap() == overriddenFunction
                                })
                                .unwrap()
                              DartClosure(
                                returns = Some<DartType>(valueType),
                                requiredParameters = functionFunctionClosuresCommonTypeArgumentValueParameters
                                  .followedByList(
                                    (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                      .expand<DartParameter>({
                                        List.of2<DartParameter>(
                                          DartParameter(
                                            name = "typeArgument$function${it.name}",
                                            isRequired = true,
                                            type = Some<DartType>(inlineTypeType),
                                            defaultValue = None<DartExpression>(),
                                          ),
                                          DartParameter(
                                            name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                                            isRequired = true,
                                            type = Some<DartType>(implFunctionType),
                                            defaultValue = None<DartExpression>(),
                                          ),
                                        )
                                      })
                                      .toList(),
                                  )
                                  .followedByList(
                                    (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                      .map<DartParameter>({
                                        DartParameter(
                                          name = it.name,
                                          isRequired = true,
                                          type = Some<DartType>(valueType),
                                          defaultValue = None<DartExpression>(),
                                        )
                                      })
                                      .toList(),
                                  ),
                                positionalParameters = List.empty<DartParameter>(),
                                namedParameters = List.empty<DartParameter>(),
                                body = DartInlineBody(
                                  (DartIdentifier(
                                    getFunctionInImplName(context, overridingFunction),
                                    None<String>(),
                                  ) as DartExpression)
                                    .callPositional(
                                      functionFunctionClosuresCommonTypeArgumentValueArguments
                                        .followedByList(
                                          (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                            .expand<DartExpression>({
                                              List.of2<DartExpression>(
                                                DartIdentifier("typeArgument$function${it.name}", None<String>()),
                                                DartIdentifier(getTypeArgumentUpperBoundImplFunctionName(context, it), None<String>()),
                                              )
                                            })
                                            .toList(),
                                        )
                                        .followedByList<DartExpression>(List.of1<DartExpression>(
                                          DartIdentifier(thisString, None<String>()),
                                        ))
                                        .followedByList(
                                          (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                            .map<DartExpression>({ DartIdentifier(it.name, None<String>()) })
                                            .toList(),
                                        )
                                    ),
                                ),
                              )
                            })
                            .toList(),
                        )
                    ),
                ),
              )
            },
          )

          DartFunction(
            isStatic = false,
            name = getImplImplFunctionName(context, implHir, isStaticString),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(if (isStatic) { inlineTypeType } else { valueType }),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = (implHir.typeParameters(context) as Iterable<HirParameterType>)
              .expand<DartParameter>({
                List.of2<DartParameter>(
                  DartParameter(
                    name = "typeArgument$impl${it.name}",
                    isRequired = true,
                    type = Some<DartType>(inlineTypeType),
                    defaultValue = None<DartExpression>(),
                  ),
                  DartParameter(
                    name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                    isRequired = true,
                    type = Some<DartType>(implFunctionType),
                    defaultValue = None<DartExpression>(),
                  ),
                )
              })
              .toList()
              .followedByList(List.of1<DartParameter>(DartParameter(
                name = thisString,
                isRequired = true,
                type = Some<DartType>(if (isStatic) { inlineTypeType } else { valueType }),
                defaultValue = None<DartExpression>(),
              ))),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(body),
          )
        })
        .toList()

    Tuple(functions, List.empty<CompilerError>())
  })
}


// trait A[AT: ATU] {
//   fun aStatic(aParameter: APS): ARS
//   fun aInstance(aParameter: API): ARI
// }

// trait B[BT: BTU]: A[ATU] {
//   fun bStatic(bParameter: BPS): BRS
//   fun bInstance(bParameter: BPI): BRI
// }

// trait C[CT: CTU]

// impl[CT: CTU] C[CT]: A[TU] {
//   fun aStatic(aParameter: APS): ARS { todo() }
//   fun aInstance(aParameter: API): ARI { todo() }
// }
// impl[CT: CTU] C[CT]: B[BTU] {
//   fun bStatic(bParameter: BPS): BRS { todo() }
//   fun bInstance(bParameter: BPI): BRI { todo() }
// }
