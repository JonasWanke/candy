use compiler_utils
use dart_code
use hir
use incremental

use ...utils
use ..name_mangling
use ..type

public fun compileTrait(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<List<DartDeclaration>, List<CompilerError>>(
    context,
    "code_generator_dart.compileTrait",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let output = List
      .of1<DartDeclaration>(compileTraitValue(context, package, traitHir))
      .followedByList(compileInstanceFunctionFunctions(context, package, traitHir))
      .followedByList(compileInstanceImplFunctions(context, package, traitHir))
      .followedByList(List.of1<DartDeclaration>(compileTraitInlineType(context, package, traitHir)))
      .followedByList(compileStaticFunctionFunctions(context, package, traitHir))
      .followedByList(compileStaticUpperBoundImplFunctions(context, package, traitHir))
      .followedByList(compileStaticImplImplFunctions(context, package, traitHir))
    Tuple(output, List.empty<CompilerError>())
  })
}

fun compileTraitValue(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileTraitValue",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let name = compileNamedType(
      context,
      HirNamedType(traitHir, List.empty<HirInlineType>()),
      "Value",
    ).name
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    let implFunctionTraits = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
      .cast<HirNamedType>()
      .toList()
    let functions = ((traitHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirFunction>()
      .where({ it.parentFunction(context) is None && !it.isStatic(context) })
      .toList()

    body.append(DartConstructor(
      className = name,
      name = Some<String>("_"),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List
        .of2<DartParameter | DartInitializingFormal>(
          DartInitializingFormal("inlineType", defaultValue = None<DartExpression>()),
          DartInitializingFormal("value", defaultValue = None<DartExpression>()),
        )
        // Impl functions
        .followedByList(
          (implFunctionTraits as Iterable<HirNamedType>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(
                getTraitUpperBoundImplFunctionName(context, it)),
                None<DartExpression>(),
              ),
            })
            .toList(),
        )
        // Function functions
        .followedByList(
          (functions as Iterable<HirFunction>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(mangleName(context, it.name_)), None<DartExpression>()),
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    // Reference to our inline type
    body.append(DartField(
      "inlineType",
      // TODO(never, JonasWanke): add `@override`
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(getDeclarationInlineTypeIdentifier(context, traitHir)),
      initialValue = None<DartExpression>(),
    ))

    // Reference to our value
    body.append(DartField(
      "value",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(valueType),
      initialValue = None<DartExpression>(),
    ))

    // Impl functions
    body.appendAll(
      (implFunctionTraits as Iterable<HirNamedType>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            getTraitUpperBoundImplFunctionName(context, it),
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(staticImplFunctionType),
            initialValue = None<DartExpression>(),
          )
        }),
    )
    
    // Function functions
    body.appendAll(
      (functions as Iterable<HirFunction>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          generateFieldForFunction(context, it)
        }),
    )

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(traitValueType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun compileInstanceFunctionFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  // ...
}

fun compileInstanceUpperBoundImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileInstanceUpperBoundImplFunctions",
    DataTuple2<Package, HirTrait>(package, traitHir), {
      let upperBounds = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
        .cast<HirNamedType>()
      let functions = upperBounds
        .map<DartFunction>({
          DartFunction(
            isStatic = false,
            name = getTraitUpperBoundImplFunctionName(context, traitHir, it, "Value"),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(valueType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = List.of1<DartParameter>(DartParameter(
              name = "$this",
              isRequired = true,
              type = Some<DartType>(valueType),
              defaultValue = None<DartExpression>(),
            )),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartInlineBody(
              (DartParenthesizedExpression(
                (DartIdentifier("$this", None<String>()) as DartExpression)
                  .as_(DartNamedType(compileNamedType(
                    context,
                    HirNamedType(traitHir, List.empty<HirInlineType>()),
                    "Value",
                  ))),
              ) as DartExpression)
                .dot(getTraitUpperBoundImplFunctionName(context, it))
                .call0(),
            )),
          )
        })
        .toList()
      Tuple(functions, List.empty<CompilerError>())
  })
}

fun compileInstanceImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  // ...
}

fun compileTraitInlineType(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileTraitInlineType",
    DataTuple2<Package, HirTrait>(package, traitHir), {
    let name = compileNamedType(
      context,
      HirNamedType(traitHir, List.empty<HirInlineType>()),
      "InlineType",
    ).name
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    let implFunctionTraits = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
      .cast<HirNamedType>()
      .toList()
    let functions = ((traitHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirFunction>()
      .where({ it.parentFunction(context) is None && it.isStatic(context) })
      .toList()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .expand<DartParameter | DartInitializingFormal>({
          List.of2<DartParameter | DartInitializingFormal>(
            DartInitializingFormal(
              name = "typeArgument$trait${it.name}",
              defaultValue = None<DartExpression>(),
            ),
            DartInitializingFormal(
              name = getTypeArgumentUpperBoundImplFunctionName(context, it),
              defaultValue = None<DartExpression>(),
            ),
          )
        })
        .toList()
        // Impl functions
        .followedByList(
          (implFunctionTraits as Iterable<HirNamedType>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(
                getTraitUpperBoundImplFunctionName(context, it)),
                None<DartExpression>(),
              ),
            })
            .toList(),
        )
        // Function functions
        .followedByList(
          (functions as Iterable<HirFunction>)
            .map<DartParameter | DartInitializingFormal>({
              DartInitializingFormal(mangleName(context, it.name_)), None<DartExpression>()),
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "create",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(valueType),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        name = "value",
        isRequired = true,
        type = Some<DartType>(valueType),
        defaultValue = None<DartExpression>(),
      )),
      // TODO(soon, JonasWanke): Integrate function functions.
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartBlock(List.of1<DartStatement | DartComment>(DartReturn(
        (getDeclarationValueIdentifier(context, traitHir) as DartExpression)
          .dot("_")
          .callPositional(
            List.of2<DartExpression>(dartThis, DartIdentifier("value", None<String>())),
          ),
        // TODO(soon, JonasWanke): Integrate function functions.
      )))),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "equals",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        name = "other",
        isRequired = true,
        type = Some<DartType>(inlineTypeType),
        defaultValue = None<DartExpression>(),
      )),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("isOfThisType", None<String>()) as DartExpression)
          .callPositional(
            (traitHir.typeParameters(context) as Iterable<HirParameterType>)
              .map<DartExpression>({ DartIdentifier("typeArgument$trait${it.name}", None<String>()) })
              .toList()
              .followedByList(List.of1<DartExpression>(DartIdentifier("other", None<String>()))),
          ),
      )),
    ))
    body.append(DartFunction(
      isStatic = true,
      name = "isOfThisType",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .map<DartParameter>({
          DartParameter(
            name = "typeArgument$trait${it.name}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(List.of1<DartParameter>(DartParameter(
          name = "inlineType",
          isRequired = true,
          type = Some<DartType>(inlineTypeType),
          defaultValue = None<DartExpression>(),
        ))),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartBlock(List.of1<DartStatement | DartComment>(DartReturn(
        (traitHir.typeParameters(context) as Iterable<HirParameterType>)
          .map<DartExpression>({
            let name = "typeArgument$trait${it.name}"
            (DartIdentifier(name, None<String>()) as DartExpression)
              .equals(DartIdentifier("inlineType", None<String>()).dot(name))
          })
          .foldLeft<DartExpression>(
            (DartIdentifier("inlineType", None<String>()) as DartExpression).is_(name),
            { result, item => result.and(item) },
          ),
      )))),
    ))

    body.appendAll(
      (traitHir.typeParameters(context) as Iterable<HirParameterType>)
        .expand<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          List.of2<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>(
            DartField(
              name = "typeArgument$trait${it.name}",
              docComment = None<String>(),
              isStatic = false,
              mutability = DartFinal(),
              type = Some<DartType>(inlineTypeType),
              initialValue = None<DartExpression>(),
            ),
            DartField(
              name = getTypeArgumentUpperBoundImplFunctionName(context, it),
              docComment = None<String>(),
              isStatic = false,
              mutability = DartFinal(),
              type = Some<DartType>(instanceImplFunctionType),
              initialValue = None<DartExpression>(),
            ),
          )
        }),
    )

    // Impl functions
    body.appendAll(
      (implFunctionTraits as Iterable<HirNamedType>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            getTraitUpperBoundImplFunctionName(context, it),
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(staticImplFunctionType),
            initialValue = None<DartExpression>(),
          )
        }),
    )

    // Function functions
    body.appendAll(
      (functions as Iterable<HirFunction>)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          generateFieldForFunction(context, it)
        }),
    )

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(traitNamedInlineTypeType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

DartField generateFieldForFunction(
  context: QueryContext<List<CompilerError>>,
  function: HirFunction,
) {
  DartField(
    mangleName(context, it.name_),
    docComment = None<String>(),
    isStatic = false,
    mutability = DartFinal(),
    type = Some<DartType>(DartFunctionType(
      parameters = (it.first.typeParameters(context) as Iterable<HirParameterType>)
        .map<DartType | DartParameter>({
          DartParameter(
            name = "typeArgument$function${it.name}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(
          (it.first.valueParameters(context) as Iterable<HirValueParameter>)
            .map<DartType | DartParameter>({
              DartParameter(
                name = it.name,
                isRequired = true,
                type = Some<DartType>(valueType),
                defaultValue = None<DartExpression>(),
              )
            })
            .toList(),
        ),
      positionalParameters = List.empty<DartType | DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      _returns = Some<DartType>(valueType),
    )),
    initialValue = None<DartExpression>(),
  )
}

fun compileStaticFunctionFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  // ...
}

fun compileStaticUpperBoundImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileStaticUpperBoundImplFunctions",
    DataTuple2<Package, HirTrait>(package, traitHir), {
      let upperBounds = (traitHir.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
        .cast<HirNamedType>()
      let functions = upperBounds
        .map<DartFunction>({
          DartFunction(
            isStatic = false,
            name = getTraitUpperBoundImplFunctionName(context, traitHir, it, "InlineType"),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(inlineTypeType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = List.of1<DartParameter>(DartParameter(
              name = "$staticThis",
              isRequired = true,
              type = Some<DartType>(inlineTypeType),
              defaultValue = None<DartExpression>(),
            )),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartInlineBody(
              (DartParenthesizedExpression(
                (DartIdentifier("$staticThis", None<String>()) as DartExpression)
                  .as_(DartNamedType(compileNamedType(
                    context,
                    HirNamedType(traitHir, List.empty<HirInlineType>()),
                    "InlineType",
                  ))),
              ) as DartExpression)
                .dot(getTraitUpperBoundImplFunctionName(context, it))
                .call0(),
            )),
          )
        })
        .toList()
      Tuple(functions, List.empty<CompilerError>())
  })
}

fun compileStaticImplImplFunctions(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  traitHir: HirTrait,
): List<DartDeclaration> {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileStaticImplImplFunctions",
    DataTuple2<Package, HirTrait>(package, traitHir), {
      let impls = getImplImplFunctionName(context, traitHir, package)
        .items()
        .where({ it.implementedTrait(context) is Some })
      let functions = impls
        .map<DartDeclaration>({ implHir =>
          let baseType = implHir.baseType(context)
          let implementedTraitNamedType = (implHir.implementedTrait(context).unwrap() as HirNamedType)
          let implementedTrait = (implementedTraitNamedType.declaration as HirTrait)

          let overridingFunctions = ((implHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
            .whereType<HirFunction>()
            .toList()
          let functionFunctionClosuresCommonTypeArgumentValueParameters = (implHir.typeParameters(context) as Iterable<HirParameterType>)
            .expand<DartParameter>({
              List.of2<DartParameter>(
                DartParameter(
                  name = "typeArgument$impl${it.name}",
                  isRequired = true,
                  type = Some<DartType>(inlineTypeType),
                  defaultValue = None<DartExpression>(),
                ),
                DartParameter(
                  name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                  isRequired = true,
                  type = Some<DartType>(staticImplFunctionType),
                  defaultValue = None<DartExpression>(),
                ),
              )
            })
            .toList()
          let functionFunctionClosuresCommonTypeArgumentValueArguments = (implHir.typeParameters(context) as Iterable<HirParameterType>)
            .expand<DartExpression>({
              List.of2<DartExpression>(
                DartIdentifier("typeArgument$impl${it.name}", List.empty<String>()),
                DartIdentifier(getTypeArgumentUpperBoundImplFunctionName(context, it), None<String>()),
              )
            })
            .toList()

          DartFunction(
            isStatic = false,
            name = getImplImplFunctionName(context, implHir, "InlineType"),
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(inlineTypeType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = (implHir.typeParameters(context) as Iterable<HirParameterType>)
              .expand<DartParameter>({
                List.of2<DartParameter>(
                  DartParameter(
                    name = "typeArgument$impl${it.name}",
                    isRequired = true,
                    type = Some<DartType>(inlineTypeType),
                    defaultValue = None<DartExpression>(),
                  ),
                  DartParameter(
                    name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                    isRequired = true,
                    type = Some<DartType>(staticImplFunctionType),
                    defaultValue = None<DartExpression>(),
                  ),
                )
              })
              .toList()
              .followedByList(List.of1<DartParameter>(DartParameter(
                name = "$staticThis",
                isRequired = true,
                type = Some<DartType>(inlineTypeType),
                defaultValue = None<DartExpression>(),
              ))),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartBlock(List.of2<DartStatement | DartComment>(
              DartExpressionStatement(
                (dartAssert as DartExpression).call1(generateInlineTypeCheck(
                  context,
                  DartIdentifier("$staticThis", None<String>()),
                  baseType,
                )),
              ),
              DartReturn(
                (compileNamedType(context, implementedTraitNamedType) as DartExpression).callPositional(
                  (implementedTraitNamedType.parameterTypes as Iterable<HirInlineType>)
                    .zip<HirParameterType>(implementedTrait.typeParameters(context))
                    .expand<DartExpression>({
                      // Type arguments and impl functions for their upper bounds
                      let typeArgument = it.first
                      let typeParameter = it.second
                      let compiledInlineType = compileInlineType(context, typeArgument)
                      List.of2<DartExpression>(
                        compiledInlineType,
                        compileInlineTypeUpcast(
                          context,
                          compiledInlineType,
                          typeArgument,
                          typeParameter.upperBound(context),
                          package,
                          "InlineType",
                        ),
                      )
                    })
                    .toList()
                    // Impl functions for upper bounds
                    .followedByList(
                      (implementedTrait.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
                        .cast<HirNamedType>()
                        .map<DartExpression>({
                          compileInlineTypeUpcast(
                            context,
                            (DartIdentifier("$staticThis", None<String>()) as DartExpression),
                            baseType,
                            it,
                            "InlineType",
                          )
                        })
                        .toList(),
                    )
                    // Function functions
                    .followedByList(
                      ((implementedTrait as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
                        .whereType<HirFunction>()
                        .where({ it.parentFunction(context) is None && it.isStatic(context) })
                        .map<DartExpression>({ overriddenFunction =>
                          let overridingFunction = overridingFunctions
                            .singleWhere({
                              it.parentFunction(context).unwrap() == overriddenFunction
                            })
                            .unwrap()
                          DartClosure(
                            returns = Some<DartType>(valueType),
                            requiredParameters = functionFunctionClosuresCommonTypeArgumentValueParameters
                              .followedByList(
                                (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                  .expand<DartParameter>({
                                    List.of2<DartParameter>(
                                      DartParameter(
                                        name = "typeArgument$function${it.name}",
                                        isRequired = true,
                                        type = Some<DartType>(inlineTypeType),
                                        defaultValue = None<DartExpression>(),
                                      ),
                                      DartParameter(
                                        name = getTypeArgumentUpperBoundImplFunctionName(context, it),
                                        isRequired = true,
                                        type = Some<DartType>(staticImplFunctionType),
                                        defaultValue = None<DartExpression>(),
                                      ),
                                    )
                                  })
                                  .toList(),
                              )
                              .followedByList(
                                (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                  .map<DartParameter>({
                                    DartParameter(
                                      name = it.name,
                                      isRequired = true,
                                      type = Some<DartType>(valueType),
                                      defaultValue = None<DartExpression>(),
                                    )
                                  })
                                  .toList(),
                              ),
                            positionalParameters = List.empty<DartParameter>(),
                            namedParameters = List.empty<DartParameter>(),
                            body = DartInlineBody(
                              (DartIdentifier(
                                getFunctionInImplName(context, overridingFunction),
                                None<String>(),
                              ) as DartExpression)
                                .callPositional(
                                  functionFunctionClosuresCommonTypeArgumentValueArguments
                                    .followedByList(
                                      (overridingFunction.typeParameters(context) as Iterable<HirParameterType>)
                                        .expand<DartExpression>({
                                          List.of2<DartExpression>(
                                            DartIdentifier("typeArgument$function${it.name}", None<String>()),
                                            DartIdentifier(getTypeArgumentUpperBoundImplFunctionName(context, it), None<String>()),
                                          )
                                        })
                                        .toList(),
                                    )
                                    .followedByList<DartExpression>(List.of1<DartExpression>(
                                      DartIdentifier("$staticThis", None<String>()),
                                    ))
                                    .followedByList(
                                      (overridingFunction.valueParameters(context) as Iterable<HirValueParameter>)
                                        .map<DartExpression>({ DartIdentifier(it.name, None<String>()) })
                                        .toList(),
                                    )
                                ),
                            ),
                          )
                        })
                        .toList(),
                    )
                ),
              ),
            ),
          )
        })
        .toList()

    Tuple(functions, List.empty<CompilerError>())
  })
}
