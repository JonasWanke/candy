use compiler_utils
use dart_code
use hir
use incremental

use ...expressions
use ..name_mangling
use ..type

public fun compileGlobalFunction(
  context: QueryContext<List<CompilerError>>,
  functionHir: HirFunction,
): DartFunction {
  query<DartFunction, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunction",
    functionHir, {
    let statements = compileValueExpressionsToBody(
      context,
      functionHir,
      lowerFunctionBody(context, functionHir).unwrap().first,
    )
    let output = DartFunction(
      name = mangleName(context, functionHir.name()),
      docComment = Some<String>("{functionHir}"),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(compileType(context, functionHir.returnType(context))),
      typeParameters = ((functionHir as HasTypeParameters).typeParameters(context) as Iterable<HirParameterType>)
        .map<DartTypeParameter>({
          DartTypeParameter(
            it.name,
            Some<DartType>(compileType(context, it.upperBound(context))),
          )
        })
        .toList(),
      requiredParameters = (functionHirvalueParameters(context) as Iterable<HirValueParameter>)
        .map<DartParameter>({
          DartParameter(
            it.name,
            true,
            Some<DartType>(compileType(context, it.type(context))),
            None<DartExpression>(),
          )
        })
        .toList(),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartBlock(statements)),
    )
    Tuple(output, List.empty<CompilerError>())
  })
}
