use compiler_utils
use dart_code
use hir
use incremental

use ...expressions
use ...types
use ..name_mangling
use ..type

public fun compileGlobalFunction(
  context: QueryContext<List<CompilerError>>,
  functionHir: HirFunction,
): DartFunction {
  query<DartFunction, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunction",
    functionHir, {
    let typeValueParameters = (functionHir.typeParameters(context) as Iterable<HirParameterType>)
      .map<DartParameter>({
        DartParameter(
          "type${it.name}",
          true,
          Some<DartType>(compileNamedTypeStaticType(
            resolveInlineTypeAsNamedType(context, it.upperBound(context)),
          )),
          None<DartExpression>(),
        )
      })
      .toList()
    let valueParameters = (functionHir.valueParameters(context) as Iterable<HirValueParameter>)
      .map<DartParameter>({
        DartParameter(
          it.name,
          true,
          Some<DartType>(compileInlineType(context, it.type(context))),
          None<DartExpression>(),
        )
      })
      .toList()
    let output = DartFunction(
      isStatic = false,
      name = mangleName(context, functionHir.name()),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(compileInlineType(context, functionHir.returnType(context))),
      typeParameters = ((functionHir as HasTypeParameters).typeParameters(context) as Iterable<HirParameterType>)
        .map<DartTypeParameter>({
          DartTypeParameter(
            it.name,
            Some<DartType>(compileInlineType(context, it.upperBound(context))),
          )
        })
        .toList(),
      requiredParameters = typeValueParameters.followedByList(valueParameters),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(
        compileValueExpressionsToBody(
          context,
          functionHir,
          lowerFunctionBody(context, functionHir).unwrap(),
        ),
      ),
    )
    Tuple(output, List.empty<CompilerError>())
  })
}

fun resolveInlineTypeAsNamedType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): HirNamedType {
  if (inlineType is HirErrorType) { throw "Tried to compile an error type to Dart." }
  if (inlineType is HirNamedType) { return (inlineType as HirNamedType) }
  if (inlineType is HirIntersectionType) {
    todo("never, Support intersection types as type parameters")
  }
  if (inlineType is HirThisType) {
    return resolveInlineTypeAsNamedType(context, (inlineType as HirThisType).resolve(context))
  }
  if (inlineType is HirParameterType) {
    return resolveInlineTypeAsNamedType(context, (inlineType as HirParameterType).upperBound(context))
  }
  throw "Unexpected inline type: {inlineType}"
}
