use compiler_utils
use dart_code
use hir
use incremental
use ..name_mangling

public fun compileClass(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  classHir: HirClass,
): List<DartClass> {
  query<List<DartClass>, List<CompilerError>>(
    context,
    "code_generator_dart.compileClass",
    DataTuple2<Package, HirClass>(package, classHir), {
    let output = MutableList.empty<DartClass>()

    output.appendAll(
      ((classHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
        .expand<DartClass>({
          // if it is HirTrait {
          //   return compileTrait(context, package, it as HirTrait) as Iterable<DartClass>
          // }
          if it is HirClass {
            return compileClass(context, package, it as HirClass) as Iterable<DartClass>
          }
          List.empty<DartClass>()
        })
    )

    let properties = ((classHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirProperty>()

    output.append(compileInstanceClass(context, package, classHir))
    output.append(compileStaticClass(context, package, classHir))

    Tuple(output, List.empty<CompilerError>())
  })
}

fun compileInstanceClass(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  classHir: HirClass,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileInstanceClass",
    DataTuple2<Package, HirClass>(package, classHir), {
    // TODO(JonasWanke): Integrate implemented traits & impls.
    // TODO(JonasWanke): Split this into separate functions when queries require less boilerplate.

    let properties = (getClassProperties(context, classHir) as Iterable<HirProperty>)
      .where({ !(it as CanBeStatic).isStatic(context) })

    let name = getDeclarationName(context, classHir)
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    // Constructor
    let constructorParameters = MutableList.empty<DartParameter | DartInitializingFormal>()
    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      requiredParameters = properties
        .map<DartParameter | DartInitializingFormal>({
          DartInitializingFormal(it.name_, defaultValue = None<DartExpression>())
        })
        .toList(),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    // Instance reference to our "static" instance.
    let staticInstanceType = DartNamedType(
      name = DartIdentifier(getDeclarationStaticName(context, classHir), None<String>()),
      typeArguments = List.empty<DartType>(), // TODO(JonasWanke): Add type arguments.
    )
    body.append(DartGetter(
      "staticInstance",
      type = staticInstanceType,
      body = Some<DartBody>(DartInlineBody(
        staticInstanceType.call(
          positionalArguments = List.empty<DartExpression>(),
          namedArguments = Map.empty<String, DartExpression>(),
          typeArguments = List.empty<DartType>(),
        ),
      )),
    ))

    // TODO(JonasWanke): Generate type-check function.

    // Properties → Fields
    body.appendAll(
      properties.map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
        DartField(
          it.name_,
          isStatic = false,
          mutability = DartFinal(),
          type = None<DartType>(), // TODO(JonasWanke): Lower property type for Dart field.
          initialValue = None<DartExpression>(),
        )
      })
    )

    let dartDeclaration = DartClass(
      name = name,
      annotations = List.empty<DartAnnotation>(),
      extends_ = None<DartType>(),
      implements_ = List.empty<DartType>(),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}
fun compileStaticClass(
  context: QueryContext<List<CompilerError>>,
  package: Package,
  classHir: HirClass,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileStaticClass",
    DataTuple2<Package, HirClass>(package, classHir), {
    // TODO(JonasWanke): Integrate implemented traits & impls.
    // TODO(JonasWanke): Split this into separate functions when queries require less boilerplate.

    let properties = (getClassProperties(context, classHir) as Iterable<HirProperty>)
      .where({ (it as CanBeStatic).isStatic(context) })

    let name = getDeclarationStaticName(context, classHir)
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    // Properties → Fields
    body.appendAll(
      properties.map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
        DartField(
          it.name_,
          isStatic = false,
          mutability = DartFinal(),
          type = None<DartType>(), // TODO(JonasWanke): Lower property type for Dart field.
          initialValue = None<DartExpression>(),
        )
      })
    )

    let dartDeclaration = DartClass(
      name = name,
      annotations = List.empty<DartAnnotation>(),
      extends_ = None<DartType>(),
      implements_ = List.empty<DartType>(),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun getClassProperties(
  context: QueryContext<List<CompilerError>>,
  classHir: HirClass,
): List<HirProperty> {
  query<List<HirProperty>, List<CompilerError>>(
    context,
    "code_generator_dart.getClassProperties",
    classHir, {
    let properties = ((classHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
      .whereType<HirProperty>()
      .toList()
    Tuple(properties, List.empty<CompilerError>())
  })
}
