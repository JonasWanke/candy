use compiler_utils
use dart_code
use hir
use incremental

public use .enum_type
public use .function_type
public use .named_type
public use .struct_type

public fun compileInlineTypeValue(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): DartIdentifier {
  query<DartIdentifier, List<CompilerError>>(
    context,
    "code_generator_dart.compileInlineTypeValue",
    inlineType, {
    Tuple(compileInlineType(context, inlineType, "Value"), List.empty<CompilerError>())
  })
}
public fun compileInlineTypeInlineType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): DartIdentifier {
  query<DartIdentifier, List<CompilerError>>(
    context,
    "code_generator_dart.compileInlineTypeInlineType",
    inlineType, {
    Tuple(compileInlineType(context, inlineType, "InlineType"), List.empty<CompilerError>())
  })
}
fun compileInlineType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
  prefix: String,
): DartIdentifier {
  if (inlineType is HirErrorType) { throw "Tried to compile an error type to Dart." }
  if (inlineType is HirNamedType) {
    return compileNamedType(context, inlineType as HirNamedType, prefix)
  }
  if (inlineType is HirFunctionType) {
    return compileFunctionType(context, inlineType as HirFunctionType, prefix)
  }
  if (inlineType is HirStructType) {
    return compileStructType(context, inlineType as HirStructType, prefix)
  }
  if (inlineType is HirEnumType) {
    return compileEnumType(context, inlineType as HirEnumType, prefix)
  }
  // TODO(soon): Can intersection and this types stay like this?
  if (inlineType is HirIntersectionType) { return dartDynamic }
  if (inlineType is HirThisType) { return dartDynamic }
  if (inlineType is HirParameterType) {
    assert(prefix == "InlineType", "Parameter types can't be compiled to value types.")
    let parameterType = (inlineType as HirParameterType)
    if (parameterType.declaration is HirTrait) {
      return DartIdentifier("$staticThis", None<String>())
        .dot("typeArgument$trait${parameterType.name}")
    }
    if (parameterType.declaration is HirImpl) {
      return DartIdentifier("typeArgument$impl${parameterType.name}", None<String>())
    }
    if (parameterType.declaration is HirFunction) {
      return DartIdentifier("typeArgument$function${parameterType.name}", None<String>())
    }
    throw "Tried to compile a reference to a type's type parameter to Dart: `{inlineType}`."
  }
  if (inlineType is HirReflectionType) {
    todo("soon, Compile HirReflectionType to Dart")
  }
  throw "Unknown inline type: {inlineType}"
}

public fun generateInlineTypeCheck(
  context: QueryContext<List<CompilerError>>,
  actualInlineTypeReference: DartExpression,
  expectedType: HirInlineType,
): DartExpression {
  if (expectedType is HirErrorType) { throw "Encountered an error type while compiling to Dart." }
  if (expectedType is HirNamedType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        ((expectedType as HirNamedType).parameterTypes as Iterable<HirInlineType>)
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirFunctionType) {
    let functionType = (expectedType as HirFunctionType)
    let parameterTypes = functionType.receiverType
      .map<Iterable<HirInlineType>>({
        List.of1<HirInlineType>(it).followedByList(functionType.parameterTypes)
      })
      .orElse({ functionType.parameterTypes })
      .followedBy(functionType.returnType)
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        parameterTypes
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirStructType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        (expectedType as HirStructType).types
          .sortedBy({ it.first })
          .map<DartExpression>({ compileInlineTypeInlineType(context, it.second) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirEnumType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        (expectedType as HirEnumType).variants.entries().toList()
          .sortedBy({ it.first })
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirIntersectionType) {
    todo("never: support intersection types as type arguments")
  }
  if (expectedType is HirThisType) { todo("never: support this types as type arguments") }
  if (expectedType is HirParameterType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("equals")
      .call1(actualInlineTypeReference)
  }
  if (expectedType is HirReflectionType) {
    todo("never: support reflection types as value arguments in impl base types")
  }
  throw "Unknown inline type: {expectedType}"
}

public fun compileInlineTypeUpcast(
  context: QueryContext<List<CompilerError>>,
  expression: DartExpression,
  actual: HirInlineType,
  target: HirInlineType,
  scope: Package,
  prefix: String,
): DartExpression {
  query<DartIdentifier, List<CompilerError>>(
    context,
    "code_generator_dart.compileInlineTypeUpcast",
    DataTuple5<DartExpression, HirInlineType, HirInlineType, Package, String>(expression, actual, target, scope, prefix), {
    Tuple(compileInlineTypeUpcastHelper(context, expression, actual, target, scope), List.empty<CompilerError>())
  })
}
fun compileInlineTypeUpcastHelper(
  context: QueryContext<List<CompilerError>>,
  expression: DartExpression,
  actual: HirInlineType,
  target: HirInlineType,
  scope: Package,
  prefix: String,
): DartExpression {
  if (actual is HirErrorType) { throw "Encountered an error type while compiling to Dart." }
  if (actual == target) { return expression }
  if (actual == HirNamedType.coreNever(context)) {
    return DartParenthesizedExpression(
      DartThrow(DartStringLiteral("Tried to upcast an instance of `Never`.")),
    )
  }

  if (target is HirErrorType) { throw "Encountered an error type while compiling to Dart." }
  if (target is HirNamedType) {
    let target = (target as HirNamedType)
    if (target.declaration is HirType) {
      throw "Generating an upcast to a type is not possible."
    }

    let source = sourceFor(context, actual, target, scope)
    if (source is None) {
      throw "Could not find an impl or upper bound allowing `{actual}` to be upcast to `{expected}`."
    }
    let source = source.unwrap()

    if (source is HirTrait || source is HirType) {
      if (target == HirNamedType.coreAny(context)) {
        let implFunctionName = getTypeAnyImplFunctionName(context, source as HirType, prefix)
        return (DartIdentifier(implFunctionName, None<String>()) as DartExpression)
          .call1(expression)
      }
      throw "Tried to generate upcast code from `{actual}` to `{target}` and received an unknown upcast source: `{source}`."
    }
    if (source is HirNamedType) {
      // Upper bound
      let traitHir = ((actual as HirNamedType).declaration as HirTrait)
      let expression = DartParenthesizedExpression(
        expression.as_(compileNamedType(context, source, prefix)),
      ).dot(getTraitUpperBoundImplFunctionName(context, traitHir, source as HirNamedType, prefix))
        .call0()
      return compileInlineTypeUpcast(context, expression, source, target, scope)
    }
    if (source is HirImpl) {
      // Impl
      let implImplFunctionName = getImplImplFunctionName(context, source as HirImpl, prefix)
      let expression = (DartIdentifier(implImplFunctionName, None<String>()) as DartExpression)
        .call1(expression)
      return compileInlineTypeUpcast(context, expression, source, target, scope)
    }
    throw "Received an unknown upcast source type: `{source}`."
  }
  if (target is HirFunctionType) {
    throw "Expression cannot currently be upcasted to function types."
  }
  if (target is HirStructType) {
    throw "Expression cannot currently be upcasted to struct types."
  }
  if (target is HirEnumType) {
    throw "Expression cannot currently be upcasted to enum types."
  }
  if (target is HirIntersectionType) {
    todo("never: support upcasting to intersection types")
  }
  if (target is HirThisType) { todo("never: support upcasting to this types") }
  if (target is HirParameterType) {
    assert(
      actual is HirParameterType,
      "Only type parameters can be upcasted to a different type parameter.",
    )
    let implFunctionName = getTypeArgumentUpperBoundImplFunctionName(
      context,
      target as HirParameterType,
    )
    let actual = (actual as HirParameterType)
    let implFunction = if (actual.declaration is HirFunction || actual.declaration is HirImpl) {
      DartIdentifier(implFunctionName, None<String>())
    } else {
      DartIdentifier("$staticThis", None<String>()).dot(implFunctionName)
    }
    let expression = (implFunction as DartExpression).call0()
    let newType = (actual as HirParameterType).upperBound(context)
    return compileInlineTypeUpcast(context, newType, source, target, scope)
  }
  if (target is HirReflectionType) {
    todo("never: support upcasting to reflection types")
  }
  throw "Unknown inline type: {target}"
}
