use compiler_utils
use dart_code
use hir
use incremental

public use .enum_type
public use .function_type
public use .named_type
public use .struct_type

public fun compileInlineTypeValue(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): DartIdentifier {
  query<DartIdentifier, List<CompilerError>>(
    context,
    "code_generator_dart.compileInlineTypeValue",
    inlineType, {
    Tuple(compileInlineType(context, inlineType, "Value"), List.empty<CompilerError>())
  })
}
public fun compileInlineTypeInlineType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): DartIdentifier {
  query<DartIdentifier, List<CompilerError>>(
    context,
    "code_generator_dart.compileInlineTypeInlineType",
    inlineType, {
    Tuple(compileInlineType(context, inlineType, "InlineType"), List.empty<CompilerError>())
  })
}
fun compileInlineType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
  prefix: String,
): DartIdentifier {
  if (inlineType is HirErrorType) { throw "Tried to compile an error type to Dart." }
  if (inlineType is HirNamedType) {
    return compileNamedType(context, inlineType as HirNamedType, prefix)
  }
  if (inlineType is HirFunctionType) {
    return compileFunctionType(context, inlineType as HirFunctionType, prefix)
  }
  if (inlineType is HirStructType) {
    return compileStructType(context, inlineType as HirStructType, prefix)
  }
  if (inlineType is HirEnumType) {
    return compileEnumType(context, inlineType as HirEnumType, prefix)
  }
  // TODO(soon): Can intersection and this types stay like this?
  if (inlineType is HirIntersectionType) { return dartDynamic }
  if (inlineType is HirThisType) { return dartDynamic }
  if (inlineType is HirParameterType) {
    assert(prefix == "InlineType", "Parameter types can't be compiled to value types.")
    let parameterType = (inlineType as HirParameterType)
    if (parameterType.declaration is HirTrait) {
      return DartIdentifier("$staticThis", None<String>())
        .dot("typeArgument$trait${parameterType.name}")
    }
    if (parameterType.declaration is HirImpl) {
      return DartIdentifier("typeArgument$impl${parameterType.name}", None<String>())
    }
    if (parameterType.declaration is HirFunction) {
      return DartIdentifier("typeArgument$function${parameterType.name}", None<String>())
    }
    throw "Tried to compile a reference to a type's type parameter to Dart: `{inlineType}`."
  }
  if (inlineType is HirReflectionType) {
    todo("soon, Compile HirReflectionType to Dart")
  }
  throw "Unknown inline type: {inlineType}"
}

public fun generateInlineTypeCheck(
  context: QueryContext<List<CompilerError>>,
  actualInlineTypeReference: DartExpression,
  expectedType: HirInlineType,
): DartExpression {
  if (expectedType is HirErrorType) { throw "Encountered an error type while compiling to Dart." }
  if (expectedType is HirNamedType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        ((expectedType as HirNamedType).parameterTypes as Iterable<HirInlineType>)
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirFunctionType) {
    let functionType = (expectedType as HirFunctionType)
    let parameterTypes = functionType.receiverType
      .map<Iterable<HirInlineType>>({
        List.of1<HirInlineType>(it).followedByList(functionType.parameterTypes)
      })
      .orElse({ functionType.parameterTypes })
      .followedBy(functionType.returnType)
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        parameterTypes
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirStructType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        (expectedType as HirStructType).types
          .sortedBy({ it.first })
          .map<DartExpression>({ compileInlineTypeInlineType(context, it.second) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirEnumType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("isOfThisType")
      .callPositional(
        (expectedType as HirEnumType).variants.entries().toList()
          .sortedBy({ it.first })
          .map<DartExpression>({ compileInlineTypeInlineType(context, it) })
          .followedByList(List.of1<DartExpression>(actualInlineTypeReference)),
      )
  }
  if (expectedType is HirIntersectionType) {
    todo("never: support intersection types as type arguments")
  }
  if (expectedType is HirThisType) { todo("never: support this types as type arguments") }
  if (expectedType is HirParameterType) {
    return compileInlineTypeInlineType(context, expectedType)
      .dot("equals")
      .call1(actualInlineTypeReference)
  }
  if (expectedType is HirReflectionType) {
    todo("never: support reflection types as value arguments in impl base types")
  }
  throw "Unknown inline type: {expectedType}"
}
