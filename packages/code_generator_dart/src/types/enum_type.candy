use compiler_utils
use dart_code
use hir
use incremental

use ...declarations
use ...types
use ..type_collection

public fun compileEnumType(
  context: QueryContext<List<CompilerError>>,
  enumType: HirEnumType,
): DartType {
  /// Example: `True | False Int` -> `Enum$False$True<Int, Nothing>`

  query<DartType, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumType",
    enumType, {
    let variantNames = enumType.variants.keys()

    // In our example: "Enum$False$True"
    let name = DartIdentifier(
      getCompiledEnumTypeName(context, variantNames.toSet()),
      Some<String>(moduleHirToImportUrl(context, HirModule.syntheticEnums(context))),
    )

    let sortedVariantTypes = (variantNames.toList().unsafeSorted() as Iterable<String>)
      .map<HirInlineType>({ enumType.variants.get(it).unwrap() })
    // In our example: ["Int", "Nothing"]
    let types = sortedVariantTypes.map<DartType>({ compileInlineType(context, it) }).toList()

    Tuple(DartNamedType(name, types), List.empty<CompilerError>())
  })
}

public fun compileEnumTypeDeclarations(
  context: QueryContext<List<CompilerError>>,
  package: Package,
): (HirModule, List<DartDeclaration>) {
  /// Visits all used enum types and generates their Dart code.

  query<(HirModule, List<DartDeclaration>), List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclarations",
    package, {
    let variantNames = getAllInlineTypes(context, package).items()
      .whereType<HirEnumType>()
      .map<Set<String>>({ it.variants.keys().toSet() })
      .toSet()
    let classes = variantNames.items()
      .expand<DartDeclaration>({
        (compileEnumTypeDeclaration(context, it) as Iterable<DartDeclaration>)
      })
      .toList()
    Tuple(Tuple(HirModule.syntheticEnums(context), classes), List.empty<CompilerError>())
  })
}
fun compileEnumTypeDeclaration(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): List<DartClass> {
  query<List<DartClass>, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclaration",
    variantNames, {
    let classes = MutableList.empty<DartClass>()
    classes.append(compileEnumTypeDeclarationBase(context, variantNames))
    classes.appendAll(
      variantNames.items()
        .map<DartClass>({ compileEnumTypeDeclarationVariant(context, variantNames, it) }),
    )
    Tuple(classes, List.empty<CompilerError>())
  })
}
fun compileEnumTypeDeclarationBase(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclarationBase",
    variantNames, {
    let name = getCompiledEnumTypeName(context, variantNames)

    let variants = (variantNames.items().toList().unsafeSorted() as Iterable<String>)
      .map<(String, String)>({ Tuple(it, "T{it}") })

    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List.empty<DartParameter | DartInitializingFormal>(),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.append(DartFunction(
      name = "match",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(typeT),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = generateMatchValueParameters(variants),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = None<DartBody>(),
    ))

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.empty<DartAnnotation>(),
      isAbstract = true,
      typeParameters = variants
        .map<DartTypeParameter>({ DartTypeParameter(it.second, None<DartType>()) })
        .toList(),
      extends_ = None<DartType>(),
      implements_ = List.empty<DartType>(),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}
fun compileEnumTypeDeclarationVariant(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
  variant: String,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclarationVariant",
    DataTuple2<Set<String>, String>(variantNames, variant), {
    let name = getCompiledEnumVariantName(context, variantNames, variant)

    let variants = (variantNames.items().toList().unsafeSorted() as Iterable<String>)
      .map<(String, String)>({ Tuple(it, "T{it}") })
    let fieldName = "value"
    let fieldType = variants.singleWhere({ it.first == variant }).unwrap().second

    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List.of1<DartParameter | DartInitializingFormal>(
        DartInitializingFormal(fieldName, None<DartExpression>()),
      ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.append(DartField(
      fieldName,
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(
        DartNamedType(DartIdentifier(fieldType, None<String>()), List.empty<DartType>()),
      ),
      initialValue = None<DartExpression>(),
    ))

    body.append(DartFunction(
      name = "match",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(typeT),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = generateMatchValueParameters(variants),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("value{variant}", None<String>()) as DartExpression)
          .call1(DartIdentifier("value", None<String>()) as DartExpression),
      )),
    ))

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = variants
        .map<DartTypeParameter>({ DartTypeParameter(it.second, None<DartType>()) })
        .toList(),
      extends_ = Some<DartType>(
        DartNamedType(
          DartIdentifier(getCompiledEnumTypeName(context, variantNames), None<String>()),
          variants
            .map<DartType>({
              DartNamedType(DartIdentifier(it.second, None<String>()), List.empty<DartType>())
            })
            .toList(),
        ),
      ),
      implements_ = List.empty<DartType>(),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}
let typeT = DartNamedType(DartIdentifier("T", None<String>()), List.empty<DartType>())
fun generateMatchValueParameters(variants: Iterable<(String, String)>): List<DartParameter> {
  variants
    .map<DartParameter>({
      DartParameter(
        name = DartIdentifier("value{it.first}", None<String>()),
        isRequired = true,
        type = Some<DartType>(DartFunctionType(
          parameters = List.of1<DartType | DartParameter>(it.second),
          positionalParameters = List.empty<DartType | DartParameter>(),
          namedParameters = List.empty<DartParameter>(),
          _returns = Some<DartType>(typeT),
        )),
        defaultValue = None<DartExpression>(),
      )
    })
    .toList()
}

public fun getCompiledEnumTypeName(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): String {
  /// Example: `True | False Int` -> `Enum$False$True`

  query<String, List<CompilerError>>(
    context,
    "code_generator_dart.getCompiledEnumTypeName",
    variantNames, {
    let variantNames = variantNames.items().toList().unsafeSorted()
    let variantNames = (variantNames as Iterable<String>).join("$")
    Tuple("Enum${variantNames}", List.empty<CompilerError>())
  })
}
public fun getCompiledEnumVariantName(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
  variant: String,
): String {
  /// Example: `True` in `True | False Int` -> `Enum$False$_True_`

  query<String, List<CompilerError>>(
    context,
    "code_generator_dart.getCompiledEnumVariantName",
    DataTuple2<Set<String>, String>(variantNames, variant), {
    let variantNames = variantNames.items().toList().unsafeSorted()
    let variantNames = (variantNames as Iterable<String>)
      .map<String>({ if (it == variant) { "_{it}_" } else { it } })
      .join("$")
    Tuple("Enum${variantNames}", List.empty<CompilerError>())
  })
}
