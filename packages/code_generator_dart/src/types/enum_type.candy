use compiler_utils
use dart_code
use hir
use incremental

use ...declarations
use ...types
use ...utils
use ..type_collection

public fun compileEnumType(
  context: QueryContext<List<CompilerError>>,
  enumType: HirEnumType,
  prefix: String,
): DartIdentifier {
  /// Example: `True | False Int` -> `Enum$False$True`

  compileRawEnumType(context, enumType.variants.keys().toSet(), prefix)
}
fun compileRawEnumType(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
  prefix: String,
): DartIdentifier {
  DartIdentifier(
    "{prefix}$Enum${orderEnumVariants(variantNames).join("$")}",
    Some<String>(moduleHirToImportUrl(context, HirModule.syntheticEnumTypes(context))),
  )
}
fun compileEnumVariantType(variantNames: Set<String>, variant: String): String {
  /// Example: `True` in `True | False Int` -> `Enum$False$_True_`

  let variantNames = orderEnumVariants(variantNames)
    .map<String>({ if (it == variant) { "${it}$" } else { it } })
    .join("$")
  "Value$Enum${variantNames}"
}

// TODO(soon): generate impl functions and impl for Any

public fun compileEnumTypeDeclarations(
  context: QueryContext<List<CompilerError>>,
  package: Package,
): (HirModule, List<DartDeclaration>) {
  /// Visits all used enum types and generates their Dart code.

  query<(HirModule, List<DartDeclaration>), List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclarations",
    package, {
    let variantNames = getAllInlineTypes(context, package).items()
      .whereType<HirEnumType>()
      .map<Set<String>>({ it.variants.keys().toSet() })
      .toSet()
    let classes = variantNames.items()
      .expand<DartDeclaration>({
        (compileEnumTypeDeclaration(context, it) as Iterable<DartDeclaration>)
      })
      .toList()
    Tuple(Tuple(HirModule.syntheticEnumTypes(context), classes), List.empty<CompilerError>())
  })
}
fun compileEnumTypeDeclaration(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): List<DartClass> {
  query<List<DartClass>, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeDeclaration",
    variantNames, {
    let classes = MutableList.empty<DartClass>()
    classes.append(compileEnumTypeValue(context, variantNames))
    classes.appendAll(
      variantNames.items()
        .map<DartClass>({ compileEnumTypeVariantValue(context, variantNames, it) }),
    )
    classes.append(compileEnumTypeInlineType(context, variantNames))
    Tuple(classes, List.empty<CompilerError>())
  })
}

fun compileEnumTypeValue(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeValue",
    variantNames, {
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartFunction(
      isStatic = false,
      name = "match",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(valueType),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = generateMatchValueParameters(variantNames),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = None<DartBody>(),
    ))

    let dartDeclaration = DartClass(
      name = compileRawEnumType(context, variantNames, "Value").name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.empty<DartAnnotation>(),
      isAbstract = true,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(enumValueType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}
fun compileEnumTypeVariantValue(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
  variant: String,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeVariantValue",
    DataTuple2<Set<String>, String>(variantNames, variant), {
    let name = compileEnumVariantType(variantNames, variant)
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = Some<String>("_"),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List.of2<DartParameter | DartInitializingFormal>(
        DartInitializingFormal("inlineType", None<DartExpression>()),
        DartInitializingFormal("value", None<DartExpression>()),
      ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    // TODO(never, JonasWanke): add `@override`
    body.append(DartField(
      "inlineType",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(inlineTypeType),
      initialValue = None<DartExpression>(),
    ))
    body.append(DartField(
      "value",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(valueType),
      initialValue = None<DartExpression>(),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "match",
      docComment = None<String>(),
      annotations = List.of1<DartAnnotation>(dartOverrideAnnotation),
      _returns = Some<DartType>(valueType),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = generateMatchValueParameters(variantNames),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("value${variant}", None<String>()) as DartExpression)
          .call1(DartIdentifier("value", None<String>())),
      )),
    ))

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(
        DartType(compileEnumType(context, variantNames, "Value"), List.empty<DartType>()),
      ),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}
fun generateMatchValueParameters(variantNames: Set<String>): List<DartParameter> {
  orderEnumVariants(variantNames)
    .map<DartParameter>({
      DartParameter(
        name = DartIdentifier("value${it}", None<String>()),
        isRequired = true,
        type = Some<DartType>(DartFunctionType(
          parameters = List.of1<DartType | DartParameter>(valueType),
          positionalParameters = List.empty<DartType | DartParameter>(),
          namedParameters = List.empty<DartParameter>(),
          _returns = Some<DartType>(valueType),
        )),
        defaultValue = None<DartExpression>(),
      )
    })
    .toList()
}

fun compileEnumTypeInlineType(
  context: QueryContext<List<CompilerError>>,
  variantNames: Set<String>,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileEnumTypeInlineType",
    variantNames, {
    let name = compileRawEnumType(context, variantNames, "InlineType")
    let variants = orderEnumVariants(variantNames)
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = variants
        .map<DartParameter | DartInitializingFormal>({
          DartInitializingFormal("typeParameter${it}", None<DartExpression>())
        })
        .toList(),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.appendAll(
      variants
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartFunction(
            isStatic = false,
            name = "create${it}",
            docComment = None<String>(),
            annotations = List.empty<DartAnnotation>(),
            _returns = Some<DartType>(valueType),
            typeParameters = List.empty<DartTypeParameter>(),
            requiredParameters = List.of1<DartParameter>(DartParameter(
              "value",
              isRequired = true,
              type = Some<DartType>(valueType),
              defaultValue = None<DartExpression>(),
            )),
            positionalParameters = List.empty<DartParameter>(),
            namedParameters = List.empty<DartParameter>(),
            body = Some<DartBody>(DartInlineBody(
              (DartIdentifier(compileEnumVariantType(variantNames, it), None<String>()) as DartExpression)
                .dot("_")
                .call2(dartThis, DartIdentifier("value", None<String>())),
            )),
          )
        }),
    )

    body.append(DartFunction(
      isStatic = false,
      name = "equals",
      docComment = None<String>(),
      annotations = List.of1<DartAnnotation>(dartOverrideAnnotation),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        "other",
        isRequired = true,
        type = Some<DartType>(inlineTypeType),
        defaultValue = None<DartExpression>(),
      )),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("isOfThisType", None<String>()) as DartExpression)
          .callPositional(
            variants
              .map<DartExpression>({ DartIdentifier("typeParameter${it}", None<String>()) })
              .toList()
              .followedByList(List.of1<DartExpression>(DartIdentifier("other", None<String>()))),
          ),
      )),
    ))
    body.append(DartFunction(
      isStatic = true,
      name = "isOfThisType",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = variants
        .map<DartParameter>({
          DartParameter(
            "typeParameter${it}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(List.of1<DartParameter>(DartParameter(
          "inlineType",
          isRequired = true,
          type = Some<DartType>(inlineTypeType),
          defaultValue = None<DartExpression>(),
        ))),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        variants
          .map<DartExpression>({
            (DartIdentifier("typeParameter${it}", None<String>()) as DartExpression)
              .dot("equals")
              .call1(
                (DartIdentifier("inlineType", None<String>()) as DartExpression)
                  .dot("typeParameter${it}"),
              )
          })
          .foldLeft<DartExpression>(
            (DartIdentifier("inlineType", None<String>()) as DartExpression).is_(name),
            { result, item => result.and(item) },
          ),
      )),
    ))

    body.appendAll(
      variants
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            "typeParameter${it}",
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(inlineTypeType),
            initialValue = None<DartExpression>(),
          )
        }),
    )

    let dartDeclaration = DartClass(
      name = name.name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(enumInlineTypeType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun orderEnumVariants(variantNames: Set<String>): Iterable<String> {
  variantNames.items().toList().unsafeSorted()
}
