use compiler_utils
use dart_code
use hir
use incremental

use ...types

public fun compileFunctionType(
  context: QueryContext<List<CompilerError>>,
  functionType: HirFunctionType,
  prefix: String,
): DartIdentifier {
  /// Example: `(Int, String) -> Nothing` -> `Function$2`

  compileRawFunctionType(context, getParameterCount(functionType), prefix)
}
fun compileRawFunctionType(
  context: QueryContext<List<CompilerError>>,
  parameterCount: Int,
  prefix: String,
): DartIdentifier {
  DartIdentifier(
    "{prefix}$Function${parameterCount}",
    Some<String>(moduleHirToImportUrl(context, HirModule.syntheticFunctionTypes(context))),
  )
}

// TODO(soon): generate impl functions and impl for Any

public fun compileFunctionTypeDeclarations(
  context: QueryContext<List<CompilerError>>,
  package: Package,
): (HirModule, List<DartDeclaration>) {
  /// Visits all used function types and generates their Dart code.

  query<(HirModule, List<DartDeclaration>), List<CompilerError>>(
    context,
    "code_generator_dart.compileFunctionTypeDeclarations",
    package, {
    let parameterCounts = getAllInlineTypes(context, package).items()
      .whereType<HirFunctionType>()
      .map<Int>({ getParameterCount(it) })
      .toSet()
    let classes = parameterCounts.items()
      .map<DartDeclaration>({
        (compileFunctionTypeDeclaration(context, it) as Iterable<DartClass>).cast<DartDeclaration>()
      })
      .toList()
    Tuple(Tuple(HirModule.syntheticFunctionTypes(context), classes), List.empty<CompilerError>())
  })
}
fun compileFunctionTypeDeclaration(
  context: QueryContext<List<CompilerError>>,
  parameterCount: Int,
): List<DartClass> {
  query<List<DartClass>, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunctionTypeDeclaration",
    parameterCount, {
    let classes = List.of2<DartClass>(
      compileFunctionTypeValue(context, parameterCount),
      compileFunctionTypeInlineType(context, parameterCount),
    )
    Tuple(classes, List.empty<CompilerError>())
  })
}

fun compileFunctionTypeValue(
  context: QueryContext<List<CompilerError>>,
  parameterCount: Int,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunctionTypeValue",
    parameterCount, {
    let name = compileRawFunctionType(context, parameterCount, "Value")
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = Some<String>("_"),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = List.of2<DartParameter | DartInitializingFormal>(
        DartInitializingFormal("inlineType", None<DartExpression>()),
        DartInitializingFormal("function", None<DartExpression>()),
      ),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    // TODO(never, JonasWanke): add `@override`
    body.append(DartField(
      "inlineType",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(inlineTypeType),
      initialValue = None<DartExpression>(),
    ))
    body.append(DartField(
      "function",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(compileDartFunctionType(parameterCount)),
      initialValue = None<DartExpression>(),
    ))

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(functionValueType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun compileFunctionTypeInlineType(
  context: QueryContext<List<CompilerError>>,
  parameterCount: Int,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileFunctionTypeInlineType",
    parameterCount, {
    let name = compileRawFunctionType(context, parameterCount, "InlineType")
    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = 0.until(parameterCount)
        .map<DartParameter | DartInitializingFormal>({
          DartInitializingFormal("typeArgument${it}", None<DartExpression>())
        })
        .toList()
        .followedByList(List.of1<DartParameter | DartInitializingFormal>(
          DartInitializingFormal("typeArgument$Return", None<DartExpression>()),
        )),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "create",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(valueType),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = DartParameter(
        "function",
        isRequired = true,
        type = Some<DartType>(compileDartFunctionType(parameterCount)),
        defaultValue = None<DartExpression>(),
      ),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (compileRawFunctionType(context, parameterCount, "Value") as DartExpression)
          .dot("_")
          .callPositional(
            List.of2<DartExpression>(dartThis, DartIdentifier("function", None<String>())),
          ),
      )),
    ))

    body.append(DartFunction(
      isStatic = false,
      name = "equals",
      docComment = None<String>(),
      annotations = List.of1<DartAnnotation>(dartOverrideAnnotation),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = List.of1<DartParameter>(DartParameter(
        "other",
        isRequired = true,
        type = Some<DartType>(inlineTypeType),
        defaultValue = None<DartExpression>(),
      )),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        (DartIdentifier("isOfThisType", None<String>()) as DartExpression)
          .callPositional(
            0.until(parameterCount)
              .map<DartExpression>({ DartIdentifier("typeArgument${it}", None<String>()) })
              .toList()
              .followedByList(List.of2<DartExpression>(
                DartIdentifier("typeArgument$Return", None<String>()),
                DartIdentifier("other", None<String>()),
              )),
          ),
      )),
    ))
    body.append(DartFunction(
      isStatic = true,
      name = "isOfThisType",
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      _returns = Some<DartType>(dartBool),
      typeParameters = List.empty<DartTypeParameter>(),
      requiredParameters = 0.until(parameterCount)
        .map<DartParameter>({
          DartParameter(
            "typeArgument${it}",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList()
        .followedByList(List.of2<DartParameter>(
          DartParameter(
            "typeArgument$Return",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          ),
          DartParameter(
            "inlineType",
            isRequired = true,
            type = Some<DartType>(inlineTypeType),
            defaultValue = None<DartExpression>(),
          ),
        )),
      positionalParameters = List.empty<DartParameter>(),
      namedParameters = List.empty<DartParameter>(),
      body = Some<DartBody>(DartInlineBody(
        0.until(parameterCount)
          .map<DartExpression>({
            (DartIdentifier("typeArgument${it}", None<String>()) as DartExpression)
              .dot("equals")
              .call1(
                (DartIdentifier("inlineType", None<String>()) as DartExpression)
                  .dot("typeArgument${it}"),
              )
          })
          .foldLeft<DartExpression>(
            (DartIdentifier("inlineType", None<String>()) as DartExpression).is_(name),
            { result, item => result.and(item) },
          )
          .and(
            (DartIdentifier("typeArgument$Return", None<String>()) as DartExpression)
              .dot("equals")
              .call1(
                (DartIdentifier("inlineType", None<String>()) as DartExpression)
                  .dot("typeArgument$Return"),
              ),
          ),
      )),
    ))

    body.appendAll(
      0.until(parameterCount)
        .map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
          DartField(
            "typeArgument${it}",
            docComment = None<String>(),
            isStatic = false,
            mutability = DartFinal(),
            type = Some<DartType>(inlineTypeType),
            initialValue = None<DartExpression>(),
          )
        }),
    )
    body.append(DartField(
      "typeArgument$Return",
      docComment = None<String>(),
      isStatic = false,
      mutability = DartFinal(),
      type = Some<DartType>(inlineTypeType),
      initialValue = None<DartExpression>(),
    ))

    let dartDeclaration = DartClass(
      name = name.name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.of1<DartAnnotation>(dartMetaSealedAnnotation),
      isAbstract = false,
      typeParameters = List.empty<DartTypeParameter>(),
      extends_ = None<DartType>(),
      implements_ = List.of1<DartType>(functionInlineTypeType),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

fun getParameterCount(functionType: HirFunctionType): Int { getParameterTypes(functionType).length }
fun getParameterTypes(functionType: HirFunctionType): Iterable<HirInlineType> {
  /// In Dart code, the this-parameter is treated as a regular parameter and prepended to the rest.

  functionType.receiverType
    .map<Iterable<HirInlineType>>({
      List.of1<HirInlineType>(it).followedByList(functionType.parameterTypes)
    })
    .orElse({ functionType.parameterTypes })
}

fun compileDartFunctionType(parameterCount: Int): DartFunctionType {
  DartFunctionType(
    parameters = 0.until(parameterCount).map<DartType | DartParameter>({ valueType }).toList(),
    positionalParameters = List.empty<DartType | DartParameter>(),
    namedParameters = List.empty<DartParameter>(),
    _returns = Some<DartType>(valueType),
  )
}
