use compiler_utils
use dart_code
use hir
use incremental

use ...declarations
use ...types
use ..type_collection

public fun compileStructType(
  context: QueryContext<List<CompilerError>>,
  structType: HirStructType,
): DartType {
  /// Example: `(first: Foo, second: Bar)` -> `Struct$first$second<Foo, Bar>`

  query<DartType, List<CompilerError>>(
    context,
    "code_generator_dart.compileStructType",
    structType, {
    let sortedFields = (structType.types.sortedBy<String>({ it.first }) as Iterable<(String, HirInlineType)>)
    let fieldNames = sortedFields.map<String>({ it.first }).toSet()
    let name = getCompiledStructTypeName(context, fieldNames)
    let importUrl = moduleHirToImportUrl(context, HirModule.syntheticStructs(context))
    let name = DartIdentifier(name, Some<String>(importUrl))

    let types = sortedFields.map<DartType>({ compileInlineType(context, it.second) }).toList()

    Tuple(DartNamedType(name, types), List.empty<CompilerError>())
  })
}

public fun compileStructTypeDeclarations(
  context: QueryContext<List<CompilerError>>,
  package: Package,
): (HirModule, List<DartDeclaration>) {
  /// Visits all used struct types and generates their Dart code.

  query<(HirModule, List<DartDeclaration>), List<CompilerError>>(
    context,
    "code_generator_dart.compileStructTypeDeclarations",
    package, {
    let fieldNames = getAllInlineTypes(context, package).items()
      .whereType<HirStructType>()
      .map<Set<String>>({
        (it.types as Iterable<(String, HirInlineType)>).map<String>({ it.first }).toSet()
      })
      .toSet()
    let classes = fieldNames.items()
      .map<DartDeclaration>({ compileStructTypeDeclaration(context, it) })
      .toList()
    Tuple(Tuple(HirModule.syntheticStructs(context), classes), List.empty<CompilerError>())
  })
}
fun compileStructTypeDeclaration(
  context: QueryContext<List<CompilerError>>,
  fieldNames: Set<String>,
): DartClass {
  query<DartClass, List<CompilerError>>(
    context,
    "code_generator_dart.compileStructTypeDeclaration",
    fieldNames, {
    let name = getCompiledStructTypeName(context, fieldNames)

    let fields = (fieldNames.items().toList().unsafeSorted() as Iterable<String>)
      .map<(String, String)>({ Tuple(it, "T{it}") })

    let body = MutableList.empty<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>()

    body.append(DartConstructor(
      className = name,
      name = None<String>(),
      docComment = None<String>(),
      annotations = List.empty<DartAnnotation>(),
      isConst = true,
      requiredParameters = fields
        .map<DartParameter | DartInitializingFormal>({
          DartInitializingFormal(
            mangleName(context, it.first),
            defaultValue = None<DartExpression>(),
          )
        })
        .toList(),
      positionalParameters = List.empty<DartParameter | DartInitializingFormal>(),
      namedParameters = List.empty<DartParameter | DartInitializingFormal>(),
      body = None<DartBody>(),
    ))

    body.appendAll(fields.map<DartConstructor | DartField | DartGetter | DartSetter | DartFunction>({
      DartField(
        mangleName(context, it.first),
        docComment = None<String>(),
        // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
        isStatic = false,
        mutability = DartFinal(),
        type = Some<DartType>(
          DartNamedType(DartIdentifier(it.second, None<String>()), List.empty<DartType>()),
        ),
        initialValue = None<DartExpression>(),
      )
    }))

    let dartDeclaration = DartClass(
      name = name,
      docComment = None<String>(),
      // TODO(never, JonasWanke): Add the corresponding Candy code as the doc comment.
      annotations = List.empty<DartAnnotation>(),
      isAbstract = false,
      typeParameters = fields
        .map<DartTypeParameter>({ DartTypeParameter(it.second, None<DartType>()) })
        .toList(),
      extends_ = None<DartType>(),
      implements_ = List.empty<DartType>(),
      with_ = List.empty<DartType>(),
      body = body,
    )
    Tuple(dartDeclaration, List.empty<CompilerError>())
  })
}

public fun getCompiledStructTypeName(
  context: QueryContext<List<CompilerError>>,
  fieldNames: Set<String>,
): String {
  /// Example: `(first: Foo, second: Bar)` -> `Struct$first$second`

  query<String, List<CompilerError>>(
    context,
    "code_generator_dart.getCompiledStructTypeName",
    fieldNames, {
    let fieldNames = fieldNames.items().toList().unsafeSorted()
    let fieldNames = (fieldNames as Iterable<String>).join("$")
    Tuple("Struct${fieldNames}", List.empty<CompilerError>())
  })
}
