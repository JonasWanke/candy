use compiler_utils
use dart_code
use hir
use incremental

use ...types

public fun getAllInlineTypes(
  context: QueryContext<List<CompilerError>>,
  package: Package,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypes",
    package, {
    let inlineTypes = (package.getAllPackagesInCompilationOrder(context) as Iterable<Package>)
      .expand<HirInlineType>({ getAllInlineTypesInside(context, HirTopLevelModule(it)).items() })
      .toSet()
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}

fun getAllInlineTypesInside(
  context: QueryContext<List<CompilerError>>,
  declarationHir: HirDeclaration,
): Set<HirInlineType> {
  let inlineTypes = MutableSet.empty<HirInlineType>()
  if (declarationHir is HirModule) {}
  if (declarationHir is HirTrait) {
    inlineTypes.addAll(getAllInlineTypesInsideTrait(context, declarationHir as HirTrait).items())
  }
  if (declarationHir is HirImpl) {
    inlineTypes.addAll(getAllInlineTypesInsideImpl(context, declarationHir as HirImpl).items())
  }
  if (declarationHir is HirType) {
    inlineTypes.addAll(getAllInlineTypesInsideType(context, declarationHir as HirType).items())
  }
  if (declarationHir is HirFunction) {
    inlineTypes.addAll(
      getAllInlineTypesInsideFunction(context, declarationHir as HirFunction).items(),
    )
  }
  inlineTypes.addAll(getAllNestedInlineTypesInsideDeclaration(context, declarationHir).items())
  inlineTypes
}
fun getAllInlineTypesInsideTrait(
  context: QueryContext<List<CompilerError>>,
  traitHir: HirTrait,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideTrait",
    traitHir, {
    let inlineTypes = getAllInlineTypesInsideTypeParameters(context, traitHir)
      .union(getAllInlineTypesInsideInlineType(context, traitHir.upperBound(context)))
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}
fun getAllInlineTypesInsideImpl(
  context: QueryContext<List<CompilerError>>,
  implHir: HirImpl,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideImpl",
    implHir, {
    let inlineTypes = getAllInlineTypesInsideTypeParameters(context, implHir)
      .union(getAllInlineTypesInsideInlineType(context, implHir.baseType(context)))
      .union(
        implHir.implementedTrait(context)
          .map<Set<HirInlineType>>({ getAllInlineTypesInsideInlineType(context, it) })
          .orElse({ Set.empty<HirInlineType>() }),
      )
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}
fun getAllInlineTypesInsideType(
  context: QueryContext<List<CompilerError>>,
  typeHir: HirType,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideType",
    typeHir, {
    let inlineTypes = getAllInlineTypesInsideTypeParameters(context, typeHir).union(
      typeHir.type(context)
        .map<Set<HirInlineType>>({ getAllInlineTypesInsideInlineType(context, it) })
        .orElse({ Set.empty<HirInlineType>() }),
    )
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}
fun getAllInlineTypesInsideFunction(
  context: QueryContext<List<CompilerError>>,
  functionHir: HirFunction,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideFunction",
    functionHir, {
    let inlineTypes = getAllInlineTypesInsideTypeParameters(context, functionHir)
      .union(
        (functionHir.valueParameters(context) as Iterable<HirValueParameter>)
          .expand<Set<HirInlineType>>({
            getAllInlineTypesInsideInlineType(context, it.type(context)).items()
          })
          .toSet(),
      )
      .union(
        getAllInlineTypesInsideExpressions(
          context,
          (lowerFunctionBody(context, functionHir)
            .orElse({ List.empty<HirValueExpressionUri>() }) as Iterable<HirValueExpressionUri>),
        ),
      )
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}
fun getAllNestedInlineTypesInsideDeclaration(
  context: QueryContext<List<CompilerError>>,
  declarationHir: HirDeclaration,
): Set<HirInlineType> {
  ((declarationHir as HasDeclarations).declarations(context) as Iterable<HirDeclaration>)
    .expand<HirInlineType>({ getAllInlineTypesInside(context, it).items() })
    .toSet()
}

fun getAllInlineTypesInsideTypeParameters(
  context: QueryContext<List<CompilerError>>,
  declarationHir: HasTypeParameters,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideTypeParameters",
    declarationHir, {
    let inlineTypes = (declarationHir.typeParameters(context) as Iterable<HirParameterType>)
      .map<HirInlineType>({ getAllInlineTypesInsideInlineType(context, it.upperBound(context)) })
      .toSet()
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}

fun getAllInlineTypesInsideInlineTypes(
  context: QueryContext<List<CompilerError>>,
  inlineTypes: List<HirInlineType>,
): Set<HirInlineType> {
  (inlineTypes as Iterable<HirInlineType>)
    .expand<HirInlineType>({ getAllInlineTypesInsideInlineType(context, it).items() })
    .toSet()
}
fun getAllInlineTypesInsideInlineType(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideInlineType",
    inlineType, {
    let inlineTypes = MutableSet.of1<HirInlineType>(inlineType)
    if (inlineType is HirErrorType) { throw "Tried to compile an error type to Dart." }
    if (inlineType is HirNamedType) {
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(context, (inlineType as HirNamedType).parameterTypes)
          .items(),
      )
    }
    if (inlineType is HirFunctionType) {
      let functionType = (inlineType as HirFunctionType)
      functionType.receiverType.do({
        inlineTypes.insert(it)
        unit
      })
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(context, functionType.parameterTypes).items(),
      )
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineType(context, functionType.returnType).items(),
      )
    }
    if (inlineType is HirStructType) {
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(
          context,
          ((inlineType as HirStructType).types as Iterable<(String, HirInlineType)>)
            .map<HirInlineType>({ it.second })
            .toList(),
        ),
      )
    }
    if (inlineType is HirEnumType) {
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(
          context,
          (inlineType as HirEnumType).variants.values().toList(),
        ),
      )
    }
    if (inlineType is HirIntersectionType) {
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(context, (inlineType as HirIntersectionType).types),
      )
    }
    if (inlineType is HirThisType) {}
    if (inlineType is HirParameterType) {}
    if (inlineType is HirReflectionType) {}
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}

fun getAllInlineTypesInsideExpressions(
  context: QueryContext<List<CompilerError>>,
  expressionUris: List<HirValueExpressionUri>,
): Set<HirInlineType> {
  (expressionUris as Iterable<HirValueExpressionUri>)
    .expand<HirInlineType>({ getAllInlineTypesInsideExpression(context, it).items() })
    .toSet()
}
fun getAllInlineTypesInsideExpression(
  context: QueryContext<List<CompilerError>>,
  expressionUri: HirValueExpressionUri,
): Set<HirInlineType> {
  query<Set<HirInlineType>, List<CompilerError>>(
    context,
    "code_generator_dart.getAllInlineTypesInsideExpression",
    expressionUri, {
    let expression = resolveHirValueExpressionUri(context, expressionUri)
    let inlineTypes = getAllInlineTypesInsideInlineType(context, expression.type(context))
      .toMutable()

    if (expression is HirErrorValueExpression) {
      throw "Tried to compile an error expression to Dart."
    }
    if (expression is HirIntValueExpression) {}
    if (expression is HirStringValueExpression) {}
    if (expression is HirLambdaValueExpression) {
      let expression = (expression as HirLambdaValueParameter)
      let parameterTypes = expression.parameters.map<HirInlineType>({ it.type_ }).toList()
      inlineTypes.addAll(getAllInlineTypesInsideInlineTypes(context, parameterTypes).items())
      inlineTypes.addAll(
        getAllInlineTypesInsideExpressions(context, expression.expressions).items(),
      )
      inlineTypes.addAll(getAllInlineTypesInsideInlineType(context, expression.returnType).items())
    }
    if (expression is HirThisValueExpression) {
      let expression = (expression as HirThisValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideInlineType(context, expression.thisType).items())
    }
    if (expression is HirParameterReferenceValueExpression) {}
    if (expression is HirFunctionCallValueExpression) {
      let expression = (expression as HirFunctionCallValueExpression)
      expression.receiver.do({
        if (it is HirValueExpressionUri) {
          inlineTypes.addAll(
            getAllInlineTypesInsideExpression(context, it as HirValueExpressionUri).items(),
          )
        } else {
          inlineTypes.addAll(
            getAllInlineTypesInsideInlineType(context, (it as HirTypeExpression).type).items(),
          )
        }
        unit
      })
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(context, expression.typeArguments.values()).items(),
      )
      inlineTypes.addAll(
        getAllInlineTypesInsideExpressions(context, expression.valueArguments.values().toList())
          .items(),
      )
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.returnType).items())
    }
    if (expression is HirValueExpressionCallValueExpression) {
      let expression = (expression as HirValueExpressionCallValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.receiver).items())
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.returnType).items())
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(context, expression.typeArguments).items(),
      )
      inlineTypes.addAll(
        getAllInlineTypesInsideExpressions(context, expression.valueArguments).items(),
      )
    }
    if (expression is HirTypeInstantiationValueExpression) {
      let expression = (expression as HirTypeInstantiationValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideInlineType(context, expression.receiver).items())
      inlineTypes.addAll(
        getAllInlineTypesInsideExpression(context, expression.valueArgument).items(),
      )
    }
    if (expression is HirStructValueExpression) {
      let expression = (expression as HirStructValueExpression)
      let fields = expression.fields.values()
      inlineTypes.addAll(
        getAllInlineTypesInsideExpressions(
          context,
          fields.map<HirValueExpressionUri>({ it.first }).toList(),
        ).items(),
      )
      inlineTypes.addAll(
        getAllInlineTypesInsideInlineTypes(
          context,
          fields.map<HirInlineType>({ it.second }).toList(),
        ).items(),
      )
    }
    if (expression is HirTypeValueValueExpression) {
      let expression = (expression as HirTypeValueValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.receiver).items())
      inlineTypes.addAll(getAllInlineTypesInsideInlineType(context, expression.type_).items())
    }
    if (expression is HirStructFieldAccessValueExpression) {
      let expression = (expression as HirStructFieldAccessValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.receiver).items())
      inlineTypes.addAll(getAllInlineTypesInsideInlineType(context, expression.type_).items())
    }
    if (expression is HirReturnValueExpression) {
      let expression = (expression as HirReturnValueExpression)
      inlineTypes.addAll(getAllInlineTypesInsideExpression(context, expression.expression).items())
    }
    Tuple(inlineTypes, List.empty<CompilerError>())
  })
}
