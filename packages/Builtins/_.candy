# This package is special to the compiler and code in here behaves somewhat
# different than other code. Be careful when editing the code in here. These are
# the peculiarities you need to worry about:
#
# - There's a magic variable called `✨` in scope. It's a struct containing
#   entry points to compiler builtins – functions that are implemented directly
#   in the Rust compiler rather than in Candy code.
#   For the VM implementations, see `vm/src/builtin_functions.rs`.
#
# - You need to make sure the builtin functions from `✨` are called with valid
#   arguments, so make sure to guard all calls with appropriate needs. If you
#   don't, the underlying Rust code may panic.
#
# - Invalid struct accesses cause panics, so make sure you know a key is in a
#   struct when you access it using the dot syntax.
#
# - Don't remove the `structGet` function! All struct accesses from other
#   packages refer to this function.

typeIs value type =
  needs (type | ✨.typeOf | ✨.equals Tag)
  value | ✨.typeOf | ✨.equals type
not bool = bool %
  True -> False
  False -> True
  _ -> needs False
isNonNegative int =
  needs (int | typeIs Int)
  int | ✨.intCompareTo 0 %
    Greater | Equal -> True
    Less -> False
isLessThanOrEqualTo a b =
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  a | ✨.intCompareTo b %
    Less | Equal -> True
    Greater -> False

equals a b :=
  # Takes two values. Returns `True` if both values are equal, otherwise
  # `False`.
  #
  # TODO: Document how equality works. Also, change how equality for
  # functions works.
  #
  # ```candy
  # ✨.equals 5 5 => True
  # ✨.equals 5 2 => False
  # ```
  ✨.equals a b

functionRun function :=
  # Takes a single function that requires zero arguments. Calls the function
  # with the responsibility being responsible for fulfilling its needs. Returns
  # the return value of the function.
  #
  # This built-in is necessary because functions in Candy are called by writing
  # space-separated arguments such as `foo 2`. For functions that take no value,
  # this syntax is not possible. Such functions are rare though because you
  # don't need them if you're working with pure values.
  #
  # ```candy
  # ✨.functionRun { 4 } => 4
  # ```
  needs (function | typeIs Function)
  needs (function | ✨.getArgumentCount | equals 0)
  ✨.functionRun function

getArgumentCount function :=
  # Takes a single function. Returns the number of arguments the function
  # requires *excluding the responsibility* argument.
  #
  # ```candy
  # ✨.getArgumentCount { a -> a } => 1
  # ✨.getArgumentCount ✨.getArgumentCount => 1
  # ```
  needs (function | typeIs Function)
  ✨.getArgumentCount function

ifElse condition then else :=
  # Takes a condition, a then-function, and an else-function. The condition is
  # `True` or `False` and both given functions take zero arguments. If the
  # condition is `True`, the then-function is executed. If it's `False`, the
  # else-function is executed. Returns the return value of the executed
  # function.
  #
  # ```candy
  # ✨.ifElse True { 1 } { 2 } => 1
  # ✨.ifElse False { 1 } { 2 } => 2
  # ```
  conditionIsBool = condition %
    True | False -> True
    _ -> False
  needs conditionIsBool
  needs (then | typeIs Function)
  needs (then | getArgumentCount | equals 0)
  needs (else | typeIs Function)
  needs (else | getArgumentCount | equals 0)
  ✨.ifElse condition then else

fitsInRustU32 value =
  needs (value | typeIs Int)
  needs (value | isNonNegative)
  rustU32Max = 4294967295
  # https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX
  value | isLessThanOrEqualTo rustU32Max
fitsInRustU128 value =
  needs (value | typeIs Int)
  needs (value | isNonNegative)
  rustU128Max = 340282366920938463463374607431768211455
  # https://doc.rust-lang.org/std/primitive.u128.html#associatedconstant.MAX
  value | isLessThanOrEqualTo rustU128Max

intAdd a b :=
  # Takes two integers. Returns the result of adding both integers.
  #
  # ```candy
  # ✨.intAdd 1 2 => 3
  # ```
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  ✨.intAdd a b

intBitLength value :=
  # Takes one integer. Returns the number of bits that are required to represent
  # that integer, ignoring the sign.
  #
  # ```candy
  # ✨.intBitLength 1 => 1
  # ✨.intBitLength 2 => 2
  # ✨.intBitLength 3 => 2
  # ✨.intBitLength -3 => 2
  # ```
  needs (value | typeIs Int)
  ✨.intBitLength value

intBitwiseAnd a b :=
  # Takes two integers. Returns the result of taking the bitwise "and" of both
  # integers.
  #
  # ```candy
  # ✨.intBitwiseAnd 1 2 => 1
  # ```
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  ✨.intBitwiseAnd a b

intBitwiseOr a b :=
  # Takes two integers. Returns the result of taking the bitwise "or" of both
  # integers.
  #
  # ```candy
  # ✨.intBitwiseOr 1 2 => 2
  # ```
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  ✨.intBitwiseOr a b

intBitwiseXor a b :=
  # Takes two integers. Returns the result of taking the bitwise "xor" of both
  # integers.
  #
  # ```candy
  # ✨.intBitwiseXor 1 3 => 2
  # ```
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  ✨.intBitwiseXor a b

intCompareTo a b :=
  # Takes two integers. Returns the relationship between the integers as a tag,
  # which is either `Less`, `Equal`, or `Greater`.
  #
  # ```candy
  # ✨.intCompareTo 1 3 => Less
  # ✨.intCompareTo 3 3 => Equal
  # ✨.intCompareTo 5 3 => Greater
  # ```
  needs (a | typeIs Int)
  needs (b | typeIs Int)
  ✨.intCompareTo a b

intDivideTruncating dividend divisor :=
  # Takes two integers – a dividend and a non-zero divisor. Returns the dividend
  # divided by the dividend. This operation rounds towards zero, truncating any
  # fractional part of the exact result.
  #
  # ```candy
  # ✨.intDivideTruncating 6 3 => 2
  # ✨.intDivideTruncating 5 3 => 1
  # ```
  needs (dividend | typeIs Int)
  needs (divisor | typeIs Int)
  needs (divisor | equals 0 | not) "You can't divide by zero."
  ✨.intDivideTruncating dividend divisor

intModulo dividend divisor :=
  # Takes two integers – a value and a non-zero divisor. Returns the value
  # modulo the divisor.
  #
  # ```candy
  # ✨.intModulo 6 2 => 0
  # ✨.intModulo 5 2 => 1
  # ```
  needs (dividend | typeIs Int)
  needs (divisor | typeIs Int)
  needs (divisor | equals 0 | not) "You can't divide by zero."
  ✨.intModulo dividend divisor

intMultiply factorA factorB :=
  # Takes two integers. Returns the result of multiplying both integers.
  #
  # ```candy
  # ✨.intMultiply 6 2 => 12
  # ```
  needs (factorA | typeIs Int)
  needs (factorB | typeIs Int)
  ✨.intMultiply factorA factorB

intParse text :=
  # Takes a text. `text` must be a string of decimal digits, optionally preceded
  # by a minus sign. If the text is the textual representation of an integer,
  # returns `Ok` and the parsed integer. Otherwise, returns
  # `Error NotAnInteger`.
  #
  # ```candy
  # ✨.intParse "6" => Ok 6
  # ✨.intParse "-2" => Ok -2
  # ✨.intParse "Foo" => Error NotAnInteger
  # ```
  needs (text | typeIs Text)
  ✨.intParse text

intRemainder dividend divisor :=
  # Takes two integers – a dividend and a non-zero divisor. Returns the
  # remainder you get when dividing the dividend by the divisor.
  #
  # ```candy
  # ✨.intRemainder 12 6 => 0
  # ✨.intRemainder 13 6 => 1
  # ```
  needs (dividend | typeIs Int)
  needs (divisor | typeIs Int)
  needs (divisor | equals 0 | not) "You can't divide by zero."
  ✨.intRemainder dividend divisor

intShiftLeft value amount :=
  # Takes two integers – a value and a non-negative amount. Returns the value
  # shifted to the left by the amount.
  #
  # ```candy
  # ✨.intShiftLeft 1 3 => 8
  # ```
  needs (value | typeIs Int)
  needs (amount | typeIs Int)
  needs
    amount | isNonNegative
    "The shift `amount` is negative: {amount}. You might want to call `shiftRight` instead."
  needs (amount | fitsInRustU128) "Shifts by that much are not yet supported."
  ✨.intShiftLeft value amount

intShiftRight value amount :=
  # Takes two integers – a value and a non-negative amount. Returns the value
  # shifted to the right by the amount.
  #
  # ```candy
  # ✨.intShiftLeft 8 3 => 1
  # ✨.intShiftLeft 10 3 => 1
  # ```
  needs (value | typeIs Int)
  needs (amount | typeIs Int)
  needs
    amount | isNonNegative
    "The shift `amount` is negative: {amount}. You might want to call `shiftLeft` instead."
  needs (amount | fitsInRustU128) "Shifts by that much are not yet supported."
  ✨.intShiftRight value amount

intSubtract minuend subtrahend :=
  # Takes two integers. Returns the first minus the second.
  #
  # ```candy
  # ✨.intSubtract 3 2 => 1
  # ```
  # Returns `minuend` - `subtrahend`.
  needs (minuend | typeIs Int)
  needs (subtrahend | typeIs Int)
  ✨.intSubtract minuend subtrahend

listFilled length item :=
  # Takes an integer (the length of the list) and a value (the item). Returns a
  # list of `length` items, each of which is `item`.
  #
  # ```candy
  # ✨.listFilled 3 Foo => (Foo, Foo, Foo)
  # ✨.listFilled 10 1 => (1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
  # ✨.listFilled 0 Bar => (,)
  # ```
  needs (length | typeIs Int)
  needs (length | isNonNegative)
  ✨.listFilled length item

listGet list index :=
  # Takes a list and an integer index. The index is valid
  # (0 <= index < length of the list). Returns the item that's at the index in
  # the list.
  #
  # ```candy
  # ✨.listGet (Foo, Bar, Baz) 0 => Foo
  # ✨.listGet (Foo, Bar, Baz) 1 => Bar
  # ✨.listGet (Foo, Bar, Baz) 2 => Baz
  # ```
  needs (list | typeIs List)
  needs (index | typeIs Int)
  needs (index | isNonNegative)
  needs (index | intCompareTo (list | ✨.listLength) | equals Less)
  ✨.listGet list index

listInsert list index item :=
  # Takes a list, an integer index, and an item. The index is valid, but can
  # point one past the end of the list (0 <= index <= length of the list).
  # Returns a new list where the item is inserted at the given index.
  #
  # ```candy
  # ✨.listInsert (Foo, Bar) 0 Baz => (Baz, Foo, Bar)
  # ✨.listInsert (Foo, Bar) 1 Baz => (Foo, Baz, Bar)
  # ✨.listInsert (Foo, Bar) 2 Baz => (Foo, Bar, Baz)
  # ```
  needs (list | typeIs List)
  needs (index | typeIs Int)
  needs (index | isNonNegative)
  needs (index | isLessThanOrEqualTo (list | ✨.listLength))
  ✨.listInsert list index item

listLength list :=
  # Takes a list. Returns the length of the list.
  #
  # ```candy
  # ✨.listLength (Foo, Bar) => 2
  # ```
  needs (list | typeIs List)
  ✨.listLength list

listRemoveAt list index :=
  # Takes a list and an index (0 <= index < length of the list). Returns a
  # two-item list with a new list without the item at the index, and the removed
  # item.
  #
  # ```candy
  # ✨.listRemoveAt (Foo, Bar, Baz) 1 => ((Foo, Baz), Bar)
  # ```
  # Returns `(listWithoutItemAtIndex, itemAtIndex)`.
  needs (list | typeIs List)
  needs (index | typeIs Int)
  needs (index | isNonNegative)
  needs (index | intCompareTo (list | listLength) | equals Less)
  ✨.listRemoveAt list index

listReplace list index newItem :=
  # Takes a list, an index (0 <= index < length of the list), and a new item.
  # Returns a list where the item at the given index is replaced with the new
  # item.
  #
  # ```candy
  # ✨.listRemoveAt (Foo, Bar, Baz) 1 Blub => (Foo, Blub, Baz)
  # ```
  needs (list | typeIs List)
  needs (index | typeIs Int)
  needs (index | isNonNegative)
  needs (index | intCompareTo (list | listLength) | equals Less)
  ✨.listReplace list index newItem

print message :=
  # Takes a text and prints it. Returns a `Nothing` tag.
  #
  # ```candy
  # ✨.print "Hello!" => Nothing
  # ```
  ✨.print message

structGet struct key :=
  # Takes a struct and a key. The struct contains the key. Returns the value
  # that's saved for that key.
  #
  # ```candy
  # ✨.structGet [Foo: 2] Foo => 2
  # ```
  needs (struct | typeIs Struct)
  needs (struct | ✨.structHasKey key)
  ✨.structGet struct key

structGetKeys struct :=
  # Takes a struct. Returns a list containing all of the struct keys in no
  # guaranteed order.
  #
  # ```candy
  # ✨.structGetKeys [Foo: 2, Bar: 1] => (Foo, Bar)
  # ```
  # Returns a list of all keys inside `struct`.
  #
  # The order of the keys is unspecified.
  needs (struct | typeIs Struct)
  ✨.structGetKeys struct

structHasKey struct key :=
  # Takes a struct and a key. Returns a boolean of whether the struct
  # contains the key.
  #
  # ```candy
  # ✨.structHasKey [Foo: 2, Bar: 1] Foo => True
  # ✨.structHasKey [Foo: 2, Bar: 1] Bar => False
  # ```
  # Returns whether `struct` contains the key `key`.
  needs (struct | typeIs Struct)
  ✨.structHasKey struct key

tagGetValue tag :=
  # Takes a tag with a value. Returns the tag's value.
  #
  # ```candy
  # ✨.tagGetValue (Foo 1) => 1
  # ✨.tagGetValue (Bar Baz) => Baz
  # ```
  needs (tag | typeIs Tag)
  needs (tag | ✨.tagHasValue)
  ✨.tagGetValue tag

tagHasValue tag :=
  # Takes a tag. Returns a boolean indicating whether the tag has a value.
  #
  # ```candy
  # ✨.tagHasValue (Foo 1) => True
  # ✨.tagHasValue Bar => False
  # ```
  needs (tag | typeIs Tag)
  ✨.tagHasValue tag

tagWithoutValue tag :=
  # Takes a tag. Returns the tag without a value.
  #
  # ```candy
  # ✨.tagWithoutValue (Foo 1) => Foo
  # ✨.tagWithoutValue Bar => Bar
  # ```
  needs (tag | typeIs Tag)
  ✨.tagWithoutValue tag

textCharacters text :=
  # Takes a text. Returns a list of characters (Unicode grapheme clusters) in
  # this text.
  #
  # ```candy
  # ✨.textCharacters "Hello" => ("H", "e", "l", "l", "o")
  # ```
  # 
  needs (text | typeIs Text)
  ✨.textCharacters text

textConcatenate a b :=
  # Takes two texts. Returns a concatenation of both inputs.
  #
  # ```candy
  # ✨.textConcatenate "Hello" "world" => "Helloworld"
  # ```
  needs (a | typeIs Text)
  needs (b | typeIs Text)
  ✨.textConcatenate a b

textContains text pattern :=
  # Takes two texts. Returns whether the first text contains the second one.
  #
  # ```candy
  # ✨.textContains "Hello" "H" => True
  # ✨.textContains "Hello" "X" => False
  # ```
  needs (text | typeIs Text)
  needs (pattern | typeIs Text)
  ✨.textContains text pattern

textEndsWith text suffix :=
  # Takes two texts. Returns whether the first text ends with the second one.
  #
  # ```candy
  # ✨.textEndsWith "Hello, world" "world" => True
  # ✨.textEndsWith "Hello, world" "you" => False
  # ```
  needs (text | typeIs Text)
  needs (suffix | typeIs Text)
  ✨.textEndsWith text suffix

textFromUtf8 bytes :=
  # Takes a list of integers representing bytes (so, 0 <= byte < 256 for each
  # item of the list). If the bytes are a valid UTF-8 encoding, returns the
  # corresponding text. Otherwise, returns `Error NotUtf8` and the original
  # bytes.
  #
  # ```candy
  # ✨.textFromUtf8 (104, 101, 108, 108, 111) => Ok "Hello"
  # ✨.textFromUtf8 (104, 101, 245) => Error NotUtf8
  # ```
  needs (bytes | typeIs List)
  ## TODO: Add this when it runs faster.
  ## needs (bytes | iterable.fromList | iterable.all { byte ->
  ##   bool.lazyAnd (int.is byte) {
  ##     bool.and (byte | int.isNonNegative) (byte | int.isLessThan 256)
  ##   }
  ## })
  ✨.textFromUtf8 bytes

textGetRange text startInclusive endExclusive :=
  # Takes a text, and two integers, representing the inclusive start and
  # exclusive end. Returns the substring of the text in that range.
  #
  # ```candy
  # ✨.textGetRange "Hello" 1 3 => "el"
  # ```
  needs (text | typeIs Text)
  needs (startInclusive | typeIs Int)
  needs (startInclusive | isNonNegative)
  needs (startInclusive | isLessThanOrEqualTo (text | ✨.textLength))
  needs (endExclusive | typeIs Int)
  needs (endExclusive | isNonNegative)
  needs (endExclusive | isLessThanOrEqualTo (text | ✨.textLength))
  needs (startInclusive | isLessThanOrEqualTo endExclusive)
  ✨.textGetRange text startInclusive endExclusive

textIsEmpty text :=
  # Takes a text. Returns whether it's empty.
  #
  # ```candy
  # ✨.textIsEmpty "Hello" => False
  # ✨.textIsEmpty "" => True
  # ```
  needs (text | typeIs Text)
  ✨.textIsEmpty text

textLength text :=
  # Takes a text. Returns the number of grapheme clusters in that text.
  #
  # ```candy
  # ✨.textLength "Hello" => 5
  # ✨.textLength "" => 0
  # ```
  # Returns the number of characters (Unicode grapheme clusters) in this text.
  needs (text | typeIs Text)
  ✨.textLength text

textStartsWith text prefix :=
  # Takes two texts. Returns whether the first text starts with the second
  # one.
  #
  # ```candy
  # ✨.textEndsWith "Hello, world" "Hello" => True
  # ✨.textEndsWith "Hello, world" "Hi" => False
  # ```
  needs (text | typeIs Text)
  needs (prefix | typeIs Text)
  ✨.textStartsWith text prefix

textTrimEnd text :=
  # Takes a text. Returns a text with whitespace removed at the end.
  #
  # ```candy
  # ✨.textTrimEnd "  Hi  " => "  Hi"
  # ```
  needs (text | typeIs Text)
  # text
  ✨.textTrimEnd text

textTrimStart text :=
  # Takes a text. Returns a text with whitespace removed at the start.
  #
  # ```candy
  # ✨.textTrimStart "  Hi  " => "Hi  "
  # ```
  needs (text | typeIs Text)
  # text
  ✨.textTrimStart text

toDebugText any :=
  # Takes a value. Returns a stringified version of the value.
  #
  # ```candy
  # ✨.toDebugText 2 => "2"
  # ```
  ✨.toDebugText any

typeOf any :=
  # Takes a value. Returns a tag denoting the type of the value. These are the
  # possible types: `Function`, `Int`, `List`, `Struct`, `Text`, `Tag`
  #
  # ```candy
  # ✨.typeOf {} => Function
  # ✨.typeOf 2 => Int
  # ✨.typeOf (1, 2) => List
  # ✨.typeOf [Foo: 2] => Struct
  # ✨.typeOf "Hi" => Text
  # ✨.typeOf Text => Tag
  # ```
  ✨.typeOf any
