use lexer
use ..declarations
use ..node
use ..types

public trait /* enum */ CstExpression


public data class CstIntExpression {
  public let value: CstNode<LiteralToken<Int>>
}
impl CstIntExpression: CstExpression


public data class CstStringExpression {
  public let openingQuote: CstNode<PunctuationToken>
  public let parts: List<CstNode<StringPart>>
  public let closingQuote: Maybe<CstNode<PunctuationToken>>
}
impl CstStringExpression: CstExpression

public trait /* enum */ StringPart

public data class CstLiteralStringPart {
  public let value: CstNode<IdentifierToken>
  // TODO(JonasWanke): Check this when our lexer supports strings.
}
impl CstLiteralStringPart: CstExpression

public data class CstInterpolatedStringPart {
  public let openingCurlyBrace: CstNode<PunctuationToken>
  public let expression: Maybe<CstNode<CstExpression>>
  public let closingCurlyBrace: Maybe<CstNode<PunctuationToken>>
}
impl CstInterpolatedStringPart: CstExpression


public data class CstLambdaExpression {
  public let openingCurlyBrace: CstNode<PunctuationToken>
  public let valueParameters: Maybe<CstNode<CstLambdaExpressionValueParameters>>
  public let expressions: List<CstNode<CstExpression>>
  public let closingCurlyBrace: Maybe<CstNode<PunctuationToken>>
}
impl CstLambdaExpression: CstExpression

public data class CstLambdaExpressionValueParameters {
  public let valueParameters: List<CstNode<CstValueParameter | PunctuationToken>>
  public let arrow: CstNode<PunctuationToken>
}


public data class CstIdentifierExpression {
  public let value: CstNode<IdentifierToken>
}
impl CstIdentifierExpression: CstExpression


public data class CstBinaryExpression {
  public let leftOperand: Maybe<CstNode<CstExpression>>

  public let operator: CstNode<PunctuationToken>
  /// May be one of the following:
  ///
  /// * arithmetic: `+`, `-`, `*`, `/`, `~/`, `%`
  /// * assignment & comparison: `=`, `==`, `!=`, `<`, `<=`, `>`, `>=`
  /// * logical: `&`, `|`, `=>`
  ///
  /// TODO(JonasWanke): convert this to an enum when we support these

  public let rightOperand: Maybe<CstNode<CstExpression>>
}
impl CstBinaryExpression: CstExpression


impl CstProperty: CstExpression


public data class CstNavigationExpression {
  public let receiver: CstNode<CstExpression>
  public let target: CstNode<IdentifierToken>
}
impl CstNavigationExpression: CstExpression

public data class CstCallExpression {
  public let receiver: CstNode<CstExpression>
  public let typeArguments: Maybe<CstNode<CstTypeArguments>>
  public let valueArguments: CstNode<CstValueArguments>
}
impl CstCallExpression: CstExpression

public data class CstValueArguments {
  public let openingParenthesis: CstNode<PunctuationToken>
  public let valueArguments: List<CstNode<CstValueArgument | PunctuationToken>>
  public let closingParenthesis: Maybe<CstNode<PunctuationToken>>
}
public data class CstValueArgument {
  public let name: Maybe<(Maybe<CstNode<IdentifierToken>>, CstNode<PunctuationToken>)>
  public let value: Maybe<CstNode<CstExpression>>
}

public data class CstTupleExpression {
  public let openingParenthesis: CstNode<PunctuationToken>
  public let valueArguments: List<Maybe<CstNode<CstExpression>> | CstNode<PunctuationToken>>
  public let closingParenthesis: Maybe<CstNode<PunctuationToken>>
}
impl CstTupleExpression: CstExpression


public data class CstIfExpression {
  public let ifKeyword: CstNode<KeywordToken>
  public let condition: Maybe<CstNode<CstExpression>>
  public let body: Maybe<CstNode<CstExpression | CstIfElseBracedBody>>
  public let elsePart: Maybe<CstNode<CstElsePart>>
}
impl CstIfExpression: CstExpression

public data class CstElsePart {
  public let elseKeyword: CstNode<KeywordToken>
  public let body: Maybe<CstNode<CstExpression | CstIfElseBracedBody>>
}
public data class CstIfElseBracedBody {
  public let openingCurlyBrace: CstNode<PunctuationToken>
  public let expressions: List<CstNode<CstExpression>>
  public let closingCurlyBrace: Maybe<CstNode<PunctuationToken>>
}

public data class CstReturnExpression {
  public let returnKeyword: CstNode<KeywordToken>
  public let value: Maybe<CstNode<CstExpression>>
}
impl CstReturnExpression: CstExpression
