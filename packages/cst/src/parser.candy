use lexer
use petit_parser
use ..declarations
use ..expressions
use ..file
use ..node
use ..types

public fun parseString(source: String): CstFile { parse(lex(source)) }
public fun parse(tokens: List<Token>): CstFile {
  let parser = CstParser(
    tokens,
    0,
    notYetDefined<Token, CstNode<CstType>>("Parser not yet defined."),
    notYetDefined<Token, CstNode<CstExpression>>("Parser not yet defined."),
  )
  parser.initType()
  parser.parse()
}

class CstParser {
  let tokens: List<Token>
  mut let nextId = 0

  fun parse(): CstFile {
    let result = file().parseInput(tokens)
    if result is Error<Success<CstFile>, Failure> {
      throw "Couldn't parse file: {result}."
    }
    result.unwrap().output
  }

  // file

  fun file(): Parser<Token, CstFile> {
    useLine()
        .map<CstNode<CstUseLine | CstDeclaration>>({ it as CstNode<CstUseLine | CstDeclaration> })
        .star()
        .map<CstFile>({ CstFile(it) })
  }

  fun useLine(): Parser<Token, CstNode<CstUseLine>> {
    localRelativeUseLine()
        .or<CstNode<CstGlobalUseLine>>(globalUseLine())
        .map<CstNode<CstUseLine>>({ it as CstNode<CstUseLine> })
  }
  fun localRelativeUseLine(): Parser<Token, CstNode<CstLocalRelativeUseLine>> {
    let path = identifier()
        .or<CstNode<PunctuationToken>>(punctuation("."))
        .map<CstNode<IdentifierToken | PunctuationToken>>({ it as CstNode<IdentifierToken | PunctuationToken> })
        .star()
    let useLine = modifiers()
        .sequence<CstNode<KeywordToken>>(keyword("use"))
        .sequence<List<CstNode<PunctuationToken>>>(punctuation(".").plus())
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(path)
        .map<CstLocalRelativeUseLine>({
          let modifiers = it.first.first.first
          let useKeyword = it.first.first.second
          let parentNavigations = it.first.second
          let path = it.second
          CstLocalRelativeUseLine(modifiers, useKeyword, parentNavigations, path)
        })
    node<CstLocalRelativeUseLine>(useLine)
  }
  fun globalUseLine(): Parser<Token, CstNode<CstGlobalUseLine>> {
    let packagePath = identifier()
        .or<CstNode<PunctuationToken>>(punctuation("."))
        .map<CstNode<IdentifierToken | PunctuationToken>>({ it as CstNode<IdentifierToken | PunctuationToken> })
        .star()
    let useLine = modifiers()
        .sequence<CstNode<KeywordToken>>(keyword("use"))
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(packagePath)
        .map<CstGlobalUseLine>({
          let modifiers = it.first.first
          let useKeyword = it.first.second
          let packagePath = it.second
          CstGlobalUseLine(modifiers, useKeyword, packagePath)
        })
    node<CstGlobalUseLine>(useLine)
  }

  // declarations

  fun declaration(): Parser<Token, CstNode<CstDeclaration>> {
    let declaration = notYetDefined<Token, CstNode<CstDeclaration>>("Parser not yet defined.")
    let declarationBeginning = { keywordString: String =>
        modifiers().sequence<CstNode<KeywordToken>>(keyword(keywordString))
    }
    let declarationBeginningWithName = { keywordString: String =>
        declarationBeginning(keywordString)
            .sequence<Maybe<CstNode<IdentifierToken>>>(identifier().optional())
    }

    let optionalDeclarationContent = node<CstDeclarationContent>(
        punctuation("üëç")
          .sequence<List<CstNode<CstDeclaration>>>(declaration.star())
          .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
          .map<CstDeclarationContent>({
            let openingCurlyBrace = it.first.first
            let innerDeclarations = it.first.second
            let closingCurlyBrace = it.second
            CstDeclarationContent(openingCurlyBrace, innerDeclarations, closingCurlyBrace)
          })
      )
      .optional()

    let module_ = declarationBeginningWithName("module")
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first
          let moduleKeyword = it.first.first.second
          let name = it.first.second
          let content = it.second
          CstModule(modifiers, moduleKeyword, name, content)
        })

    let trait_ = declarationBeginningWithName("trait")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let traitKeyword = it.first.first.first.first.second
          let name = it.first.first.first.second
          let typeParameters = it.first.first.second
          let upperBound = it.first.second
          let content = it.second
          CstTrait(modifiers, traitKeyword, name, typeParameters, upperBound, content)
        })

    let impl_ = declarationBeginning("impl")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let implKeyword = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let type = it.first.first.second
          let traits = it.first.second
          let content = it.second
          CstImpl(modifiers, implKeyword, typeParameters, type, traits, content)
        })

    let class_ = declarationBeginningWithName("class")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first
          let classKeyword = it.first.first.first.second
          let name = it.first.first.second
          let typeParameters = it.first.second
          let content = it.second
          CstClass(modifiers, classKeyword, name, typeParameters, content)
        })

    let function = declarationBeginningWithName("fun")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstValueParameters>>>(valueParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstBlockBody | CstExpressionBody>>>(
          blockBody()
              .or<CstNode<CstExpressionBody>>(expressionBody())
              .map<CstNode<CstBlockBody | CstExpressionBody>>({
                it as CstNode<CstBlockBody | CstExpressionBody>
              })
              .optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first.first
          let functionKeyword = it.first.first.first.first.first.second
          let name = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let valueParameters = it.first.first.second
          let returnType = it.first.second
          let body = it.second
          CstFunction(
            modifiers,
            functionKeyword,
            name,
            typeParameters,
            valueParameters,
            returnType,
            body,
          )
        })

    let property = declarationBeginningWithName("let")
        .or<(
          (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
          Maybe<CstNode<IdentifierToken>>,
        )>(
          declarationBeginningWithName("var")
        )
        .map<(
          (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
          Maybe<CstNode<IdentifierToken>>,
        )>({
          it as (
              (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
              Maybe<CstNode<IdentifierToken>>,
            )
        })
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDelegationBody>>>(
            delegationBody().optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first
          let keyword = it.first.first.first.second
          let name = it.first.first.second
          let type = it.first.second
          let initializer = it.second
          let initializer = it.second
          CstProperty(modifiers, keyword, name, type, initializer)
        })

    declaration.delegate = node<CstDeclaration>(
      choiceOf<Token, CstDeclaration>(
        List.of6<Parser<Token, CstDeclaration>>(module_, trait_, impl_, class_, function, property),
      ),
    )
    declaration
  }

  fun valueParameters(): Parser<Token, CstNode<CstValueParameters>> {
    let valueParameters = punctuation("(")
        .sequence<List<CstNode<CstValueParameter | PunctuationToken>>>(
          commaSeparated<CstValueParameter>(valueParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstValueParameters>({ CstValueParameters(it.first.first, it.first.second, it.second) })
    node<CstValueParameters>(valueParameters)
  }
  fun valueParameter(): Parser<Token, CstNode<CstValueParameter>> {
    // TODO(JonasWanke): allow modifiers
    let valueParameter = identifier()
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDelegationBody>>>(delegationBody().optional())
        .map<CstValueParameter>({
          CstValueParameter(
            List.empty<CstNode<IdentifierToken>>(),
            it.first.first,
            it.first.second,
            it.second,
          )
        })
    node<CstValueParameter>(valueParameter)
  }

  fun blockBody(): Parser<Token, CstNode<CstBlockBody>> {
    let blockBody = punctuation("üëç")
        // TODO(JonasWanke): expressions
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstBlockBody>({
          CstBlockBody(it.first, List.empty<CstNode<CstExpression>>(), it.second)
        })
    node<CstBlockBody>(blockBody)
  }
  fun expressionBody(): Parser<Token, CstNode<CstExpressionBody>> {
    let expressionBody = punctuation("->")
        // TODO(JonasWanke): expression
        .map<CstExpressionBody>({ CstExpressionBody(it, None<CstNode<CstExpression>>()) })
    node<CstExpressionBody>(expressionBody)
  }
  fun delegationBody(): Parser<Token, CstNode<CstDelegationBody>> {
    let delegationBody = punctuation("=")
        // TODO(JonasWanke): expression
        .map<CstDelegationBody>({ CstDelegationBody(it, None<CstNode<CstExpression>>()) })
    node<CstDelegationBody>(delegationBody)
  }

  // types

  let type = notYetDefined<Token, CstNode<CstType>>("Parser not yet defined.")
  fun initType() {
    let closingParenthesisOrOtherEndDetection = punctuationOrEnd(")")
        .or<Maybe<CstNode<PunctuationToken>>>(
          punctuation(">")
              .or<CstNode<PunctuationToken>>(punctuation("}"))
              .and()
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })

    // TODO(JonasWanke): allow modifiers
    let namedType = punctuation(".")
        .star()
        .sequence<CstNode<IdentifierToken>>(identifier())
        .sequence<List<(List<CstNode<PunctuationToken>>, CstNode<IdentifierToken>)>>(
          punctuation(".")
              .plus()
              .sequence<CstNode<IdentifierToken>>(identifier())
              .plus()
        )
        .map<List<CstNode<IdentifierToken | PunctuationToken>>>({
          let initialDots = (it.first.first as Iterable<CstNode<PunctuationToken>>)
              .map<CstNode<IdentifierToken | PunctuationToken>>({
                it as CstNode<IdentifierToken | PunctuationToken>
              })
          let initialIdentifier = it.first.second
          let remaining = it.second
          let result = MutableList.empty<CstNode<IdentifierToken | PunctuationToken>>()
          result.appendAll(initialDots)
          result.append(initialIdentifier as CstNode<IdentifierToken | PunctuationToken>)
          for tuple in remaining {
            let dots = (tuple.first as Iterable<CstNode<PunctuationToken>>)
                .map<CstNode<IdentifierToken | PunctuationToken>>({
                  it as CstNode<IdentifierToken | PunctuationToken>
                })
            result.appendAll(dots)
            result.append(tuple.second as CstNode<IdentifierToken | PunctuationToken>)
          }
          result
        })
        .sequence<Maybe<CstNode<CstTypeArguments>>>(typeArguments().optional())
        .map<CstType>({ CstNamedType(List.empty<CstNode<IdentifierToken>>(), it.first, it.second) })

    let groupType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(
          punctuationOrEnd(")")
              .or<Maybe<CstNode<PunctuationToken>>>(
                punctuation(">")
                  .and()
                  .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
              )
              .or<Maybe<CstNode<PunctuationToken>>>(
                punctuation("}")
                  .and()
                  .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
              )
              .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })
        )
        .map<CstType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let type = it.first.second
          let closingParenthesis = it.second
          CstGroupType(modifiers, openingParenthesis, type, closingParenthesis)
        })

    let tupleType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<List<CstNode<CstType | PunctuationToken>>>(commaSeparated<CstType>(type))
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let types = it.first.second
          let closingParenthesis = it.second
          CstTupleType(modifiers, openingParenthesis, types, closingParenthesis)
        })

    let intersectionType = notYetDefined<Token, CstType>("Parser not yet defined.")
    intersectionType.delegate = node<CstType>(
          choiceOf<Token, CstType>(List.of2<Parser<Token, CstType>>(namedType, groupType)),
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("&"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<Token, CstType>(
              List.of3<Parser<Token, CstType>>(intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let leftType = it.first.first
          let ampersand = it.first.second
          let rightType = it.second
          CstIntersectionType(leftType, ampersand, rightType)
        })

    let unionType = notYetDefined<Token, CstType>("Parser not yet defined.")
    unionType.delegate = node<CstType>(
          choiceOf<Token, CstType>(
            List.of3<Parser<Token, CstType>>(intersectionType, groupType, namedType),
          ),
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("|"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<Token, CstType>(
              List.of4<Parser<Token, CstType>>(unionType, intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let leftType = it.first.first
          let bar = it.first.second
          let rightType = it.second
          CstUnionType(leftType, bar, rightType)
        })

    let functionTypeParameterTypes = punctuation("(")
        .sequence<List<CstNode<CstType | PunctuationToken>>>(commaSeparated<CstType>(type))
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstFunctionTypeParameterTypes>({
          CstFunctionTypeParameterTypes(it.first.first, it.first.second, it.second)
        })
    let functionTypeParameterTypes = node<CstFunctionTypeParameterTypes>(functionTypeParameterTypes)
    // TODO(JonasWanke): allow modifiers
    let functionType = node<CstType>(
          choiceOf<Token, CstType>(
            List.of4<Parser<Token, CstType>>(unionType, intersectionType, groupType, namedType),
          ),
        )
        .optional()
        .sequence<Maybe<CstNode<CstFunctionTypeParameterTypes>>>(
          functionTypeParameterTypes.optional()
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<Token, CstType>(
              List.of4<Parser<Token, CstType>>(unionType, intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let modifiers = List.empty<CstNode<IdentifierToken>>()
          let receiverType = it.first.first.first
          let parameterTypes = it.first.first.second
          let arrow = it.first.second
          let returnType = it.second
          CstFunctionType(modifiers, receiverType, parameterTypes, arrow, returnType)
        })

    type.delegate = node<CstType>(
      choiceOf<Token, CstType>(
        List.of6<Parser<Token, CstType>>(
          unionType,
          intersectionType,
          functionType,
          groupType,
          tupleType,
          namedType,
        ),
      ),
    )
  }

  fun typeParameters(): Parser<Token, CstNode<CstTypeParameters>> {
    let typeParameters = punctuation("<")
        .sequence<List<CstNode<CstTypeParameter | PunctuationToken>>>(
          commaSeparated<CstTypeParameter>(typeParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(">"))
        .map<CstTypeParameters>({ CstTypeParameters(it.first.first, it.first.second, it.second) })
    node<CstTypeParameters>(typeParameters)
  }
  fun typeParameter(): Parser<Token, CstNode<CstTypeParameter>> {
    let typeParameter = modifiers()
        .sequence<Maybe<CstNode<IdentifierToken>>>(identifier().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .map<CstTypeParameter>({ CstTypeParameter(it.first.first, it.first.second, it.second) })
    node<CstTypeParameter>(typeParameter)
  }

  fun typeArguments(): Parser<Token, CstNode<CstTypeArguments>> {
    let typeArguments = punctuation("<")
        .sequence<List<CstNode<CstTypeArgument | PunctuationToken>>>(
          commaSeparated<CstTypeArgument>(typeArgument())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(">"))
        .map<CstTypeArguments>({ CstTypeArguments(it.first.first, it.first.second, it.second) })
    node<CstTypeArguments>(typeArguments)
  }
  fun typeArgument(): Parser<Token, CstNode<CstTypeArgument>> {
    let typeArgument = modifiers()
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .map<CstTypeArgument>({ CstTypeArgument(it.first, it.second) })
    node<CstTypeArgument>(typeArgument)
  }

  // expressions

  let expression_ = notYetDefined<Token, CstNode<CstExpression>>("Parser not yet defined.")
  fun initExpression() {
    let intExpression = node<LiteralToken<Int>>(token<LiteralToken<Int>>("int literal", { true }))
        .map<CstExpression>({ CstIntExpression(it) })

    let lambdaExpressionValueParameters = commaSeparated<CstValueParameter>(
      valueParameter()
    )
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .map<CstLambdaExpressionValueParameters>({
          CstLambdaExpressionValueParameters(it.first, it.second)
        })
    let lambdaExpressionValueParameters = node<CstLambdaExpressionValueParameters>(
      lambdaExpressionValueParameters
    )
    let lambdaExpression = punctuation("üëç")
        .sequence<Maybe<CstNode<CstLambdaExpressionValueParameters>>>(
          lambdaExpressionValueParameters.optional()
        )
        .sequence<List<CstNode<CstExpression>>>(expression_.star())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstExpression>({
          let openingCurlyBrace = it.first.first.first
          let valueParameters = it.first.first.second
          let expressions = it.first.second
          let closingCurlyBrace = it.second
          CstLambdaExpression(openingCurlyBrace, valueParameters, expressions, closingCurlyBrace)
        })

    let identifierExpression = identifier()
        .map<CstExpression>({ CstIdentifierExpression(it) })

    // TODO(JonasWanke): binary expressions
    // TODO(JonasWanke): property expressions

    let navigationExpression = node<CstExpression>(
      choiceOf<Token, CstExpression>(
        List.of3<Parser<Token, CstExpression>>(
          intExpression,
          lambdaExpression,
          identifierExpression,
        ),
      ),
    )
        .sequence<List<CstNode<IdentifierToken>>>(identifier().plus())
        .map<CstExpression>({
          let receiver = it.first
          let targets = (it.second as Iterable<CstNode<IdentifierToken>>)
          targets.foldLeft<CstNode<CstExpression>>(
            receiver,
            { receiver, target =>
              CstNode<CstExpression>(
                getNextNodeId(),
                CstNavigationExpression(receiver, target),
                List.empty<WhitespaceToken | CommentToken>(),
              )
            },
          ).child as CstExpression
        })

    let callExpression = node<CstExpression>(
      choiceOf<Token, CstExpression>(
        List.of4<Parser<Token, CstExpression>>(
          intExpression,
          lambdaExpression,
          identifierExpression,
          navigationExpression,
        ),
      ),
    )
        .sequence<List<(Maybe<CstNode<CstTypeArguments>>, CstNode<CstValueArguments>)>(
          typeArguments()
              .optional()
              .sequence<CstNode<CstValueArguments>>(valueArguments())
              .plus()
        )
        .map<CstExpression>({
          let receiver = it.first
          let targets = (it.second as Iterable<(Maybe<CstNode<CstTypeArguments>>, CstNode<CstValueArguments>)>)
          arguments.foldLeft<CstNode<CstExpression>>(
            receiver,
            { receiver, arguments =>
              CstNode<CstExpression>(
                getNextNodeId(),
                CstCallExpression(receiver, arguments.first, arguments.second),
                List.empty<WhitespaceToken | CommentToken>(),
              )
            },
          ).child as CstExpression
        })

    // TODO(JonasWanke): tuple expression
    // TODO(JonasWanke): if/else expression
    // TODO(JonasWanke): return expression

    expression_.delegate = node<CstExpression>(
      choiceOf<Token, CstExpression>(
        List.of5<Parser<Token, CstExpression>>(
          intExpression,
          // TODO(JonasWanke): string expressions
          lambdaExpression,
          identifierExpression,
          // TODO(JonasWanke): binary expressions
          // TODO(JonasWanke): property expressions
          navigationExpression,
          callExpression,
          // TODO(JonasWanke): tuple expression
          // TODO(JonasWanke): if/else expression
          // TODO(JonasWanke): return expression
        ),
      ),
    )
  }

  // utilities

  fun modifiers(): Parser<Token, List<CstNode<IdentifierToken>>> { identifier().star() }

  fun keyword(keyword: String): Parser<Token, CstNode<KeywordToken>> {
    let token = token<KeywordToken>("keyword", { it.keyword == keyword })
    node<KeywordToken>(token)
  }
  fun identifier(): Parser<Token, CstNode<IdentifierToken>> {
    node<IdentifierToken>(token<IdentifierToken>("identifier", { true }))
  }
  fun punctuation(punctuation: String): Parser<Token, CstNode<PunctuationToken>> {
    let token = token<PunctuationToken>("punctuation", { it.punctuation == punctuation })
    node<PunctuationToken>(token)
  }
  fun punctuationOrEnd(
    punctuationString: String,
  ): Parser<Token, Maybe<CstNode<PunctuationToken>>> {
    punctuation(punctuationString)
        .map<Maybe<CstNode<PunctuationToken>>>({ Some<CstNode<PunctuationToken>>(it) })
        .or<Maybe<CstNode<PunctuationToken>>>(
          endOfInput<Token>("End of input expected.")
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })
  }
  fun commaSeparated<Output>(
    parser: Parser<Token, CstNode<Output>>,
  ): Parser<Token, List<CstNode<Output | PunctuationToken>>> {
    parser
        .or<CstNode<PunctuationToken>>(punctuation(","))
        .map<CstNode<Output | PunctuationToken>>({ it as CstNode<Output | PunctuationToken> })
        .star()
  }

  fun node<T>(parser: Parser<Token, T>): Parser<Token, CstNode<T>> {
    let parser = parser.sequence<List<WhitespaceToken | CommentToken>>(trailingTrivia())
    parser.map<CstNode<T>>({ output =>
      CstNode<T>(getNextNodeId(), output.first, output.second)
    })
  }
  fun getNextNodeId(): CstNodeId {
    let id = CstNodeId(nextId)
    nextId = nextId + 1
    id
  }
  fun trailingTrivia(): Parser<Token, List<WhitespaceToken | CommentToken>> {
    whitespace().or<CommentToken>(comment()).star()
  }
  fun whitespace(): Parser<Token, WhitespaceToken> { token<WhitespaceToken>("whitespace", { true }) }
  fun comment(): Parser<Token, CommentToken> { token<CommentToken>("comment", { true }) }

  fun token<T: Token>(name: String, tester: (T) => Bool): Parser<Token, T> {
    custom<Token, T>(
      1,
      { tokens =>
        assert((tokens as Iterable<Token>).length() == 1, "List should only contain one token.")

        let token = (tokens as Iterable<Token>).first().unwrap()
        let result = if token is T && tester(token as T) {
          Some<T>(token as T)
        } else {
          None<T>()
        }
        result as Maybe<T>
      },
      "Expected a {name}.",
    )
  }
}
