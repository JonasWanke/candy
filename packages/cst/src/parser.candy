use petit_parser
use ..declarations
use ..expressions
use ..file
use ..node
use ..tokens
use ..types

public fun parse(source: String): CstFile {
  let parser = CstParser(
    source.characters().toList(),
    0,
    notYetDefined<String, CstNode<CstType>>("Parser not yet defined."),
    notYetDefined<String, CstNode<CstExpression>>("Parser not yet defined."),
  )
  parser.initType()
  parser.initExpression()
  parser.parse()
}

class CstParser {
  let source: List<String>
  mut let nextId = 0

  fun parse(): CstFile {
    let result = file().parseInput(source)
    if result is Error<Success<CstFile>, Failure> {
      throw "Couldn't parse file: {result}."
    }
    result.unwrap().output
  }

  // file

  fun file(): Parser<String, CstFile> {
    useLine()
        .map<CstNode<CstUseLine | CstDeclaration>>({ it as CstNode<CstUseLine | CstDeclaration> })
        .star()
        .map<CstFile>({ CstFile(it) })
  }

  fun useLine(): Parser<String, CstNode<CstUseLine>> {
    localRelativeUseLine()
        .or<CstNode<CstGlobalUseLine>>(globalUseLine())
        .map<CstNode<CstUseLine>>({ it as CstNode<CstUseLine> })
  }
  fun localRelativeUseLine(): Parser<String, CstNode<CstLocalRelativeUseLine>> {
    let path = identifier()
        .or<CstNode<PunctuationToken>>(punctuation("."))
        .map<CstNode<IdentifierToken | PunctuationToken>>({ it as CstNode<IdentifierToken | PunctuationToken> })
        .star()
    let useLine = modifiers()
        .sequence<CstNode<KeywordToken>>(keyword("use"))
        .sequence<List<CstNode<PunctuationToken>>>(punctuation(".").plus())
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(path)
        .map<CstLocalRelativeUseLine>({
          let modifiers = it.first.first.first
          let useKeyword = it.first.first.second
          let parentNavigations = it.first.second
          let path = it.second
          CstLocalRelativeUseLine(modifiers, useKeyword, parentNavigations, path)
        })
    node<CstLocalRelativeUseLine>(useLine)
  }
  fun globalUseLine(): Parser<String, CstNode<CstGlobalUseLine>> {
    let packagePath = identifier()
        .or<CstNode<PunctuationToken>>(punctuation("."))
        .map<CstNode<IdentifierToken | PunctuationToken>>({ it as CstNode<IdentifierToken | PunctuationToken> })
        .star()
    let useLine = modifiers()
        .sequence<CstNode<KeywordToken>>(keyword("use"))
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(packagePath)
        .map<CstGlobalUseLine>({
          let modifiers = it.first.first
          let useKeyword = it.first.second
          let packagePath = it.second
          CstGlobalUseLine(modifiers, useKeyword, packagePath)
        })
    node<CstGlobalUseLine>(useLine)
  }

  // declarations

  fun declaration(): Parser<String, CstNode<CstDeclaration>> {
    let declaration = notYetDefined<String, CstNode<CstDeclaration>>("Parser not yet defined.")
    let declarationBeginning = { keywordString: String =>
        modifiers().sequence<CstNode<KeywordToken>>(keyword(keywordString))
    }
    let declarationBeginningWithName = { keywordString: String =>
        declarationBeginning(keywordString)
            .sequence<Maybe<CstNode<IdentifierToken>>>(identifier().optional())
    }

    let optionalDeclarationContent = node<CstDeclarationContent>(
        punctuation("üëç")
          .sequence<List<CstNode<CstDeclaration>>>(declaration.star())
          .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
          .map<CstDeclarationContent>({
            let openingCurlyBrace = it.first.first
            let innerDeclarations = it.first.second
            let closingCurlyBrace = it.second
            CstDeclarationContent(openingCurlyBrace, innerDeclarations, closingCurlyBrace)
          })
      )
      .optional()

    let module_ = declarationBeginningWithName("module")
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first
          let moduleKeyword = it.first.first.second
          let name = it.first.second
          let content = it.second
          CstModule(modifiers, moduleKeyword, name, content)
        })

    let trait_ = declarationBeginningWithName("trait")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let traitKeyword = it.first.first.first.first.second
          let name = it.first.first.first.second
          let typeParameters = it.first.first.second
          let upperBound = it.first.second
          let content = it.second
          CstTrait(modifiers, traitKeyword, name, typeParameters, upperBound, content)
        })

    let impl_ = declarationBeginning("impl")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let implKeyword = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let type = it.first.first.second
          let traits = it.first.second
          let content = it.second
          CstImpl(modifiers, implKeyword, typeParameters, type, traits, content)
        })

    let class_ = declarationBeginningWithName("class")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first
          let classKeyword = it.first.first.first.second
          let name = it.first.first.second
          let typeParameters = it.first.second
          let content = it.second
          CstClass(modifiers, classKeyword, name, typeParameters, content)
        })

    let function = declarationBeginningWithName("fun")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstValueParameters>>>(valueParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstBlockBody | CstExpressionBody>>>(
          blockBody()
              .or<CstNode<CstExpressionBody>>(expressionBody())
              .map<CstNode<CstBlockBody | CstExpressionBody>>({
                it as CstNode<CstBlockBody | CstExpressionBody>
              })
              .optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first.first
          let functionKeyword = it.first.first.first.first.first.second
          let name = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let valueParameters = it.first.first.second
          let returnType = it.first.second
          let body = it.second
          CstFunction(
            modifiers,
            functionKeyword,
            name,
            typeParameters,
            valueParameters,
            returnType,
            body,
          )
        })

    let property = declarationBeginningWithName("let")
        .or<(
          (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
          Maybe<CstNode<IdentifierToken>>,
        )>(
          declarationBeginningWithName("var")
        )
        .map<(
          (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
          Maybe<CstNode<IdentifierToken>>,
        )>({
          it as (
              (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>),
              Maybe<CstNode<IdentifierToken>>,
            )
        })
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDelegationBody>>>(
            delegationBody().optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first
          let keyword = it.first.first.first.second
          let name = it.first.first.second
          let type = it.first.second
          let initializer = it.second
          let initializer = it.second
          CstProperty(modifiers, keyword, name, type, initializer)
        })

    declaration.delegate = node<CstDeclaration>(
      choiceOf<String, CstDeclaration>(
        List.of6<Parser<String, CstDeclaration>>(module_, trait_, impl_, class_, function, property),
      ),
    )
    declaration
  }

  fun valueParameters(): Parser<String, CstNode<CstValueParameters>> {
    let valueParameters = punctuation("(")
        .sequence<List<CstNode<CstValueParameter | PunctuationToken>>>(
          commaSeparated<CstValueParameter>(valueParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstValueParameters>({ CstValueParameters(it.first.first, it.first.second, it.second) })
    node<CstValueParameters>(valueParameters)
  }
  fun valueParameter(): Parser<String, CstNode<CstValueParameter>> {
    // TODO(JonasWanke): allow modifiers
    let valueParameter = identifier()
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDelegationBody>>>(delegationBody().optional())
        .map<CstValueParameter>({
          CstValueParameter(
            List.empty<CstNode<IdentifierToken>>(),
            it.first.first,
            it.first.second,
            it.second,
          )
        })
    node<CstValueParameter>(valueParameter)
  }

  fun blockBody(): Parser<String, CstNode<CstBlockBody>> {
    let blockBody = punctuation("üëç")
        // TODO(JonasWanke): expressions
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstBlockBody>({
          CstBlockBody(it.first, List.empty<CstNode<CstExpression>>(), it.second)
        })
    node<CstBlockBody>(blockBody)
  }
  fun expressionBody(): Parser<String, CstNode<CstExpressionBody>> {
    let expressionBody = punctuation("->")
        // TODO(JonasWanke): expression
        .map<CstExpressionBody>({ CstExpressionBody(it, None<CstNode<CstExpression>>()) })
    node<CstExpressionBody>(expressionBody)
  }
  fun delegationBody(): Parser<String, CstNode<CstDelegationBody>> {
    let delegationBody = punctuation("=")
        // TODO(JonasWanke): expression
        .map<CstDelegationBody>({ CstDelegationBody(it, None<CstNode<CstExpression>>()) })
    node<CstDelegationBody>(delegationBody)
  }

  // types

  let type = notYetDefined<String, CstNode<CstType>>("Parser not yet defined.")
  fun initType() {
    let closingParenthesisOrOtherEndDetection = punctuationOrEnd(")")
        .or<Maybe<CstNode<PunctuationToken>>>(
          punctuation(">")
              .or<CstNode<PunctuationToken>>(punctuation("}"))
              .and()
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })

    // TODO(JonasWanke): allow modifiers
    let namedType = punctuation(".")
        .star()
        .sequence<CstNode<IdentifierToken>>(identifier())
        .sequence<List<(List<CstNode<PunctuationToken>>, CstNode<IdentifierToken>)>>(
          punctuation(".")
              .plus()
              .sequence<CstNode<IdentifierToken>>(identifier())
              .plus()
        )
        .map<List<CstNode<IdentifierToken | PunctuationToken>>>({
          let initialDots = (it.first.first as Iterable<CstNode<PunctuationToken>>)
              .map<CstNode<IdentifierToken | PunctuationToken>>({
                it as CstNode<IdentifierToken | PunctuationToken>
              })
          let initialIdentifier = it.first.second
          let remaining = it.second
          let result = MutableList.empty<CstNode<IdentifierToken | PunctuationToken>>()
          result.appendAll(initialDots)
          result.append(initialIdentifier as CstNode<IdentifierToken | PunctuationToken>)
          for tuple in remaining {
            let dots = (tuple.first as Iterable<CstNode<PunctuationToken>>)
                .map<CstNode<IdentifierToken | PunctuationToken>>({
                  it as CstNode<IdentifierToken | PunctuationToken>
                })
            result.appendAll(dots)
            result.append(tuple.second as CstNode<IdentifierToken | PunctuationToken>)
          }
          result
        })
        .sequence<Maybe<CstNode<CstTypeArguments>>>(typeArguments().optional())
        .map<CstType>({ CstNamedType(List.empty<CstNode<IdentifierToken>>(), it.first, it.second) })

    let groupType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(
          punctuationOrEnd(")")
              .or<Maybe<CstNode<PunctuationToken>>>(
                punctuation(">")
                  .and()
                  .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
              )
              .or<Maybe<CstNode<PunctuationToken>>>(
                punctuation("}")
                  .and()
                  .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
              )
              .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })
        )
        .map<CstType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let type = it.first.second
          let closingParenthesis = it.second
          CstGroupType(modifiers, openingParenthesis, type, closingParenthesis)
        })

    let tupleType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<List<CstNode<CstType | PunctuationToken>>>(commaSeparated<CstType>(type))
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let types = it.first.second
          let closingParenthesis = it.second
          CstTupleType(modifiers, openingParenthesis, types, closingParenthesis)
        })

    let intersectionType = notYetDefined<String, CstType>("Parser not yet defined.")
    intersectionType.delegate = node<CstType>(
          choiceOf<String, CstType>(List.of2<Parser<String, CstType>>(namedType, groupType)),
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("&"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<String, CstType>(
              List.of3<Parser<String, CstType>>(intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let leftType = it.first.first
          let ampersand = it.first.second
          let rightType = it.second
          CstIntersectionType(leftType, ampersand, rightType)
        })

    let unionType = notYetDefined<String, CstType>("Parser not yet defined.")
    unionType.delegate = node<CstType>(
          choiceOf<String, CstType>(
            List.of3<Parser<String, CstType>>(intersectionType, groupType, namedType),
          ),
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("|"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<String, CstType>(
              List.of4<Parser<String, CstType>>(unionType, intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let leftType = it.first.first
          let bar = it.first.second
          let rightType = it.second
          CstUnionType(leftType, bar, rightType)
        })

    let functionTypeParameterTypes = punctuation("(")
        .sequence<List<CstNode<CstType | PunctuationToken>>>(commaSeparated<CstType>(type))
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstFunctionTypeParameterTypes>({
          CstFunctionTypeParameterTypes(it.first.first, it.first.second, it.second)
        })
    let functionTypeParameterTypes = node<CstFunctionTypeParameterTypes>(functionTypeParameterTypes)
    // TODO(JonasWanke): allow modifiers
    let functionType = node<CstType>(
          choiceOf<String, CstType>(
            List.of4<Parser<String, CstType>>(unionType, intersectionType, groupType, namedType),
          ),
        )
        .optional()
        .sequence<Maybe<CstNode<CstFunctionTypeParameterTypes>>>(
          functionTypeParameterTypes.optional()
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .sequence<Maybe<CstNode<CstType>>>(
          node<CstType>(
            choiceOf<String, CstType>(
              List.of4<Parser<String, CstType>>(unionType, intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstType>({
          let modifiers = List.empty<CstNode<IdentifierToken>>()
          let receiverType = it.first.first.first
          let parameterTypes = it.first.first.second
          let arrow = it.first.second
          let returnType = it.second
          CstFunctionType(modifiers, receiverType, parameterTypes, arrow, returnType)
        })

    type.delegate = node<CstType>(
      choiceOf<String, CstType>(
        List.of6<Parser<String, CstType>>(
          unionType,
          intersectionType,
          functionType,
          groupType,
          tupleType,
          namedType,
        ),
      ),
    )
  }

  fun typeParameters(): Parser<String, CstNode<CstTypeParameters>> {
    let typeParameters = punctuation("<")
        .sequence<List<CstNode<CstTypeParameter | PunctuationToken>>>(
          commaSeparated<CstTypeParameter>(typeParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(">"))
        .map<CstTypeParameters>({ CstTypeParameters(it.first.first, it.first.second, it.second) })
    node<CstTypeParameters>(typeParameters)
  }
  fun typeParameter(): Parser<String, CstNode<CstTypeParameter>> {
    let typeParameter = modifiers()
        .sequence<Maybe<CstNode<IdentifierToken>>>(identifier().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstType>>>(type.optional())
              .optional()
        )
        .map<CstTypeParameter>({ CstTypeParameter(it.first.first, it.first.second, it.second) })
    node<CstTypeParameter>(typeParameter)
  }

  fun typeArguments(): Parser<String, CstNode<CstTypeArguments>> {
    let typeArguments = punctuation("<")
        .sequence<List<CstNode<CstTypeArgument | PunctuationToken>>>(
          commaSeparated<CstTypeArgument>(typeArgument())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(">"))
        .map<CstTypeArguments>({ CstTypeArguments(it.first.first, it.first.second, it.second) })
    node<CstTypeArguments>(typeArguments)
  }
  fun typeArgument(): Parser<String, CstNode<CstTypeArgument>> {
    let typeArgument = modifiers()
        .sequence<Maybe<CstNode<CstType>>>(type.optional())
        .map<CstTypeArgument>({ CstTypeArgument(it.first, it.second) })
    node<CstTypeArgument>(typeArgument)
  }

  // expressions

  let expression_ = notYetDefined<String, CstNode<CstExpression>>("Parser not yet defined.")
  fun initExpression() {
    let intExpression = intLiteral()
        .map<CstExpression>({ CstIntExpression(it) })

    let lambdaExpressionValueParameters = commaSeparated<CstValueParameter>(
      valueParameter()
    )
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .map<CstLambdaExpressionValueParameters>({
          CstLambdaExpressionValueParameters(it.first, it.second)
        })
    let lambdaExpressionValueParameters = node<CstLambdaExpressionValueParameters>(
      lambdaExpressionValueParameters
    )
    let lambdaExpression = punctuation("üëç")
        .sequence<Maybe<CstNode<CstLambdaExpressionValueParameters>>>(
          lambdaExpressionValueParameters.optional()
        )
        .sequence<List<CstNode<CstExpression>>>(expression_.star())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstExpression>({
          let openingCurlyBrace = it.first.first.first
          let valueParameters = it.first.first.second
          let expressions = it.first.second
          let closingCurlyBrace = it.second
          CstLambdaExpression(openingCurlyBrace, valueParameters, expressions, closingCurlyBrace)
        })

    let identifierExpression = identifier()
        .map<CstExpression>({ CstIdentifierExpression(it) })

    let groupExpression = punctuation("(")
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstExpression>({
          let openingParenthesis = it.first.first
          let expression = it.first.second
          let closingParenthesis = it.second
          CstGroupExpression(openingParenthesis, expression, closingParenthesis)
          loop {}
        })

    let tupleExpression = punctuation("(")
        .sequence<List<CstNode<CstExpression | PunctuationToken>>>(commaSeparated<CstExpression>(expression_))
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstExpression>({
          let openingParenthesis = it.first.first
          let valueArguments = it.first.second
          let closingParenthesis = it.second
          CstTupleExpression(openingParenthesis, valueArguments, closingParenthesis)
        })

    // TODO(JonasWanke): binary expressions
    // TODO(JonasWanke): property expressions

    let navigationExpression = node<CstExpression>(
      choiceOf<String, CstExpression>(
        List.of5<Parser<String, CstExpression>>(
          groupExpression,
          tupleExpression,
          // TODO(JonasWanke): callExpression
          intExpression,
          lambdaExpression,
          identifierExpression,
        ),
      ),
    )
        .sequence<List<(CstNode<PunctuationToken>, Maybe<CstNode<IdentifierToken>>)>>(
          punctuation(".")
              .sequence<Maybe<CstNode<IdentifierToken>>>(identifier().optional())
              .plus()
        )
        .map<CstExpression>({
          let receiver = it.first
          let navigationParts = (it.second as Iterable<(CstNode<PunctuationToken>, Maybe<CstNode<IdentifierToken>>)>)
          navigationParts.foldLeft<CstNode<CstExpression>>(
            receiver,
            { receiver, navigationPart =>
              CstNode<CstExpression>(
                getNextNodeId(),
                CstNavigationExpression(receiver, navigationPart.first, navigationPart.second),
                List.empty<WhitespaceToken | CommentToken>(),
              )
            },
          ).child as CstExpression
        })

    let callExpression = node<CstExpression>(
      choiceOf<String, CstExpression>(
        List.of6<Parser<String, CstExpression>>(
          groupExpression,
          tupleExpression,
          navigationExpression,
          intExpression,
          lambdaExpression,
          identifierExpression,
        ),
      ),
    )
        .sequence<List<(Maybe<CstNode<CstTypeArguments>>, CstNode<CstValueArguments>)>>(
          typeArguments()
              .optional()
              .sequence<CstNode<CstValueArguments>>(valueArguments())
              .plus()
        )
        .map<CstExpression>({
          let receiver = it.first
          let arguments = (it.second as Iterable<(Maybe<CstNode<CstTypeArguments>>, CstNode<CstValueArguments>)>)
          arguments.foldLeft<CstNode<CstExpression>>(
            receiver,
            { receiver, arguments =>
              CstNode<CstExpression>(
                getNextNodeId(),
                CstCallExpression(receiver, arguments.first, arguments.second),
                List.empty<WhitespaceToken | CommentToken>(),
              )
            },
          ).child as CstExpression
        })

    let higherPrecedenceThanBinaryParsers = List.of7<Parser<String, CstExpression>>(
      groupExpression,
      tupleExpression,
      navigationExpression,
      callExpression,
      intExpression,
      lambdaExpression,
      identifierExpression,
    )
    let buildBinaryLeftAssociative = {
        operators: List<String>,
        higherPrecedenceBinaryParsers: List<Parser<String, CstExpression>> =>
      let higherPrecedenceParsers = node<CstExpression>(
        choiceOf<String, CstExpression>(
          higherPrecedenceThanBinaryParsers.followedByList(higherPrecedenceBinaryParsers),
        ),
      )

      let operatorsParser = choiceOf<String, CstNode<PunctuationToken>>(
        (operators as Iterable<String>)
            .map<Parser<String, CstNode<PunctuationToken>>>({ punctuation(it) })
            .toList()
      )

      higherPrecedenceParsers
          .optional()
          .separatedBy<CstNode<PunctuationToken>>(operatorsParser, 2, false)
          .map<CstExpression>({
            let iterable = it as Iterable<Maybe<CstNode<CstExpression>> | CstNode<PunctuationToken>>
            mut let result = (iterable.first().unwrap() as Maybe<CstNode<CstExpression>>)

            mut let index = 1
            while index < iterable.length() {
              let operator = (iterable.get(index).unwrap() as CstNode<PunctuationToken>)
              let rightOperand = (iterable.get(index + 1).unwrap() as Maybe<CstNode<CstExpression>>)
              result = Some<CstNode<CstExpression>>(
                CstNode<CstExpression>(
                  getNextNodeId(),
                  CstBinaryExpression(result, operator, rightOperand),
                  List.empty<WhitespaceToken | CommentToken>(),
                ),
              )
              index = index + 2
            }
            result.unwrap().child as CstExpression
          })
    }
    let binaryExpressionMultiplicative = buildBinaryLeftAssociative(
      List.of4<String>("*", "/", "~/", "%"),
      List.empty<Parser<String, CstExpression>>(),
    )
    let binaryExpressionAdditive = buildBinaryLeftAssociative(
      List.of2<String>("+", "-"),
      List.of1<Parser<String, CstExpression>>(binaryExpressionMultiplicative),
    )
    let binaryExpressionComparison = buildBinaryLeftAssociative(
      List.of4<String>("<", "<=", ">", ">="),
      List.of2<Parser<String, CstExpression>>(
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      ),
    )
    let binaryExpressionEquality = buildBinaryLeftAssociative(
      List.of2<String>("==", "!="),
      List.of3<Parser<String, CstExpression>>(
        binaryExpressionComparison,
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      ),
    )
    let binaryExpressionLogicalAnd = buildBinaryLeftAssociative(
      List.of1<String>("&"),
      List.of4<Parser<String, CstExpression>>(
        binaryExpressionEquality,
        binaryExpressionComparison,
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      ),
    )
    let binaryExpressionLogicalOr = buildBinaryLeftAssociative(
      List.of1<String>("|"),
      List.of5<Parser<String, CstExpression>>(
        binaryExpressionLogicalAnd,
        binaryExpressionEquality,
        binaryExpressionComparison,
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      ),
    )
    let binaryExpressionLogicalImplication = buildBinaryLeftAssociative(
      List.of1<String>("=>"),
      List.of6<Parser<String, CstExpression>>(
        binaryExpressionLogicalOr,
        binaryExpressionLogicalAnd,
        binaryExpressionEquality,
        binaryExpressionComparison,
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      ),
    )
    let higherPrecedenceThanAssignmentParser = node<CstExpression>(
      choiceOf<String, CstExpression>(
        higherPrecedenceThanBinaryParsers
            .followedByList(
              List.of7<Parser<String, CstExpression>>(
                binaryExpressionLogicalImplication,
                binaryExpressionLogicalOr,
                binaryExpressionLogicalAnd,
                binaryExpressionEquality,
                binaryExpressionComparison,
                binaryExpressionAdditive,
                binaryExpressionMultiplicative,
              ),
            ),
      ),
    )
    let binaryExpressionAssignment = higherPrecedenceThanAssignmentParser
        .optional()
        .sequence<CstNode<PunctuationToken>>(punctuation("="))
        .sequence<Maybe<CstNode<CstExpression>>>(higherPrecedenceThanAssignmentParser.optional())
        .map<CstExpression>({
          CstBinaryExpression(it.first.first, it.first.second, it.second)
        })
    let binaryExpression = choiceOf<String, CstExpression>(
      List.of8<Parser<String, CstExpression>>(
        binaryExpressionAssignment,
        binaryExpressionLogicalImplication,
        binaryExpressionLogicalOr,
        binaryExpressionLogicalAnd,
        binaryExpressionEquality,
        binaryExpressionComparison,
        binaryExpressionAdditive,
        binaryExpressionMultiplicative,
      )
    )
 
    let returnExpression = keyword("return")
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .map<CstExpression>({ CstReturnExpression(it.first, it.second) })

    expression_.delegate = node<CstExpression>(
      choiceOf<String, CstExpression>(
        List.of9<Parser<String, CstExpression>>(
          groupExpression,
          tupleExpression,
          binaryExpression,
          // TODO(JonasWanke): property expressions
          navigationExpression,
          callExpression,
          returnExpression,
          intExpression,
          // TODO(JonasWanke): string expressions
          lambdaExpression,
          identifierExpression,
        ),
      ),
    )
  }

  fun valueArguments(): Parser<String, CstNode<CstValueArguments>> {
    let valueArguments = punctuation("(")
        .sequence<List<CstNode<CstValueArgument | PunctuationToken>>>(
          commaSeparated<CstValueArgument>(valueArgument())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstValueArguments>({ CstValueArguments(it.first.first, it.first.second, it.second) })
    node<CstValueArguments>(valueArguments)
  }
  fun valueArgument(): Parser<String, CstNode<CstValueArgument>> {
    let valueArgument = identifier()
        .optional()
        .sequence<CstNode<PunctuationToken>>(punctuation("="))
        .optional()
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .map<CstValueArgument>({ CstValueArgument(it.first, it.second) })
    node<CstValueArgument>(valueArgument)
  }

  // utilities

  fun modifiers(): Parser<String, List<CstNode<IdentifierToken>>> { identifier().star() }

  fun node<T>(parser: Parser<String, T>): Parser<String, CstNode<T>> {
    let parser = parser.sequence<List<WhitespaceToken | CommentToken>>(trailingTrivia())
    parser.map<CstNode<T>>({ output =>
      CstNode<T>(getNextNodeId(), output.first, output.second)
    })
  }
  fun getNextNodeId(): CstNodeId {
    let id = CstNodeId(nextId)
    nextId = nextId + 1
    id
  }

  // lexer

  fun keyword(keyword: String): Parser<String, CstNode<KeywordToken>> {
    assert((keywords as Iterable<String>).any({ it == keyword }), "Invalid keyword: {keyword}.")

    let parser = string(keyword, "'{keyword}' expected.")
        .token()
        .map<KeywordToken>({ KeywordToken(it.span, keyword) })
    node<KeywordToken>(parser)
  }
  fun identifier(): Parser<String, CstNode<IdentifierToken>> {
    let firstCharacter = character(
          {
            "a" <= it && it <= "z"
            || "A" <= it && it <= "Z"
            || it == "_"
          },
          "Letter or underscore expected.",
        )
    let followingCharacter = character(
          {
            "a" <= it && it <= "z"
            || "A" <= it && it <= "Z"
            || "0" <= it && it <= "9"
            || it == "_"
          },
          "Letter, digit or underscore expected.",
        )
    let parser = firstCharacter
        .sequence<List<String>>(followingCharacter.star())
        .token()
        .map<Token<String, String>>({
          let a = it
          Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
        })
        .when({ token =>
          if (keywords as Iterable<String>).any({ it == token.value }) {
            return Error<Unit, String>("Expected an identifier, but got keyword '{token.value}'.")
          }
          Ok<Unit, String>(unit)
        })
        .map<IdentifierToken>({ IdentifierToken(it.span, it.value) })
    node<IdentifierToken>(parser)
  }

  fun intLiteral(): Parser<String, CstNode<IntLiteralToken>> {
    let parser = digit("Digit expected.")
        .plus()
        .map<Int>({ Int.parse((it as Iterable<String>).join("")) })
        .token()
        .map<IntLiteralToken>({ IntLiteralToken(it.span, it.value as Int) })
    node<IntLiteralToken>(parser)
  }
  
  fun punctuation(punctuation: String): Parser<String, CstNode<PunctuationToken>> {
    // TODO(JonasWanke): detect punctuation separated by whitespace, e.g., "> =" as ">="

    let parser = string(punctuation, "'{punctuation}' expected.")
        .token()
        .map<PunctuationToken>({ PunctuationToken(it.span, punctuation) })
    node<PunctuationToken>(parser)
  }
  fun punctuationOrEnd(
    punctuationString: String,
  ): Parser<String, Maybe<CstNode<PunctuationToken>>> {
    punctuation(punctuationString)
        .map<Maybe<CstNode<PunctuationToken>>>({ Some<CstNode<PunctuationToken>>(it) })
        .or<Maybe<CstNode<PunctuationToken>>>(
          endOfInput<String>("End of input expected.")
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .map<Maybe<CstNode<PunctuationToken>>>({ it as Maybe<CstNode<PunctuationToken>> })
  }
  fun commaSeparated<Output>(
    parser: Parser<String, CstNode<Output>>,
  ): Parser<String, List<CstNode<Output | PunctuationToken>>> {
    parser
        .or<CstNode<PunctuationToken>>(punctuation(","))
        .map<CstNode<Output | PunctuationToken>>({ it as CstNode<Output | PunctuationToken> })
        .star()
  }

  fun trailingTrivia(): Parser<String, List<WhitespaceToken | CommentToken>> {
    whitespace().or<CommentToken>(comment()).star()
  }
  fun whitespace(): Parser<String, WhitespaceToken> {
    character(
      { it == " " || it == "\t" || it == "\r" || it == "\n" },
      "Whitespace expected.",
    )
        .plus()
        .token()
        .map<Token<String, String>>({
          Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
        })
        .map<WhitespaceToken>({ WhitespaceToken(it.span, it.value) })
  }
  fun comment(): Parser<String, CommentToken> {
    let lineCommentFromStart = { start: Parser<String, String> =>
      start
          .sequence<String>(
            lineBreak()
                .negated("Expected something different from the receiver.")
                .star()
                .token()
                .map<String>({ (it.input as Iterable<String>).join("") })
          )
          .map<String>({ it.second })
          .token()
          .sequence<Unit>(
            lineBreak()
                .or<Unit>(endOfInput<String>("End of input expected."))
                .map<Unit>({ unit })
                .and()
          )
          .map<(Span, String)>({ Tuple(it.first.span, it.first.value as String) })
    }
    let docComment = lineCommentFromStart(string("///", "'///' expected."))
        .map<CommentToken>({ CommentToken(it.first, it.second, "doc") })
    let lineComment = lineCommentFromStart(string("//", "'//' expected."))
        .map<CommentToken>({ CommentToken(it.first, it.second, "line") })

    let blockComment = notYetDefined<String, CommentToken>("Parser not yet defined.")
    blockComment.delegate = string("/*", "'/*' expected.")
        .sequence<Token<String, String>>(
          blockComment
              .or<Failure>(string("*/", "'*/' expected.").negated("Expected something different from the receiver."))
              .star()
              .token()
              .map<Token<String, String>>({
                Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
              })
        )
        .sequence<Unit>(
          string("*/", "'*/' expected.")
              .or<Unit>(endOfInput<String>("End of input expected."))
              .map<Unit>({ unit })
        )
        .map<CommentToken>({
          let token = it.first.second
          CommentToken(token.span, token.value, "block")
        })

    choiceOf<String, CommentToken>(
      List.of3<Parser<String, CommentToken>>(docComment, lineComment, blockComment),
    )
  }
  fun lineBreak(): Parser<String, Token<String, String>> {
    singleCharacter("\r", "'\\r' expected.")
        .optional()
        .sequence<String>(singleCharacter("\n", "'\\n' expected."))
        .token()
        .map<Token<String, String>>({
          Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
        })
  }
}
let keywords = List.of12<String>(
  "use", "crate",
  "module", "trait", "impl", "class",
  "fun", "let", "var", "get", "set",
  "return",
)
