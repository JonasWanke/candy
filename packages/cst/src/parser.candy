use compiler_utils
use incremental
use petit_parser
use ..declarations
use ..expressions
use ..file
use ..node
use ..tokens
use ..types

public fun parseCstOfFile(context: QueryContext<List<CompilerError>>, file: FancyFile): CstNode<CstFile> {
  query<CstNode<CstFile>, List<CompilerError>>(context, "parseCstOfFile", (file as Equals & Hash), {
    Tuple(parseCst(context, file.read(context)), List.empty<CompilerError>())
  })
}
public fun parseCst(context: QueryContext<List<CompilerError>>, source: String): CstNode<CstFile> {
  query<CstNode<CstFile>, List<CompilerError>>(context, "parseCst", (source as Equals & Hash), {
    Tuple(parse(source), List.empty<CompilerError>())
  })
}


public fun parse(source: String): CstNode<CstFile> {
  let parser = CstParser(
    source.characters().toList(),
    0,
    notYetDefined<String, CstNode<CstInlineType>>("Parser not yet defined."),
    notYetDefined<String, CstNode<CstExpression>>("Parser not yet defined."),
  )
  parser.initInlineType()
  parser.initExpression()
  parser.parse()
}

class CstParser {
  let source: List<String>
  mut let nextId = 0

  fun parse(): CstNode<CstFile> {
    let result = file().parseInput(source)
    if result is Error<Success<CstNode<CstFile>>, Failure> {
      throw "Couldn't parse file: {result}."
    }
    result.unwrap().output
  }

  // file

  fun file(): Parser<String, CstNode<CstFile>> {
    let parser = trivia()
      .sequence<List<CstNode<CstUseLine | CstDeclaration>>>(
        choiceOf<String, CstNode<CstUseLine | CstDeclaration>>(
          List.of2<Parser<String, CstNode<CstUseLine | CstDeclaration>>>(
            useLine() as Parser<String, CstNode<CstUseLine | CstDeclaration>>,
            declaration() as Parser<String, CstNode<CstUseLine | CstDeclaration>>,
          ),
        )
        .star()
      )
      .map<CstFile>({ CstFile(it.first, it.second) })
    node<CstFile>(parser)
  }

  fun useLine(): Parser<String, CstNode<CstUseLine>> {
    let parser = modifiers()
        .sequence<CstNode<KeywordToken>>(keyword("use"))
        .sequence<Maybe<CstNode<CstUseLineTarget>>>(
          choiceOf<String, CstNode<CstUseLineTarget>>(
            List.of2<Parser<String, CstNode<CstUseLineTarget>>>(
              localRelativeUseLineTarget(),
              globalUseLineTarget(),
            ),
          ).optional()
        )
        .map<CstUseLine>({ CstUseLine(it.first.first, it.first.second, it.second) })
    node<CstUseLine>(parser)
  }
  fun localRelativeUseLineTarget(): Parser<String, CstNode<CstUseLineTarget>> {
    let parser = punctuation(".")
        .plus()
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(
          identifier(true)
              .or<CstNode<PunctuationToken>>(punctuation("."))
              .cast<CstNode<IdentifierToken | PunctuationToken>>()
              .star()
        )
        .map<CstUseLineTarget>({ CstLocalRelativeUseLineTarget(it.first, it.second) })
    node<CstUseLineTarget>(parser)
  }
  fun globalUseLineTarget(): Parser<String, CstNode<CstUseLineTarget>> {
    let parser = identifier(true)
        .or<CstNode<PunctuationToken>>(punctuation("."))
        .cast<CstNode<IdentifierToken | PunctuationToken>>()
        .plus()
        .map<CstUseLineTarget>({ CstGlobalUseLineTarget(it) })
    node<CstUseLineTarget>(parser)
  }

  // declarations

  fun declaration(): Parser<String, CstNode<CstDeclaration>> {
    let declaration = notYetDefined<String, CstNode<CstDeclaration>>("Parser not yet defined.")

    let optionalDeclarationContent = node<CstDeclarationContent>(
        punctuation("\üëç")
          .sequence<List<CstNode<CstDeclaration>>>(declaration.star())
          .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
          .map<CstDeclarationContent>({
            let openingCurlyBrace = it.first.first
            let innerDeclarations = it.first.second
            let closingCurlyBrace = it.second
            CstDeclarationContent(openingCurlyBrace, innerDeclarations, closingCurlyBrace)
          })
      )
      .optional()

    let module_ = declarationBeginningWithName("module", true)
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first
          let moduleKeyword = it.first.first.second
          let name = it.first.second
          let content = it.second
          CstModule(modifiers, moduleKeyword, name, content)
        })

    let trait_ = declarationBeginningWithName("trait", true)
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let traitKeyword = it.first.first.first.first.second
          let name = it.first.first.first.second
          let typeParameters = it.first.first.second
          let upperBound = it.first.second
          let content = it.second
          CstTrait(modifiers, traitKeyword, name, typeParameters, upperBound, content)
        })

    let impl_ = declarationBeginning("impl")
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstDeclarationContent>>>(optionalDeclarationContent)
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first
          let implKeyword = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let type = it.first.first.second
          let traits = it.first.second
          let content = it.second
          CstImpl(modifiers, implKeyword, typeParameters, type, traits, content)
        })

    let type = declarationBeginningWithName("type", true)
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>>(
          punctuation("=")
              .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
              .optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first
          let typeKeyword = it.first.first.first.second
          let name = it.first.first.second
          let typeParameters = it.first.second
          let type = it.second
          CstType(modifiers, typeKeyword, name, typeParameters, type)
        })

    let function = declarationBeginningWithName("fun", false)
        .sequence<Maybe<CstNode<CstTypeParameters>>>(typeParameters().optional())
        .sequence<Maybe<CstNode<CstValueParameters>>>(valueParameters().optional())
        .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>>(
          punctuation(":")
              .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
              .optional()
        )
        .sequence<Maybe<CstNode<CstBlockBody | CstExpressionBody>>>(
          blockBody()
              .or<CstNode<CstExpressionBody>>(expressionBody())
              .cast<CstNode<CstBlockBody | CstExpressionBody>>()
              .optional()
        )
        .map<CstDeclaration>({
          let modifiers = it.first.first.first.first.first.first
          let functionKeyword = it.first.first.first.first.first.second
          let name = it.first.first.first.first.second
          let typeParameters = it.first.first.first.second
          let valueParameters = it.first.first.second
          let returnType = it.first.second
          let body = it.second
          CstFunction(
            modifiers,
            functionKeyword,
            name,
            typeParameters,
            valueParameters,
            returnType,
            body,
          )
        })

    declaration.delegate = node<CstDeclaration>(
      choiceOf<String, CstDeclaration>(
        List.of5<Parser<String, CstDeclaration>>(module_, trait_, impl_, type, function),
      ),
    )
    declaration
  }
  fun declarationBeginning(
    keywordString: String,
  ): Parser<String, (List<CstNode<IdentifierToken>>, CstNode<KeywordToken>)> {
      modifiers().sequence<CstNode<KeywordToken>>(keyword(keywordString))
  }
  fun declarationBeginningWithName(
    keywordString: String,
    startWithUppercase: Bool,
  ): Parser<
    String,
    ((List<CstNode<IdentifierToken>>, CstNode<KeywordToken>), Maybe<CstNode<IdentifierToken>>),
  > {
      declarationBeginning(keywordString)
          .sequence<Maybe<CstNode<IdentifierToken>>>(identifier(startWithUppercase).optional())
  }

  fun valueParameters(): Parser<String, CstNode<CstValueParameters>> {
    let valueParameters = punctuation("(")
        .sequence<List<CstNode<CstValueParameter | PunctuationToken>>>(
          commaSeparated<CstValueParameter>(valueParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstValueParameters>({ CstValueParameters(it.first.first, it.first.second, it.second) })
    node<CstValueParameters>(valueParameters)
  }
  fun valueParameter(): Parser<String, CstNode<CstValueParameter>> {
    // TODO(never, JonasWanke): allow modifiers
    // TODO(soon, JonasWanke): allow parameters without a name
    let valueParameter = atLeastOne<
      CstNode<IdentifierToken>,
      (CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>),
    >(
      identifier(false),
      punctuation(":").sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional()),
    ).sequence<Maybe<CstNode<CstExpressionBody>>>(expressionBody().optional())
      .map<CstValueParameter>({
        CstValueParameter(
          List.empty<CstNode<IdentifierToken>>(),
          it.first.first,
          it.first.second,
          it.second,
        )
      })
    node<CstValueParameter>(valueParameter)
  }

  fun blockBody(): Parser<String, CstNode<CstBlockBody>> {
    let blockBody = punctuation("\üëç")
        .sequence<List<CstNode<CstExpression>>>(expression_.star())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstBlockBody>({
          CstBlockBody(it.first.first, it.first.second, it.second)
        })
    node<CstBlockBody>(blockBody)
  }
  fun expressionBody(): Parser<String, CstNode<CstExpressionBody>> {
    let expressionBody = punctuation("=")
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .map<CstExpressionBody>({ CstExpressionBody(it.first, it.second) })
    node<CstExpressionBody>(expressionBody)
  }

  // types

  let inlineType = notYetDefined<String, CstNode<CstInlineType>>("Parser not yet defined.")
  fun initInlineType() {
    let closingParenthesisOrOtherEndDetection = punctuationOrEnd(")")
        .or<Maybe<CstNode<PunctuationToken>>>(
          punctuation("]")
              .or<CstNode<PunctuationToken>>(punctuation("}"))
              .and()
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .cast<Maybe<CstNode<PunctuationToken>>>()

    let namedType = modifiers()
        .sequence<List<CstNode<IdentifierToken | PunctuationToken>>>(
          punctuation(".")
              .star()
              .sequence<CstNode<IdentifierToken>>(identifier(true))
              .sequence<List<(List<CstNode<PunctuationToken>>, CstNode<IdentifierToken>)>>(
                punctuation(".")
                    .plus()
                    .sequence<CstNode<IdentifierToken>>(identifier(true))
                    .star()
              )
              .map<List<CstNode<IdentifierToken | PunctuationToken>>>({
                let initialDots = (it.first.first as Iterable<CstNode<PunctuationToken>>)
                    .cast<CstNode<IdentifierToken | PunctuationToken>>()
                let initialIdentifier = it.first.second
                let remaining = it.second
                let result = MutableList.empty<CstNode<IdentifierToken | PunctuationToken>>()
                result.appendAll(initialDots)
                result.append(initialIdentifier as CstNode<IdentifierToken | PunctuationToken>)
                for tuple in remaining {
                  let dots = (tuple.first as Iterable<CstNode<PunctuationToken>>)
                      .cast<CstNode<IdentifierToken | PunctuationToken>>()
                  result.appendAll(dots)
                  result.append(tuple.second as CstNode<IdentifierToken | PunctuationToken>)
                }
                result
              }),
          )
        .sequence<Maybe<CstNode<CstTypeArguments>>>(typeArguments().optional())
        .map<CstInlineType>({ CstNamedType(it.first.first, it.first.second, it.second) })

    let groupType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(
          punctuationOrEnd(")")
              .or<Maybe<CstNode<PunctuationToken>>>(
                punctuation("]")
                    .or<CstNode<PunctuationToken>>(punctuation("}"))
                    .and()
                    .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() }),
              )
              .cast<Maybe<CstNode<PunctuationToken>>>()
        )
        .map<CstInlineType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let type = it.first.second
          let closingParenthesis = it.second
          CstGroupType(modifiers, openingParenthesis, type, closingParenthesis)
        })

    // TODO(never, JonasWanke): Allow modifiers before struct type fields.
    let structTypeField = atLeastOne<
        CstNode<IdentifierToken>,
        (CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>),
      >(
        identifier(false),
        punctuation(":").sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional()),
      )
      .map<CstStructTypeField>({
        CstStructTypeField(List.empty<CstNode<IdentifierToken>>(), it.first, it.second)
      })
    let structTypeField = node<CstStructTypeField>(structTypeField)
    let structType = modifiers()
        .sequence<CstNode<PunctuationToken>>(punctuation("("))
        .sequence<List<CstNode<CstStructTypeField | PunctuationToken>>>(
          commaSeparated<CstStructTypeField>(structTypeField),
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstInlineType>({
          let modifiers = it.first.first.first
          let openingParenthesis = it.first.first.second
          let fields = it.first.second
          let closingParenthesis = it.second
          CstNamedTupleType(modifiers, openingParenthesis, fields, closingParenthesis)
        })

    let intersectionType = notYetDefined<String, CstInlineType>("Parser not yet defined.")
    let functionType = notYetDefined<String, CstInlineType>("Parser not yet defined.")

    let enumTypeVariantValueType = node<CstInlineType>(
      choiceOf<String, CstInlineType>(
        List.of5<Parser<String, CstInlineType>>(
          intersectionType,
          functionType,
          groupType,
          structType,
          namedType,
        ),
      ),
    )
    // We have to make sure that this doesn't match nothing.
    let enumTypeVariant = modifiers()
      .sequence<(CstNode<IdentifierToken>, Maybe<CstNode<CstInlineType>>)>(
        identifier(true)
          .sequence<Maybe<CstNode<CstInlineType>>>(enumTypeVariantValueType.optional()),
      )
      .map<CstEnumTypeVariant>({
        let modifiers = it.first
        let nameAndValue = Some<(CstNode<IdentifierToken>, Maybe<CstNode<CstInlineType>>)>(it.second)
        CstEnumTypeVariant(modifiers, nameAndValue)
      })
    let enumTypeVariant = node<CstEnumTypeVariant>(enumTypeVariant)
    let enumType = enumTypeVariant.optional()
        .sequence<CstNode<PunctuationToken>>(punctuation("|"))
        .sequence<List<CstNode<CstEnumTypeVariant | PunctuationToken>>>(
          enumTypeVariant
            .or<CstNode<PunctuationToken>>(punctuation("|"))
            .cast<CstNode<CstEnumTypeVariant | PunctuationToken>>()
            .star(),
        )
        .map<CstInlineType>({
          let firstVariant = it.first.first
          let firstBar = it.first.second
          let remaining = it.second

          mut let variants = List.of1<CstNode<CstEnumTypeVariant | PunctuationToken>>(
            (firstBar as CstNode<CstEnumTypeVariant | PunctuationToken>),
          ).followedByList(remaining)
          if (firstVariant is Some<CstNode<CstEnumTypeVariant>>) {
            variants = List.of1<CstNode<CstEnumTypeVariant | PunctuationToken>>(
              (firstVariant.unwrap() as CstNode<CstEnumTypeVariant | PunctuationToken>),
            ).followedByList(variants)
          }
          CstEnumType(variants)
        })

    intersectionType.delegate = node<CstInlineType>(
          choiceOf<String, CstInlineType>(List.of2<Parser<String, CstInlineType>>(namedType, groupType)),
        )
        .sequence<CstNode<PunctuationToken>>(punctuation("&"))
        .sequence<Maybe<CstNode<CstInlineType>>>(
          node<CstInlineType>(
            choiceOf<String, CstInlineType>(
              List.of3<Parser<String, CstInlineType>>(intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstInlineType>({
          let leftType = it.first.first
          let ampersand = it.first.second
          let rightType = it.second
          CstIntersectionType(leftType, ampersand, rightType)
        })

    let functionTypeParameterTypes = punctuation("(")
        .sequence<List<CstNode<CstInlineType | PunctuationToken>>>(commaSeparated<CstInlineType>(inlineType))
        .sequence<Maybe<CstNode<PunctuationToken>>>(closingParenthesisOrOtherEndDetection)
        .map<CstFunctionTypeParameterTypes>({
          CstFunctionTypeParameterTypes(it.first.first, it.first.second, it.second)
        })
    let functionTypeParameterTypes = node<CstFunctionTypeParameterTypes>(functionTypeParameterTypes)
    // TODO(never, JonasWanke): allow modifiers
    let functionTypeReceiverAndParameterTypes = choiceOf<
      String,
      (Maybe<CstNode<CstInlineType>>, Maybe<CstNode<CstFunctionTypeParameterTypes>>),
    >(
      List.of2<
        Parser<
          String,
          (Maybe<CstNode<CstInlineType>>, Maybe<CstNode<CstFunctionTypeParameterTypes>>),
        >,
      >(
        node<CstInlineType>(groupType)
          .map<Maybe<CstNode<CstInlineType>>>({ Some<CstNode<CstInlineType>>(it) })
          .sequence<Maybe<CstNode<CstFunctionTypeParameterTypes>>>(
            functionTypeParameterTypes.map<Maybe<CstNode<CstFunctionTypeParameterTypes>>>({
              Some<CstNode<CstFunctionTypeParameterTypes>>(it)
            })
          ),
        node<CstInlineType>(
          choiceOf<String, CstInlineType>(
            List.of3<Parser<String, CstInlineType>>(enumType, intersectionType, namedType),
          ),
        )
          .optional()
          .sequence<Maybe<CstNode<CstFunctionTypeParameterTypes>>>(
            functionTypeParameterTypes.optional()
          ),
      ),
    )
    functionType.delegate = functionTypeReceiverAndParameterTypes
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .sequence<Maybe<CstNode<CstInlineType>>>(
          node<CstInlineType>(
            choiceOf<String, CstInlineType>(
              List.of4<Parser<String, CstInlineType>>(enumType, intersectionType, groupType, namedType),
            ),
          )
          .optional()
        )
        .map<CstInlineType>({
          let modifiers = List.empty<CstNode<IdentifierToken>>()
          let receiverType = it.first.first.first
          let parameterTypes = it.first.first.second
          let arrow = it.first.second
          let returnType = it.second
          CstFunctionType(modifiers, receiverType, parameterTypes, arrow, returnType)
        })

    inlineType.delegate = node<CstInlineType>(
      choiceOf<String, CstInlineType>(
        List.of6<Parser<String, CstInlineType>>(
          enumType,
          intersectionType,
          functionType,
          groupType,
          structType,
          namedType,
        ),
      ),
    )
  }

  fun typeParameters(): Parser<String, CstNode<CstTypeParameters>> {
    let typeParameters = punctuation("[")
        .sequence<List<CstNode<CstTypeParameter | PunctuationToken>>>(
          commaSeparated<CstTypeParameter>(typeParameter())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("]"))
        .map<CstTypeParameters>({ CstTypeParameters(it.first.first, it.first.second, it.second) })
    node<CstTypeParameters>(typeParameters)
  }
  fun typeParameter(): Parser<String, CstNode<CstTypeParameter>> {
    let typeParameter = modifiers()
        .sequence<(
          Maybe<CstNode<IdentifierToken>>,
          Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>,
        )>(
          atLeastOne<
            CstNode<IdentifierToken>,
            (CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>),
          >(
            identifier(true),
            punctuation(":").sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional()),
          )
        )
        .map<CstTypeParameter>({ CstTypeParameter(it.first, it.second.first, it.second.second) })
    node<CstTypeParameter>(typeParameter)
  }

  fun typeArguments(): Parser<String, CstNode<CstTypeArguments>> {
    let typeArguments = punctuation("[")
        .sequence<List<CstNode<CstTypeArgument | PunctuationToken>>>(
          commaSeparated<CstTypeArgument>(typeArgument())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("]"))
        .map<CstTypeArguments>({ CstTypeArguments(it.first.first, it.first.second, it.second) })
    node<CstTypeArguments>(typeArguments)
  }
  fun typeArgument(): Parser<String, CstNode<CstTypeArgument>> {
    let typeArgument = inlineType.map<CstTypeArgument>({ CstTypeArgument(it) })
    node<CstTypeArgument>(typeArgument)
  }

  // expressions

  let expression_ = notYetDefined<String, CstNode<CstExpression>>("Parser not yet defined.")
  fun initExpression() {
    let intExpression = intLiteral()
        .map<CstExpression>({ CstIntExpression(it) })

    let stringLiteralToken = { parser: Parser<String, Any> =>
      parser.token()
          .map<CstNode<StringLiteralToken>>({
            CstNode<StringLiteralToken>(
              getNextNodeId(),
              StringLiteralToken(
                it.span,
                List.empty<WhitespaceToken | CommentToken>(),
                (it.input as Iterable<String>).join(""),
              ),
            )
          })
    }
    let literalStringPart = choiceOf<String, String>(
      (List.of3<String>("\ü¶Ñ", "\\", "\üëç") as Iterable<String>)
          .map<Parser<String, String>>({ singleCharacter(it, "'{it}' expected.") })
          .toList()
    )
        .negated("Expected a valid char inside a string literal.")
        .plus()
    let literalStringPart = stringLiteralToken(literalStringPart as Parser<String, Any>)
        .map<StringPart>({ CstLiteralStringPart(it) })
    let escapedStringPart = rawPunctuation("\\")
        .sequence<Maybe<CstNode<StringLiteralToken>>>(
          choiceOf<String, Maybe<CstNode<StringLiteralToken>>>(
            List.of2<Parser<String, Maybe<CstNode<StringLiteralToken>>>>(
              stringLiteralToken(any<String>("Any character expected.") as Parser<String, Any>)
                  .map<Maybe<CstNode<StringLiteralToken>>>({
                    Some<CstNode<StringLiteralToken>>(it)
                  }),
              endOfInput<String>("End of input expected.")
                  .map<Maybe<CstNode<StringLiteralToken>>>({ None<CstNode<StringLiteralToken>>() }),
            ),
          ),
        )
        .map<StringPart>({
          CstEscapedStringPart(CstNode<PunctuationToken>(getNextNodeId(), it.first), it.second)
        })
    let interpolatedStringPart = punctuation("\üëç")
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(rawPunctuationOrEnd("}"))
        .map<StringPart>({
          CstInterpolatedStringPart(it.first.first, it.first.second, it.second)
        })
    let stringExpression = punctuation("\ü¶Ñ")
        .sequence<List<CstNode<StringPart>>>(
          choiceOf<String, StringPart>(
            List.of3<Parser<String, StringPart>>(
              literalStringPart,
              escapedStringPart,
              interpolatedStringPart,
            ),
          )
              .map<CstNode<StringPart>>({ CstNode<StringPart>(getNextNodeId(), it) })
              .star(),
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("\ü¶Ñ"))
        .map<CstExpression>({
          let openingQuote = it.first.first
          let parts = it.first.second
          let closingQuote = it.second
          CstStringExpression(openingQuote, parts, closingQuote)
        })

    let lambdaExpressionValueParameters = commaSeparated<CstValueParameter>(
      valueParameter()
    )
        .sequence<CstNode<PunctuationToken>>(punctuation("->"))
        .map<CstLambdaExpressionValueParameters>({
          CstLambdaExpressionValueParameters(it.first, it.second)
        })
    let lambdaExpressionValueParameters = node<CstLambdaExpressionValueParameters>(
      lambdaExpressionValueParameters
    )
    let lambdaExpression = punctuation("\üëç")
        .sequence<Maybe<CstNode<CstLambdaExpressionValueParameters>>>(
          lambdaExpressionValueParameters.optional()
        )
        .sequence<List<CstNode<CstExpression>>>(expression_.star())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd("}"))
        .map<CstExpression>({
          let openingCurlyBrace = it.first.first.first
          let valueParameters = it.first.first.second
          let expressions = it.first.second
          let closingCurlyBrace = it.second
          CstLambdaExpression(openingCurlyBrace, valueParameters, expressions, closingCurlyBrace)
        })

    let identifierExpression = choiceOf<String, CstNode<IdentifierToken>>(
      List.of2<Parser<String, CstNode<IdentifierToken>>>(identifier(false), identifier(true)),
    ).map<CstExpression>({ CstIdentifierExpression(it) })

    let groupExpression = punctuation("(")
        .sequence<Maybe<CstNode<CstExpression>>>(expression_.optional())
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstExpression>({
          let openingParenthesis = it.first.first
          let expression = it.first.second
          let closingParenthesis = it.second
          CstGroupExpression(openingParenthesis, expression, closingParenthesis)
        })

    let structExpression = valueParameters().map({ CstStructExpression(it) })

    let propertyExpression = declarationBeginningWithName("let", false)
          .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>>(
            punctuation(":")
                .sequence<Maybe<CstNode<CstInlineType>>>(inlineType.optional())
                .optional()
          )
          .sequence<Maybe<CstNode<CstExpressionBody>>>(expressionBody().optional())
          .map<CstExpression>({
            let modifiers = it.first.first.first.first
            let keyword = it.first.first.first.second
            let name = it.first.first.second
            let type = it.first.second
            let initializer = it.second
            CstPropertyExpression(modifiers, keyword, name, type, initializer)
          })

    let primitiveExpressions = choiceOf<String, CstExpression>(
        List.of7<Parser<String, CstExpression>>(
          propertyExpression,
          intExpression,
          stringExpression,
          lambdaExpression,
          identifierExpression,
          groupExpression,
          structExpression,
        ),
      )


    let navigationPostfix = punctuation(".")
        .sequence<Maybe<CstNode<IdentifierToken>>>(
          choiceOf<String, CstNode<IdentifierToken>>(
            List.of2<Parser<String, CstNode<IdentifierToken>>>(identifier(false), identifier(true)),
          ).optional(),
        )
        .map<(CstNode<CstExpression>) => CstExpression>({
          { receiver: CstNode<CstExpression> =>
            CstNavigationExpression(receiver, it.first, it.second)
          }
        })

    let callPostfix = valueArguments().map<(CstNode<CstExpression>) => CstExpression>({
      { receiver: CstNode<CstExpression> => CstCallExpression(receiver, it) }
    })

    let typeArgumentsPostfix = typeArguments().map<(CstNode<CstExpression>) => CstExpression>({
      { receiver: CstNode<CstExpression> => CstTypeArgumentsExpression(receiver, it) }
    })

    let postfixExpressions = primitiveExpressions
        .sequence<List<(CstNode<CstExpression>) => CstExpression>>(
          choiceOf<String, (CstNode<CstExpression>) => CstExpression>(
            List.of3<Parser<String, (CstNode<CstExpression>) => CstExpression>>(
              navigationPostfix,
              callPostfix,
              typeArgumentsPostfix,
            ),
          ).star()
        )
        .map<CstExpression>({
          let receiver = it.first
          let postfixFactories = (it.second as Iterable<(CstNode<CstExpression>) => CstExpression>)
          postfixFactories.foldLeft<CstNode<CstExpression>>(
            CstNode<CstExpression>(getNextNodeId(), receiver),
            { receiver, postfixFactory =>
              CstNode<CstExpression>(getNextNodeId(), postfixFactory(receiver))
            },
          ).child as CstExpression
        })


    let buildBinaryOperatorsParser = { operators: List<String> =>
      choiceOf<String, CstNode<PunctuationToken>>(
        (operators as Iterable<String>)
            .map<Parser<String, CstNode<PunctuationToken>>>({ punctuation(it) })
            .toList()
      )
    }
    let buildBinaryLeftAssociative = {
        operators: List<String>,
        higherPrecedenceParser: Parser<String, CstExpression> =>
      // TODO(never, JonasWanke): support things like "+1" and "1++1"

      node<CstExpression>(higherPrecedenceParser)
          .sequence<List<(Maybe<CstNode<CstExpression>>) => CstExpression>>(
            buildBinaryOperatorsParser(operators)
                .sequence<Maybe<CstNode<CstExpression>>>(
                  node<CstExpression>(higherPrecedenceParser).optional()
                )
                .map<(Maybe<CstNode<CstExpression>>) => CstExpression>({
                  { leftOperand: Maybe<CstNode<CstExpression>> =>
                    CstBinaryExpression(leftOperand, it.first, it.second)
                  }
                })
                .star()
          )
          .map<CstExpression>({
            let leftOperand = it.first
            let factories = (it.second as Iterable<(Maybe<CstNode<CstExpression>>) => CstExpression>)
            factories.foldLeft<CstNode<CstExpression>>(
              leftOperand,
              { leftOperand, factory =>
                CstNode<CstExpression>(
                  getNextNodeId(),
                  factory(Some<CstNode<CstExpression>>(leftOperand)),
                )
              },
            ).child as CstExpression
          })
    }
    let buildBinaryRightAssociative = {
        operators: List<String>,
        higherPrecedenceParser: Parser<String, CstExpression> =>
      // TODO(never, JonasWanke): support things like "+1" and "1++1"
      let parser = notYetDefined<String, CstExpression>("Parser not yet defined.")

      parser.delegate = higherPrecedenceParser
          .sequence<Maybe<(CstNode<PunctuationToken>, Maybe<CstNode<CstExpression>>)>>(
            buildBinaryOperatorsParser(operators)
                .sequence<Maybe<CstNode<CstExpression>>>(
                  node<CstExpression>(
                    choiceOf<String, CstExpression>(
                      List.of2<Parser<String, CstExpression>>(higherPrecedenceParser, parser),
                    ),
                  ).optional()
                )
                .optional()
          )
          .map<CstExpression>({
            let leftOperand = it.first
            let operatorAndRightOperand = it.second
            if operatorAndRightOperand is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstExpression>>)> {
              return leftOperand
            }

            let leftOperand = Some<CstNode<CstExpression>>(
              CstNode<CstExpression>(getNextNodeId(), leftOperand),
            )
            let operatorAndRightOperand = operatorAndRightOperand.unwrap()

            CstBinaryExpression(leftOperand, operatorAndRightOperand.first, operatorAndRightOperand.second)
          })
    }

    let multiplicativeExpressions = buildBinaryLeftAssociative(
      List.of4<String>("*", "/", "~/", "%"),
      postfixExpressions,
    )
    let additiveExpressions = buildBinaryLeftAssociative(
      List.of2<String>("+", "-"),
      multiplicativeExpressions,
    )
    let comparisonExpressions = buildBinaryLeftAssociative(
      List.of4<String>("<=", "<", ">=", ">"),
      additiveExpressions,
    )
    let equalityExpressions = buildBinaryLeftAssociative(
      List.of2<String>("==", "!="),
      comparisonExpressions,
    )
    let logicalAndExpressions = buildBinaryLeftAssociative(
      List.of1<String>("&"),
      equalityExpressions,
    )
    let logicalOrExpressions = buildBinaryLeftAssociative(
      List.of1<String>("|"),
      logicalAndExpressions,
    )
    let logicalImplicationExpressions = buildBinaryLeftAssociative(
      List.of1<String>("=>"),
      logicalOrExpressions,
    )
    let assignmentExpressions = buildBinaryRightAssociative(
      List.of1<String>("="),
      logicalImplicationExpressions,
    )
 
    let returnExpressions = choiceOf<String, CstExpression>(
      List.of2<Parser<String, CstExpression>>(
        keyword("return")
            .plus()
            .sequence<Maybe<CstNode<CstExpression>>>(
              node<CstExpression>(logicalImplicationExpressions).optional(),
            )
            .map<CstExpression>({
              let returnTokens = (it.first as Iterable<CstNode<KeywordToken>>)
              let expression = it.second
              returnTokens.foldRight<Maybe<CstNode<CstExpression>>>(
                expression,
                { returnKeyword, expression =>
                  Some<CstNode<CstExpression>>(
                    CstNode<CstExpression>(
                      getNextNodeId(),
                      CstReturnExpression(returnKeyword, expression),
                    ),
                  )
                },
              ).unwrap().child as CstExpression
            }),
        logicalImplicationExpressions,
      ),
    )

    expression_.delegate = node<CstExpression>(returnExpressions)
  }

  fun valueArguments(): Parser<String, CstNode<CstValueArguments>> {
    let valueArguments = punctuation("(")
        .sequence<List<CstNode<CstValueArgument | PunctuationToken>>>(
          commaSeparated<CstValueArgument>(valueArgument())
        )
        .sequence<Maybe<CstNode<PunctuationToken>>>(punctuationOrEnd(")"))
        .map<CstValueArguments>({ CstValueArguments(it.first.first, it.first.second, it.second) })
    node<CstValueArguments>(valueArguments)
  }
  fun valueArgument(): Parser<String, CstNode<CstValueArgument>> {
    let valueArgument = atLeastOne<
      (Maybe<CstNode<IdentifierToken>>, CstNode<PunctuationToken>),
      CstNode<CstExpression>,
    >(
      identifier(false)
          .optional()
          .sequence<CstNode<PunctuationToken>>(punctuation("=")),
      expression_,
    ).map<CstValueArgument>({ CstValueArgument(it.first, it.second) })
    node<CstValueArgument>(valueArgument)
  }

  // utilities

  fun modifiers(): Parser<String, List<CstNode<IdentifierToken>>> { identifier(false).star() }

  fun node<T>(parser: Parser<String, T>): Parser<String, CstNode<T>> {
    parser.map<CstNode<T>>({ CstNode<T>(getNextNodeId(), it) })
  }
  fun getNextNodeId(): CstNodeId {
    let id = CstNodeId(nextId)
    nextId = nextId + 1
    id
  }

  fun atLeastOne<T1, T2>(
    parser1: Parser<String, T1>,
    parser2: Parser<String, T2>,
  ): Parser<String, (Maybe<T1>, Maybe<T2>)> {
    choiceOf<String, (Maybe<T1>, Maybe<T2>)>(
      List.of2<Parser<String, (Maybe<T1>, Maybe<T2>)>>(
        parser1
            .map<Maybe<T1>>({ Some<T1>(it) })
            .sequence<Maybe<T2>>(parser2.optional()),
        parser2.map<(Maybe<T1>, Maybe<T2>)>({ Tuple(None<T1>(), Some<T2>(it)) }),
      ),
    )
  }

  // lexer

  fun keyword(keyword: String): Parser<String, CstNode<KeywordToken>> {
    assert((keywords as Iterable<String>).any({ it == keyword }), "Invalid keyword: {keyword}.")

    let parser = string(keyword, "'{keyword}' expected.")
        .token()
        .sequence<List<WhitespaceToken | CommentToken>>(trivia())
        .map<KeywordToken>({ KeywordToken(it.first.span, it.second, keyword) })
    node<KeywordToken>(parser)
  }
  fun identifier(startWithUppercase: Bool = false): Parser<String, CstNode<IdentifierToken>> {
    let firstCharacter = character(
          {
            (!startWithUppercase && "a" <= it && it <= "z")
            || (startWithUppercase && "A" <= it && it <= "Z")
          },
          "Letter or underscore expected.",
        )
    let followingCharacter = character(
          {
            "a" <= it && it <= "z"
            || "A" <= it && it <= "Z"
            || "0" <= it && it <= "9"
            || it == "_"
          },
          "Letter, digit, or underscore expected.",
        )
    let parser = firstCharacter
        .sequence<List<String>>(followingCharacter.star())
        .token()
        .map<Token<String, String>>({
          let a = it
          Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
        })
        .when({ token =>
          if (keywords as Iterable<String>).any({ it == token.value }) {
            return Error<Unit, String>("Expected an identifier, but got keyword '{token.value}'.")
          }
          Ok<Unit, String>(unit)
        })
        .sequence<List<WhitespaceToken | CommentToken>>(trivia())
        .map<IdentifierToken>({ IdentifierToken(it.first.span, it.second, it.first.value) })
    node<IdentifierToken>(parser)
  }

  fun intLiteral(): Parser<String, CstNode<IntLiteralToken>> {
    let parser = digit("Digit expected.")
        .plus()
        .map<Int>({ Int.parse((it as Iterable<String>).join("")) })
        .token()
        .sequence<List<WhitespaceToken | CommentToken>>(trivia())
        .map<IntLiteralToken>({ IntLiteralToken(it.first.span, it.second, it.first.value as Int) })
    node<IntLiteralToken>(parser)
  }

  fun punctuation(punctuation: String): Parser<String, CstNode<PunctuationToken>> {
    let parser = string(punctuation, "'{punctuation}' expected.")
        .token()
        .sequence<List<WhitespaceToken | CommentToken>>(trivia())
        .map<PunctuationToken>({ PunctuationToken(it.first.span, it.second, punctuation) })
        node<PunctuationToken>(parser)
  }
  fun rawPunctuation(punctuation: String): Parser<String, PunctuationToken> {
    /// TODO(never, JonasWanke): detect punctuation separated by whitespace, e.g., "> =" as ">="

    string(punctuation, "'{punctuation}' expected.")
        .token()
        .map<PunctuationToken>({
          PunctuationToken(
            it.span,
            List.empty<WhitespaceToken | CommentToken>(),
            punctuation,
          )
        })
  }
  fun punctuationOrEnd(
    punctuationString: String,
  ): Parser<String, Maybe<CstNode<PunctuationToken>>> {
    punctuation(punctuationString)
        .map<Maybe<CstNode<PunctuationToken>>>({ Some<CstNode<PunctuationToken>>(it) })
        .or<Maybe<CstNode<PunctuationToken>>>(
          endOfInput<String>("End of input expected.")
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .cast<Maybe<CstNode<PunctuationToken>>>()
  }
  fun rawPunctuationOrEnd(
    punctuationString: String,
  ): Parser<String, Maybe<CstNode<PunctuationToken>>> {
    rawPunctuation(punctuationString)
        .map<Maybe<CstNode<PunctuationToken>>>({
          Some<CstNode<PunctuationToken>>(CstNode<PunctuationToken>(getNextNodeId(), it))
        })
        .or<Maybe<CstNode<PunctuationToken>>>(
          endOfInput<String>("End of input expected.")
              .map<Maybe<CstNode<PunctuationToken>>>({ None<CstNode<PunctuationToken>>() })
        )
        .cast<Maybe<CstNode<PunctuationToken>>>()
  }
  fun commaSeparated<Output>(
    parser: Parser<String, CstNode<Output>>,
  ): Parser<String, List<CstNode<Output | PunctuationToken>>> {
    parser
        .or<CstNode<PunctuationToken>>(punctuation(","))
        .cast<CstNode<Output | PunctuationToken>>()
        .star()
  }

  fun trivia(): Parser<String, List<WhitespaceToken | CommentToken>> {
    whitespace().or<CommentToken>(comment()).star()
  }
  fun whitespace(): Parser<String, WhitespaceToken> {
    character(
      { it == " " || it == "\t" || it == "\r" || it == "\n" || it == "\r\n" },
      "Whitespace expected.",
    )
        .plus()
        .token()
        .map<Token<String, String>>({
          Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
        })
        .map<WhitespaceToken>({ WhitespaceToken(it.span, it.value) })
  }
  fun comment(): Parser<String, CommentToken> {
    let lineCommentFromStart = { start: Parser<String, String> =>
      start
          .sequence<String>(
            lineBreak()
                .negated("Expected something different from the receiver.")
                .star()
                .token()
                .map<String>({ (it.input as Iterable<String>).join("") })
          )
          .map<String>({ it.second })
          .token()
          .sequence<Unit>(
            lineBreak()
                .or<Unit>(endOfInput<String>("End of input expected."))
                .map<Unit>({ unit })
                .and()
          )
          .map<(Span, String)>({ Tuple(it.first.span, it.first.value as String) })
    }
    let docComment = lineCommentFromStart(string("#", "'#' expected."))
        .map<CommentToken>({ CommentToken(it.first, it.second, "doc") })
    let lineComment = lineCommentFromStart(string("##", "'##' expected."))
        .map<CommentToken>({ CommentToken(it.first, it.second, "line") })

    let blockComment = notYetDefined<String, CommentToken>("Parser not yet defined.")
    blockComment.delegate = string("/*", "'/*' expected.")
        .sequence<Token<String, String>>(
          blockComment
              .or<String>(string("*/", "'*/' expected.").negated("Expected something different from the receiver."))
              .star()
              .token()
              .map<Token<String, String>>({
                Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
              })
        )
        .sequence<Unit>(
          string("*/", "'*/' expected.")
              .or<Unit>(endOfInput<String>("End of input expected."))
              .map<Unit>({ unit })
        )
        .map<CommentToken>({
          let token = it.first.second
          CommentToken(token.span, token.value, "block")
        })

    choiceOf<String, CommentToken>(
      List.of3<Parser<String, CommentToken>>(lineComment, docComment, blockComment),
    )
  }
  fun lineBreak(): Parser<String, Token<String, String>> {
    let lineFeed = singleCharacter("\n", "'\\n' expected.")
    // Carriage return followed by a line feed is a single grapheme cluster.
    let both = singleCharacter("\r\n", "'\\r\\n' expected.")
    let carriageReturn = singleCharacter("\r", "'\\r' expected.")
    choiceOf<String, String>(List.of3<Parser<String, String>>(lineFeed, both, carriageReturn))
      .token()
      .map<Token<String, String>>({
        Token<String, String>((it.input as Iterable<String>).join(""), it.span, it.input as List<String>)
      })
  }
}
let keywords = List.of9<String>(
  "use", "crate",
  "module", "trait", "impl", "type",
  "fun", "let",
  "return",
)
