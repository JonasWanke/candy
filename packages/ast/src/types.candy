use ..declarations
use ..expressions
use ..file
use ..node

public class AstInlineTypeId {
  let parentId: AstDeclarationId
      | AstInlineTypeId
      | AstTypeParameterId
      | AstTypeArgumentId
      | AstValueParameterId
      | AstExpressionId
  let value: Int
}
impl AstInlineTypeId: AstNodeId & Equals & Hash {
  fun equals(other: AstInlineTypeId): Bool { parentId == other.parentId && value == other.value }
  fun hash<T>(hasher: Hasher<T>) {
    parentId.hash<T>(hasher)
    value.hash<T>(hasher)
  }
}

public trait /* enum */ AstInlineType {
  let modifiers: List<AstIdentifier>
}
impl AstInlineType: AstNode & Equals & Hash


public class AstNamedType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let nameParts: List<AstIdentifier>
  public let typeArguments: List<AstTypeArgument>
}
impl AstNamedType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      (nameParts as Iterable<AstIdentifier>)
        .unsafeEquals(other.nameParts as Iterable<AstIdentifier>) &&
      (typeArguments as Iterable<AstTypeArgument>)
        .unsafeEquals(other.typeArguments as Iterable<AstTypeArgument>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    nameParts.unsafeHash<T>(hasher)
    typeArguments.unsafeHash<T>(hasher)
  }
}


public class AstFunctionType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let receiverType: Maybe<AstInlineType>
  public let parameterTypes: List<AstInlineType>
  public let returnType: AstInlineType
}
impl AstFunctionType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      receiverType.unsafeEquals(other.receiverType) &&
      (parameterTypes as Iterable<AstIdentifier>)
        .unsafeEquals(other.parameterTypes as Iterable<AstIdentifier>) &&
      returnType  == other.returnType
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    receiverType.unsafeHash<T>(hasher)
    parameterTypes.unsafeHash<T>(hasher)
    returnType.hash<T>(hasher)
  }
}


public class AstTupleType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstInlineType>
}
impl AstTupleType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      (types as Iterable<AstInlineType>).unsafeEquals(other.types as Iterable<AstInlineType>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    types.unsafeHash<T>(hasher)
  }
}


public class AstNamedTupleType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstNamedTupleTypeField>
}
impl AstNamedTupleType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      (types as Iterable<AstNamedTupleTypeField>)
        .unsafeEquals(other.types as Iterable<AstNamedTupleTypeField>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    types.unsafeHash<T>(hasher)
  }
}

public class AstNamedTupleTypeField {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let name: AstIdentifier
  public let type: AstInlineType
}
impl AstNamedTupleTypeField: Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      name.equals(other.name) &&
      type  == other.type
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    name.hash<T>(hasher)
    type.hash<T>(hasher)
  }
}


public class AstEnumType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let variants: List<AstEnumTypeVariant>
}
impl AstEnumType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      (variants as Iterable<AstEnumTypeVariant>)
        .unsafeEquals(other.variants as Iterable<AstEnumTypeVariant>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    variants.unsafeHash<T>(hasher)
  }
}

public class AstEnumTypeVariant {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let name: AstIdentifier
  public let valueType: Maybe<AstInlineType>
}
impl AstEnumTypeVariant: Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      name  == other.name &&
      valueType.unsafeEquals(other.valueType)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    name.hash<T>(hasher)
    valueTypes.unsafeHash<T>(hasher)
  }
}


public class AstIntersectionType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstInlineType>
}
impl AstIntersectionType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      (types as Iterable<AstIdentifier>).unsafeEquals(other.types as Iterable<AstIdentifier>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    types.unsafeHash<T>(hasher)
  }
}


public class AstErrorType {
  public let id: AstInlineTypeId
  public let modifiers: List<AstIdentifier> = List.empty<AstIdentifier>()
}
impl AstErrorType: AstInlineType & Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
  }
}


public class AstTypeParameterId {
  let parentId: AstDeclarationId
  let name: String
}
impl AstTypeParameterId: AstNodeId & Equals & Hash {
  fun equals(other: AstNamedType): Bool { parentId == other.parentId && name  == other.name }
  fun hash<T>(hasher: Hasher<T>) {
    parentId.hash<T>(hasher)
    name.hash<T>(hasher)
  }
}

public class AstTypeParameter {
  public let id: AstTypeParameterId
  public let modifiers: List<AstIdentifier>
  public let name: AstIdentifier
  public let upperBound: Maybe<AstInlineType>
}
impl AstTypeParameter: Equals & Hash {
  fun equals(other: AstNamedType): Bool {
    id == other.id &&
      (modifiers as Iterable<AstIdentifier>)
        .unsafeEquals(other.modifiers as Iterable<AstIdentifier>) &&
      name == other.name &&
      upperBound.unsafeEquals(other.upperBound)
  }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    modifiers.unsafeHash<T>(hasher)
    name.hash<T>(hasher)
    upperBound.hash<T>(hasher)
  }
}


public class AstTypeArgumentId {
  let parentId: AstInlineTypeId | AstExpressionId
  let index: Int
}
impl AstTypeArgumentId: AstNodeId & Equals & Hash {
  fun equals(other: AstNamedType): Bool { parentId == other.parentId && index == other.index }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    index.hash<T>(hasher)
  }
}

public class AstTypeArgument {
  public let id: AstTypeArgumentId
  public let type: AstInlineType
}
impl AstTypeArgument: Equals & Hash {
  fun equals(other: AstNamedType): Bool { id == other.id && type  == other.type }
  fun hash<T>(hasher: Hasher<T>) {
    id.hash<T>(hasher)
    type.hash<T>(hasher)
  }
}
