use ..declarations
use ..expressions
use ..file
use ..node

public class AstTypeId {
  let parentId: AstDeclarationId
      | AstTypeId
      | AstTypeParameterId
      | AstTypeArgumentId
      | AstValueParameterId
      | AstExpressionId
  let value: Int
}
impl AstTypeId: AstNodeId

public trait /* enum */ AstType {
  let modifiers: List<AstIdentifier>
}
impl AstType: AstNode


public class AstNamedType {
  public let id: AstTypeId
  public let modifiers: List<AstIdentifier>
  public let nameParts: List<AstIdentifier>
  public let typeArguments: List<AstTypeArgument>
}
impl AstNamedType: AstType


public class AstFunctionType {
  public let id: AstTypeId
  public let modifiers: List<AstIdentifier>
  public let receiverType: Maybe<AstType>
  public let parameterTypes: List<AstType>
  public let returnType: Maybe<AstType>
}
impl AstFunctionType: AstType


public class AstTupleType {
  public let id: AstTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstType>
}
impl AstTupleType: AstType


public class AstUnionType {
  public let id: AstTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstType>
}
impl AstUnionType: AstType

public class AstIntersectionType {
  public let id: AstTypeId
  public let modifiers: List<AstIdentifier>
  public let types: List<AstType>
}
impl AstIntersectionType: AstType


public class AstTypeParameterId {
  let parentId: AstDeclarationId
  let name: String
}
impl AstTypeParameterId: AstNodeId

public class AstTypeParameter {
  public let id: AstTypeParameterId
  public let modifiers: List<AstIdentifier>
  public let name: AstIdentifier
  public let upperBound: Maybe<AstType>
}


public class AstTypeArgumentId {
  let parentId: AstTypeId | AstExpressionId
  let index: Int
}
impl AstTypeArgumentId: AstNodeId

public class AstTypeArgument {
  public let id: AstTypeArgumentId
  public let type: Maybe<AstType>
}
