use compiler_utils
use cst
use incremental
use petit_parser
use ..comment
use ..declarations
use ..errors
use ..expressions
use ..file
use ..node
use ..types

public fun parseAstOfFile(context: QueryContext<List<CompilerError>>, file: FancyFile): (AstFile, Map<CstNodeId, AstNodeId>) {
  query<(AstFile, Map<CstNodeId, AstNodeId>), List<CompilerError>>(context, "parseAstOfFile", (file as Equals & Hash), {
    let result = lowerCstToAst(file, parseCstOfFile(context, file))
    Tuple(Tuple(result.first, result.second), result.third)
  })
}

public fun lowerCstToAst(
  file: FancyFile,
  cst: CstNode<CstFile>,
): (AstFile, Map<CstNodeId, AstNodeId>, List<CompilerError>) {
  let context = LoweringContext.create(file)
  let ast = lowerFile(context, cst)
  let trackingResult = context.getResult()
  Tuple(ast, trackingResult.first, trackingResult.second)
}

// file

fun lowerFile(context: LoweringContext, cst: CstNode<CstFile>): AstFile {
  let id = AstFileId(context.file)

  mut let sawDeclaration = false
  let useLines = MutableList.empty<AstUseLine>()
  let declarations = MutableList.empty<AstModule | AstTrait | AstImpl | AstType | AstFunction>()
  let previousNames = MutableSet.empty<String>()
  for node in cst.child.content {
    if node.child is CstUseLine {
      if sawDeclaration {
        context.addError(
          UseLineAfterDeclarationCompilerError(context.file, node.cast<CstUseLine>()),
        )
      }

      let result = lowerUseLine(
        context,
        id,
        node.cast<CstUseLine>(),
        (useLines as Iterable<AstUseLine>).length(),
      )
      if result is Some<AstUseLine> {
        useLines.append(result.unwrap())
      }
    } else {
      sawDeclaration = true
      let result = lowerDeclaration(
        context,
        id,
        node.cast<CstDeclaration>(),
        previousNames as Set<String>,
      )
      result.do({
        declarations.append(it as AstModule | AstTrait | AstImpl | AstType | AstFunction)
      })
    }
  }

  context.addIdMapping(cst.id, id)
  AstFile(id, useLines, declarations)
}

fun lowerUseLine(
  context: LoweringContext,
  fileId: AstFileId,
  cst: CstNode<CstUseLine>,
  useLineIndex: Int,
): Maybe<AstUseLine> {
  let id = AstUseLineId(fileId, useLineIndex)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)
  let target = cst.child.target
      .map<AstUseLineTarget>({
        if it.child is CstLocalRelativeUseLineTarget {
          lowerLocalRelativeUseLineTarget(context, id, it.cast<CstLocalRelativeUseLineTarget>())
        } else {
          lowerGlobalUseLineTarget(context, id, it.cast<CstGlobalUseLineTarget>())
        }
      })

  if target is None<AstUseLineTarget> { return None<AstUseLine>() }

  context.addIdMapping(cst.id, id)
  Some<AstUseLine>(AstUseLine(id, modifiers, target.unwrap()))
}
fun lowerLocalRelativeUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstLocalRelativeUseLineTarget>,
): AstLocalRelativeUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let parentNavigationsIterable = cst.child.parentNavigations as Iterable<CstNode<PunctuationToken>>
  assert(parentNavigationsIterable.isNotEmpty(), "Parent navigations may not be empty.")
  let parentNavigations = parentNavigationsIterable.length() - 1

  let path = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.path {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      }
      path.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (path as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  context.addIdMapping(cst.id, id)
  AstLocalRelativeUseLineTarget(id, parentNavigations, path)
}
fun lowerGlobalUseLineTarget(
  context: LoweringContext,
  useLineId: AstUseLineId,
  cst: CstNode<CstGlobalUseLineTarget>,
): AstGlobalUseLineTarget {
  let id = AstUseLineTargetId(useLineId)

  let packagePath = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.packagePath {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        /// TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        /// TODO(JonasWanke)
      }
      packagePath.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (packagePath as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let moduleName = None<AstIdentifier>()

  context.addIdMapping(cst.id, id)
  AstGlobalUseLineTarget(id, packagePath, moduleName)
}

fun lowerModifiers(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstInlineTypeId | AstExpressionId,
  modifiers: List<CstNode<IdentifierToken>>,
): List<AstIdentifier> {
  mut let index = 0
  mut let result = MutableList.empty<AstIdentifier>()
  for modifier in modifiers {
    result.append(lowerModifier(context, parentId, modifier, index))
    index = index + 1
  }
  result
}
fun lowerModifier(
  context: LoweringContext,
  parentId: AstUseLineId | AstDeclarationId | AstTypeParameterId | AstValueParameterId | AstInlineTypeId | AstExpressionId,
  cst: CstNode<IdentifierToken>,
  index: Int,
): AstIdentifier { lowerIdentifier(context, parentId, cst, index) }

fun lowerIdentifier(
  context: LoweringContext,
  parentId: AstUseLineId
    | AstUseLineTargetId
    | AstDeclarationId
    | AstTypeParameterId
    | AstValueParameterId
    | AstInlineTypeId
    | AstExpressionId,
  cst: CstNode<IdentifierToken>,
  index: Int,
): AstIdentifier {
  let id = AstIdentifierId(parentId, index)
  context.addIdMapping(cst.id, id)
  AstIdentifier(id, cst.child.identifier)
}

// declarations

fun lowerDeclaration(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstDeclaration>,
  previousNames: Set<String>,
): Maybe<AstDeclaration> {
  if cst.child is CstModule {
    return lowerModule(context, parentId, cst.cast<CstModule>(), previousNames)
  }
  if cst.child is CstTrait {
    return lowerTrait(context, parentId, cst.cast<CstTrait>(), previousNames)
  }
  if cst.child is CstImpl {
    return lowerImpl(context, parentId, cst.cast<CstImpl>())
  }
  if cst.child is CstType {
    return lowerType(context, parentId, cst.cast<CstType>(), previousNames)
  }
  if cst.child is CstFunction {
    return lowerFunction(context, parentId, cst.cast<CstFunction>())
  }
  throw "Unknown declaration: {cst}."
}
fun lowerModule(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstModule>,
  previousNames: Set<String>,
): Maybe<AstModule> {
 let id = AstDeclarationId(
    parentId,
    cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-module-{context.getUnnamedDeclarationIndex()}" })
  )
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
    isValid = false
  } else {
    if previousNames.contains(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstType>(),
        ),
      )
    }
  }

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, true, true) as List<AstModule | AstTrait | AstImpl | AstType | AstFunction>

  if !isValid { return None<AstModule>() }
  context.addIdMapping(cst.id, id)
  Some<AstModule>(AstModule(id, None<AstCandyDoc>(), modifiers, name.unwrap(), innerDeclarations))
}
fun lowerTrait(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstTrait>,
  previousNames: Set<String>,
): Maybe<AstTrait> {
  let id = AstDeclarationId(
    parentId,
    cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-trait-{context.getUnnamedDeclarationIndex()}" })
  )
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
    isValid = false
  } else {
    if previousNames.contains(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstType>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let upperBound = cst.child.upperBound
      .flatMap<AstInlineType>({
        if it.second is None<CstNode<CstInlineType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
            ),
          )
          None<AstInlineType>()
        } else {
          lowerInlineType(context, id, it.second.unwrap())
        }
      })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, true) as List<AstTrait | AstType | AstFunction>

  if !isValid { return None<AstTrait>() }
  context.addIdMapping(cst.id, id)
  Some<AstTrait>(
    AstTrait(
      id,
      None<AstCandyDoc>(),
      modifiers,
      name.unwrap(),
      typeParameters,
      upperBound,
      innerDeclarations,
    ),
  )
}
fun lowerImpl(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstImpl>,
): Maybe<AstImpl> {
  let id = AstDeclarationId(parentId, "impl-{context.getUnnamedDeclarationIndex()}")

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  if cst.child.type is None<AstInlineType> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
      ),
    )
  }
  let type = cst.child.type.flatMap<AstInlineType>({ lowerInlineType(context, id, it) })

  let traits = cst.child.traits
      .flatMap<AstInlineType>({
        if it.second is None<CstNode<CstInlineType>> {
          context.addError(
            ExpectedTypeCompilerError(
              context.file,
              cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
            ),
          )
          None<AstInlineType>()
        } else {
          lowerInlineType(context, id, it.second.unwrap())
        }
      })
      .map<List<AstNamedType>>({
        if it is AstNamedType { return List.of1<AstNamedType>(it as AstNamedType) }
        if it is AstIntersectionType {
          let types = (it as AstIntersectionType).types
          if (types as Iterable<AstInlineType>).any({ !(it is AstNamedType) }) {
            context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
            return List.empty<AstNamedType>()
          }
          return (types as Iterable<AstInlineType>).cast<AstNamedType>().toList()
        }
        context.addError(InvalidImplementedTraitsCompilerError(context.file, cst))
        return List.empty<AstNamedType>()
      })
      .orElse({ List.empty<AstNamedType>() })

  let innerDeclarations = lowerDeclarationContent(context, id, cst.child.content, false, false) as List<AstFunction>

  if type is None<AstInlineType> { return None<AstImpl>() }
  context.addIdMapping(cst.id, id)
  Some<AstImpl>(AstImpl(id, modifiers, typeParameters, type.unwrap(), traits, innerDeclarations))
}
fun lowerType(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstType>,
  previousNames: Set<String>,
): Maybe<AstType> {
  let id = AstDeclarationId(
    parentId,
    cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-type-{context.getUnnamedDeclarationIndex()}" })
  )
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
    isValid = false
  } else {
    if previousNames.contains(name.unwrap().value) {
      context.addError(
        DuplicateDeclarationNameCompilerError(
          context.file,
          cst.cast<CstModule | CstTrait | CstType>(),
        ),
      )
    }
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let type = cst.child.type.flatMap<AstInlineType>({
    if (it.second is None<CstNode<CstInlineType>>) {
      context.addError(ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
      ))
      isValid = false
      return None<AstInlineType>()
    }
    lowerInlineType(context, id, it.second.unwrap())
  })
  if (type is None<AstInlineType>) { isValid = false }

  if !isValid { return None<AstType>() }
  context.addIdMapping(cst.id, id)
  Some<AstType>(
    AstType(id, None<AstCandyDoc>(), modifiers, name.unwrap(), typeParameters, type.unwrap()),
  )
}
fun lowerFunction(
  context: LoweringContext,
  parentId: AstFileId | AstDeclarationId | AstExpressionId,
  cst: CstNode<CstFunction>,
): Maybe<AstFunction> {
  let id = AstDeclarationId(
    parentId,
    cst.child.name
      .map<String>({ "{it.child.identifier}-{context.getUnnamedDeclarationIndex()}" })
      .orElse({ "unnamed-function-{context.getUnnamedDeclarationIndex()}" })
  )
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingDeclarationNameCompilerError(context.file, cst.cast<CstDeclaration>()))
    isValid = false
  }

  let typeParameters = cst.child.typeParameters
      .map<List<AstTypeParameter>>({ lowerTypeParameters(context, id, it) })
      .orElse({ List.empty<AstTypeParameter>() })

  let valueParameters = cst.child.valueParameters
      .map<List<AstValueParameter>>({ lowerValueParameters(context, id, it) })
      .orElse({
        context.addError(MissingValueParametersCompilerError(context.file, cst))
        List.empty<AstValueParameter>()
      })

  let returnType = if cst.child.returnType is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)> {
    context.addError(ExpectedFunctionReturnTypeCompilerError(context.file, cst))
    None<AstType>()
  } else {
    let returnType = cst.child.returnType.unwrap()
    if returnType.second is None<CstNode<CstInlineType>> {
      context.addError(ExpectedFunctionReturnTypeCompilerError(context.file, cst))
      None<AstType>()
    } else {
      lowerInlineType(context, id, returnType.second.unwrap())
    }
  }

  let body = if cst.child.body is None<CstNode<CstBlockBody | CstExpressionBody>> {
    None<AstBlockBody | AstExpressionBody | AstDelegationBody>()
  } else {
    let body = cst.child.body.unwrap()
    if body.child is CstBlockBody {
      Some<AstBlockBody | AstExpressionBody | AstDelegationBody>(
        lowerBlockBody(context, id, body.cast<CstBlockBody>()),
      )
    } else {
      Some<AstBlockBody | AstExpressionBody | AstDelegationBody>(
        lowerExpressionBody(context, id, body.cast<CstExpressionBody>()),
      )
    }
  }

  if !isValid { return None<AstFunction>() }
  context.addIdMapping(cst.id, id)
  Some<AstFunction>(
    AstFunction(
      id,
      None<AstCandyDoc>(),
      modifiers,
      name.unwrap(),
      typeParameters,
      valueParameters,
      returnType,
      body,
    ),
  )
}

fun lowerDeclarationContent(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: Maybe<CstNode<CstDeclarationContent>>,
  allowModulesAndImpls: Bool,
  allowTraitsAndTypes: Bool,
): List<AstDeclaration> {
  if cst is None<CstNode<CstDeclarationContent>> { return List.empty<AstDeclaration>() }
  let cst = cst.unwrap()

  let result = MutableList.empty<AstDeclaration>()
  let previousNames = MutableSet.empty<String>()
  for node in cst.child.innerDeclarations {
    let loweredRaw = lowerDeclaration(context, parentId, node, previousNames as Set<String>)
    if loweredRaw is None<AstDeclaration> { continue }
    let lowered = loweredRaw.unwrap()

    mut let isValid = true
    if lowered is AstModule {
      previousNames.insert((lowered as AstModule).name.value)
      if !allowModulesAndImpls { isValid = false }
    }
    if lowered is AstTrait {
      previousNames.insert((lowered as AstTrait).name.value)
      if !allowTraitsAndTypes { isValid = false }
    }
    if lowered is AstImpl && !allowModulesAndImpls { isValid = false }
    if lowered is AstType {
      previousNames.insert((lowered as AstType).name.value)
      if !allowTraitsAndTypes { isValid = false }
    }
    if lowered is AstFunction {
      previousNames.insert((lowered as AstFunction).name.value)
    }
    if isValid {
      result.append(lowered)
    } else {
      context.addError(
        InvalidDeclarationTypeCompilerError(context.file, cst.cast<CstDeclaration>()),
      )
    }
  }

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerBlockBody(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstBlockBody>,
): AstBlockBody {
  let id = AstBodyId(parentId)

  let expressions = (cst.child.expressions as Iterable<CstNode<CstExpression>>)
      .map<Maybe<AstExpression>>({ lowerExpression(context, parentId, it) })
      .maybeMap<AstExpression>({ it })
      .toList()

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  AstBlockBody(id, expressions)
}
fun lowerExpressionBody(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstExpressionBody>,
): AstExpressionBody {
  let id = AstBodyId(parentId)

  let expression = cst.child.expression
    .flatMap<AstExpression>({ lowerExpression(context, parentId, it) })
  if cst.child.expression is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
      ),
    )
  }

  context.addIdMapping(cst.id, id)
  AstExpressionBody(id, expression)
}

fun lowerValueParameters(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameters>,
): List<AstValueParameter> {
  let result = lowerValueParameterList(context, parentId, cst.child.valueParameters)

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerValueParameterList(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  csts: List<CstNode<CstValueParameter | PunctuationToken>>,
): List<AstValueParameter> {
  let result = MutableList.empty<AstValueParameter>()
  let previousNames = MutableSet.empty<String>()
  mut let punctuationExpectedNext = false
  for node in csts {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let lowered = lowerValueParameter(
        context,
        parentId,
        node.cast<CstValueParameter>(),
        previousNames as Set<String>,
      )
      if lowered is Some<AstValueParameter> {
        let valueParameter = lowered.unwrap()
        result.append(valueParameter)
        previousNames.insert(valueParameter.name.value)
      }
      punctuationExpectedNext = true
    }
  }

  result
}
fun lowerValueParameter(
  context: LoweringContext,
  parentId: AstDeclarationId | AstExpressionId,
  cst: CstNode<CstValueParameter>,
  previousNames: Set<String>,
): Maybe<AstValueParameter> {
  let name = cst.child.name.child.identifier
  if previousNames.contains(name) {
    context.addError(DuplicateValueParameterNameCompilerError(context.file, cst))
    return None<AstValueParameter>()
  }

  let id = AstValueParameterId(parentId, name)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = lowerIdentifier(context, id, cst.child.name, 0)

  // Value parameters only occur in functions and lambdas, which we can differentiate using
  // `parentId`.
  let isFunctionParameter = (parentId is AstDeclarationId)
  let type = if isFunctionParameter {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)> {
      context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstInlineType>> {
        context.addError(FunctionValueParameterTypeMissingCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerInlineType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  } else {
    if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)> {
      None<AstType>()
    } else {
      if cst.child.type.unwrap().second is None<CstNode<CstInlineType>> {
        context.addError(LambdaValueParameterTypeExpectedCompilerError(context.file, cst))
        None<AstType>()
      } else {
        lowerInlineType(context, id, cst.child.type.unwrap().second.unwrap())
      }
    }
  }

  let defaultValue = cst.child.defaultValue
      .flatMap<AstExpression>({
        if it.child.expression is None<CstNode<CstExpression>> {
          context.addError(
            ExpectedExpressionCompilerError(
              context.file,
              it.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
            ),
          )
          None<AstExpression>()
        } else {
          lowerExpression(context, id, it.child.expression.unwrap())
        }
      })

  context.addIdMapping(cst.id, id)
  Some<AstValueParameter>(AstValueParameter(id, modifiers, name, type, defaultValue))
}

// types

fun lowerInlineType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstInlineType>,
): Maybe<AstInlineType> {
  if cst.child is CstNamedType {
    return Some<AstInlineType>(lowerNamedType(context, parentId, cst.cast<CstNamedType>()))
  }
  if cst.child is CstGroupType {
    return lowerGroupType(context, parentId, cst.cast<CstGroupType>())
  }
  if cst.child is CstFunctionType {
    return lowerFunctionType(context, parentId, cst.cast<CstFunctionType>())
  }
  if cst.child is CstTupleType {
    return lowerTupleType(context, parentId, cst.cast<CstTupleType>())
  }
  if cst.child is CstNamedTupleType {
    return lowerNamedTupleType(context, parentId, cst.cast<CstNamedTupleType>())
  }
  if cst.child is CstEnumType {
    return lowerEnumType(context, parentId, cst.cast<CstEnumType>())
  }
  if cst.child is CstIntersectionType {
    return Some<AstInlineType>(lowerIntersectionType(context, parentId, cst.cast<CstIntersectionType>()))
  }
  throw "Unknown expression: {cst}."
}
fun lowerNamedType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstNamedType>,
): AstNamedType {
  let id = context.getInlineTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let nameParts = MutableList.empty<AstIdentifier>()
  mut let punctuationExpectedNext = false
  for node in cst.child.nameParts {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      nameParts.append(
        lowerIdentifier(
          context,
          id,
          node.cast<IdentifierToken>(),
          (nameParts as Iterable<AstIdentifier>).length(),
        )
      )
      punctuationExpectedNext = true
    }
  }
  if !punctuationExpectedNext {
    // TODO(JonasWanke)
  }

  let typeArguments = cst.child.typeArguments
      .map<List<AstTypeArgument>>({ lowerTypeArguments(context, id, it) })
      .orElse({ List.empty<AstTypeArgument>() })

  context.addIdMapping(cst.id, id)
  AstNamedType(id, modifiers, nameParts, typeArguments)
}
fun lowerGroupType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstGroupType>,
): Maybe<AstInlineType> {
  let type = if cst.child.type is None<CstNode<CstInlineType>> {
    context.addError(ExpectedTypeInGroupTypeCompilerError(context.file, cst))
    None<AstInlineType>()
  } else {
    lowerInlineType(context, parentId, cst.child.type.unwrap())
  }

  // TODO(JonasWanke): support modifiers on group types
  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  type
}
fun lowerFunctionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstFunctionType>,
): Maybe<AstFunctionType> {
  let id = context.getInlineTypeId(parentId)

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let receiverType = cst.child.receiverType
      .flatMap<AstInlineType>({ lowerInlineType(context, id, it) })

  let parameterTypes = cst.child.parameterTypes
      .map<List<AstInlineType>>({ lowerFunctionTypeParameterTypes(context, id, it) })
      .orElse({
        context.addError(ExpectedParameterTypesInFunctionTypeCompilerError(context.file, cst))
        List.empty<AstInlineType>()
      })

  let returnType = cst.child.returnType.flatMap<AstInlineType>({ lowerInlineType(context, id, it) })
  // TODO(marcelgarus): This error also gets emitted if the CST contains a return type, but this
  // type couldn't be lowered.
  if returnType is None {
    context.addError(ExpectedReturnTypeInFunctionTypeCompilerError(context.file, cst))
    return None<AstFunctionType>()
  }

  context.addIdMapping(cst.id, id)
  Some<AstFunctionType>(
    AstFunctionType(id, modifiers, receiverType, parameterTypes, returnType.unwrap())
  )
}
fun lowerFunctionTypeParameterTypes(
  context: LoweringContext,
  parentId: AstInlineTypeId,
  cst: CstNode<CstFunctionTypeParameterTypes>,
): List<AstInlineType> {
  let parameterTypes = MutableList.empty<AstInlineType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.parameterTypes {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let type = lowerInlineType(context, parentId, node.cast<CstInlineType>())
      if type is Some<AstInlineType> { parameterTypes.append(type.unwrap()) }
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  parameterTypes
}

fun lowerTupleType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstTupleType>,
): Maybe<AstInlineType> {
  let id = context.getInlineTypeId(parentId)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let types = MutableList.empty<AstInlineType>()
  mut let punctuationExpectedNext = false
  for node in cst.child.types {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let type = lowerInlineType(context, id, node.cast<CstInlineType>())
      if type is Some<AstInlineType> { types.append(type.unwrap()) }
      punctuationExpectedNext = true
    }
  }
  if (types as Iterable<AstInlineType>).length() < 2 {
    isValid = false
    context.addError(
      ExpectedTwoOrMoreItemsInTupleCompilerError(
        context.file,
        cst.cast<CstTupleType | CstTupleExpression>(),
      ),
    )
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  if !isValid { return None<AstInlineType>() }
  context.addIdMapping(cst.id, id)
  Some<AstInlineType>(AstTupleType(id, modifiers, types))
}

fun lowerNamedTupleType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstNamedTupleType>,
): Maybe<AstInlineType> {
  let id = context.getInlineTypeId(parentId)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let fields = MutableList.empty<AstNamedTupleTypeField>()
  let previousNames = MutableSet.empty<String>()
  mut let punctuationExpectedNext = false
  for node in cst.child.fields {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }

      let field = lowerNamedTupleTypeField(
        context,
        id,
        node.cast<CstNamedTupleTypeField>(),
        previousNames,
      )
      if field is Some<AstNamedTupleTypeField> {
        fields.append(field.unwrap())
        previousNames.insert(field.unwrap().name.value)
      }
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  if !isValid { return None<AstInlineType>() }
  context.addIdMapping(cst.id, id)
  Some<AstInlineType>(AstNamedTupleType(id, modifiers, fields))
}
fun lowerNamedTupleTypeField(
  context: LoweringContext,
  parentId: AstInlineTypeId,
  cst: CstNode<CstNamedTupleTypeField>,
  previousNames: Set<String>,
): Maybe<AstNamedTupleTypeField> {
  let id = context.getInlineTypeId(parentId)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  if (cst.child.name is None<CstNode<IdentifierToken>>) {
    context.addError(MissingNamedTupleTypeFieldNameCompilerError(context.file, cst))
    isValid = false
  }
  let name = cst.child.name.map<AstIdentifier>({
    if (previousNames.contains(it.child.identifier)) {
      context.addError(DuplicateNamedTupleTypeFieldNameCompilerError(context.file, cst))
      isValid = false
    }
    lowerIdentifier(context, id, it, 0)
  })

  if (cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)>) {
    context.addError(MissingNamedTupleTypeFieldTypeCompilerError(context.file, cst))
    isValid = false
  }
  let type = cst.child.type.flatMap<AstInlineType>({
    if (it.second is None<CstNode<CstInlineType>>) {
      context.addError(ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
      ))
      isValid = false
      return None<AstInlineType>()
    }
    lowerInlineType(context, id, it.second.unwrap())
  })
  if (type is None<AstNamedType>) { isValid = false }

  if !isValid { return None<AstNamedTupleTypeField>() }
  context.addIdMapping(cst.id, id)
  Some<AstNamedTupleTypeField>(AstNamedTupleTypeField(id, modifiers, name.unwrap(), type.unwrap()))
}

public class MissingNamedTupleTypeFieldNameCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstNamedTupleTypeField>
}
impl MissingNamedTupleTypeFieldNameCompilerError: CompilerError {
  public fun id(): String { "missing-named-tuple-type-field-name" }

  public fun location(): Location {
    // At least one of `name` and `type` must be set.
    Location(file, node.child.type.unwrap().first.child.span)
  }
  public fun title(): String { "Missing field name." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}

public class DuplicateNamedTupleTypeFieldNameCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstNamedTupleTypeField>
  // TODO(JonasWanke): highlight previous occurrences of that name
}
impl DuplicateNamedTupleTypeFieldNameCompilerError: CompilerError {
  public fun id(): String { "duplicate-named-tuple-type-field-name" }

  public fun location(): Location {
    Location(file, node.child.name.unwrap().child.span)
  }
  public fun title(): String { "Duplicate field name." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}

public class MissingNamedTupleTypeFieldTypeCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstNamedTupleTypeField>
}
impl MissingNamedTupleTypeFieldTypeCompilerError: CompilerError {
  public fun id(): String { "missing-named-tuple-type-field-type" }

  public fun location(): Location {
    // At least one of `name` and `type` must be set.
    Location(file, node.child.name.unwrap().child.span)
  }
  public fun title(): String { "Missing field type." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}


fun lowerEnumType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstEnumType>,
): Maybe<AstInlineType> {
  let id = context.getInlineTypeId(parentId)
  mut let isValid = true

  let cstVariants = cst.child.variants as Iterable<CstNode<CstEnumTypeVariant | PunctuationToken>>
  assert(cstVariants.isNotEmpty(), "`CstEnumType` must contain at least one variant.")

  if ((cstVariants.whereType<CstNode<CstEnumTypeVariant>>() as Iterable<CstNode<CstEnumTypeVariant>>).length() < 2) {
    context.addError(
      ExpectedTwoOrMoreItemsInTupleCompilerError(
        context.file,
        cst.cast<CstTupleType | CstTupleExpression>(),
      ),
    )
    isValid = false
  }

  let variants = MutableList.empty<AstEnumTypeVariant>()
  let previousNames = MutableSet.empty<String>()
  // We allow a leading bar.
  mut let punctuationExpectedNext = (cstVariants.first().unwrap().child is PunctuationToken)
  for node in cstVariants {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }

      let variant = lowerEnumTypeVariant(
        context,
        id,
        node.cast<CstEnumTypeVariant>(),
        previousNames,
      )
      if variant is Some<AstEnumTypeVariant> {
        variants.append(variant.unwrap())
        previousNames.insert(variant.unwrap().name.value)
      }
      punctuationExpectedNext = true
    }
  }

  if !isValid { return None<AstInlineType>() }
  context.addIdMapping(cst.id, id)
  Some<AstInlineType>(AstEnumType(id, List.empty<AstIdentifier>(), variants))
}

public class ExpectedTwoOrMoreEnumVariantsCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstEnumType>
}
impl ExpectedTwoOrMoreEnumVariantsCompilerError: CompilerError {
  public fun id(): String { "expected-two-or-more-enum-variants" }

  public fun location(): Location {
    // TODO(JonasWanke): report the actual position
    Location(file, Span(0, 1))
  }
  public fun title(): String { "Expected two or more variants in an enum." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description
    ""
  }
}

fun lowerEnumTypeVariant(
  context: LoweringContext,
  parentId: AstInlineTypeId,
  cst: CstNode<CstEnumTypeVariant>,
  previousNames: Set<String>,
): Maybe<AstEnumTypeVariant> {
  let id = context.getInlineTypeId(parentId)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  if (cst.child.nameAndValueType is None<CstNode<IdentifierToken>>) {
    context.addError(MissingEnumVariantNameCompilerError(context.file, cst))
    return None<AstEnumTypeVariant>()
  }
  let nameAndValueType = cst.child.nameAndValueType.unwrap()

  let name = nameAndValueType.first
  if (previousNames.contains(name.child.identifier)) {
    context.addError(DuplicateEnumVariantNameCompilerError(context.file, cst))
    isValid = false
  }
  let name = lowerIdentifier(context, id, name, 0)

  let valueType = nameAndValueType.second
  let valueType = valueType.flatMap<AstInlineType>({ lowerInlineType(context, id, it) })

  if !isValid { return None<AstEnumTypeVariant>() }
  context.addIdMapping(cst.id, id)
  Some<AstEnumTypeVariant>(AstEnumTypeVariant(id, modifiers, name, valueType))
}

public class MissingEnumVariantNameCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstEnumTypeVariant>
}
impl MissingEnumVariantNameCompilerError: CompilerError {
  public fun id(): String { "missing-enum-variant-name" }

  public fun location(): Location {
    // At least one modifier or the variant name must be present.
    Location(
      file,
      (node.child.modifiers as Iterable<CstNode<IdentifierToken>>).first().unwrap().child.span,
    )
  }
  public fun title(): String { "Missing enum variant name." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}

public class DuplicateEnumVariantNameCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstEnumTypeVariant>
  // TODO(JonasWanke): highlight previous occurrences of that name
}
impl DuplicateEnumVariantNameCompilerError: CompilerError {
  public fun id(): String { "duplicate-enum-variant-name" }

  public fun location(): Location {
    Location(file, node.child.nameAndValueType.unwrap().first.child.span)
  }
  public fun title(): String { "Duplicate enum variant name." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}


fun lowerIntersectionType(
  context: LoweringContext,
  parentId: AstDeclarationId | AstInlineTypeId | AstTypeParameterId | AstTypeArgumentId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIntersectionType>,
): AstIntersectionType {
  let id = context.getInlineTypeId(parentId)

  let types = MutableList.empty<AstInlineType>()
  let appendType = { type: AstInlineType =>
    if type is AstIntersectionType {
      types.appendAll((type as AstIntersectionType).types as Iterable<AstInlineType>)
      context.removeTypeIdMapping((type as AstIntersectionType).id)
    } else {
      types.append(type)
    }
  }

  let leftType = lowerInlineType(context, id, cst.child.leftType)
  if leftType is Some<AstInlineType> { appendType(leftType.unwrap()) }

  if cst.child.rightType is None<CstNode<CstInlineType>> {
    context.addError(
      ExpectedTypeCompilerError(
        context.file,
        cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
      ),
    )
  } else {
    let rightType = lowerInlineType(context, id, cst.child.rightType.unwrap())
    if rightType is Some<AstType> { appendType(rightType.unwrap()) }
  }

  context.addIdMapping(cst.id, id)
  AstIntersectionType(id, List.empty<AstIdentifier>(), types)
}

fun lowerTypeParameters(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameters>,
): List<AstTypeParameter> {
  let result = MutableList.empty<AstTypeParameter>()
  let previousNames = MutableSet.empty<String>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeParameters {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let lowered = lowerTypeParameter(
        context,
        parentId,
        node.cast<CstTypeParameter>(),
        previousNames as Set<String>,
      )
      lowered.do({
        result.append(it)
        previousNames.insert(it.name.value)
        unit
      })
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeParameter(
  context: LoweringContext,
  parentId: AstDeclarationId,
  cst: CstNode<CstTypeParameter>,
  previousNames: Set<String>,
): Maybe<AstTypeParameter> {
  let name = cst.child.name
      .map<String>({ it.child.identifier })
      .orElse({ "unnamed-type-parameter-{context.getUnnamedDeclarationIndex()}" })
  if previousNames.contains(name) {
    context.addError(DuplicateTypeParameterNameCompilerError(context.file, cst))
    return None<AstTypeParameter>()
  }
  let id = AstTypeParameterId(parentId, name)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingTypeParameterNameCompilerError(context.file, cst))
    isValid = false
  }

  let upperBound = cst.child.upperBound
      .flatMap<AstInlineType>({
        if it.second is None<CstNode<CstInlineType>> {
          context.addError(ExpectedTypeInTypeParameterCompilerError(context.file, cst))
          None<AstInlineType>()
        } else {
          lowerInlineType(context, id, it.second.unwrap())
        }
      })

  if !isValid { return None<AstTypeParameter>() }
  context.addIdMapping(cst.id, id)
  Some<AstTypeParameter>(AstTypeParameter(id, modifiers, name.unwrap(), upperBound))
}

fun lowerTypeArguments(
  context: LoweringContext,
  parentId: AstInlineTypeId | AstExpressionId,
  cst: CstNode<CstTypeArguments>,
): List<AstTypeArgument> {
  mut let index = 0
  let result = MutableList.empty<AstTypeArgument>()
  mut let punctuationExpectedNext = false
  for node in cst.child.typeArguments {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      result.append(lowerTypeArgument(context, parentId, node.cast<CstTypeArgument>(), index))
      index = index + 1
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingAngleBracket is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerTypeArgument(
  context: LoweringContext,
  parentId: AstInlineTypeId | AstExpressionId,
  cst: CstNode<CstTypeArgument>,
  index: Int,
): AstTypeArgument {
  let id = AstTypeArgumentId(parentId, index)

  let type = lowerInlineType(context, id, cst.child.type)

  context.addIdMapping(cst.id, id)
  AstTypeArgument(id, type)
}

// expressions

fun lowerExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstExpression>,
): Maybe<AstExpression> {
  if cst.child is CstIntExpression {
    return lowerIntExpression(context, parentId, cst.cast<CstIntExpression>())
  }
  if cst.child is CstStringExpression {
    return lowerStringExpression(context, parentId, cst.cast<CstStringExpression>())
  }
  if cst.child is CstLambdaExpression {
    return lowerLambdaExpression(context, parentId, cst.cast<CstLambdaExpression>())
  }
  if cst.child is CstIdentifierExpression {
    return lowerIdentifierExpression(context, parentId, cst.cast<CstIdentifierExpression>())
  }
  if cst.child is CstGroupExpression {
    return lowerGroupExpression(context, parentId, cst.cast<CstGroupExpression>())
  }
  if cst.child is CstTupleExpression {
    return lowerTupleExpression(context, parentId, cst.cast<CstTupleExpression>())
  }
  if cst.child is CstBinaryExpression {
    return lowerBinaryExpression(context, parentId, cst.cast<CstBinaryExpression>())
  }
  if cst.child is CstPropertyExpression {
    return lowerPropertyExpression(context, parentId, cst.cast<CstPropertyExpression>())
  }
  if cst.child is CstNavigationExpression {
    return lowerNavigationExpression(context, parentId, cst.cast<CstNavigationExpression>())
  }
  if cst.child is CstCallExpression {
    return lowerCallExpression(context, parentId, cst.cast<CstCallExpression>())
  }
  if cst.child is CstReturnExpression {
    return lowerReturnExpression(context, parentId, cst.cast<CstReturnExpression>())
  }
  throw "Unknown expression: {cst}."
}

fun lowerIntExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIntExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)
  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstIntExpression(id, cst.child.value.child.value))
}

fun lowerStringExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstStringExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)

  let parts = (cst.child.parts as Iterable<CstNode<StringPart>>)
      .map<Maybe<AstStringPart>>({
        if it.child is CstLiteralStringPart {
          return Some<AstStringPart>(
            lowerLiteralStringPart(context, parentId, it.cast<CstLiteralStringPart>()),
          )
        }
        if it.child is CstEscapedStringPart {
          return lowerEscapedStringPart(context, parentId, it.cast<CstEscapedStringPart>())
        }
        if it.child is CstInterpolatedStringPart {
          return lowerInterpolatedStringPart(
            context,
            parentId,
            it.cast<CstInterpolatedStringPart>(),
          )
        }
        throw "Unknown string part: {it}."
      })
      .maybeMap<AstStringPart>({ it })
      .toList()

  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstStringExpression(id, parts))
}
fun lowerLiteralStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLiteralStringPart>,
): AstStringPart {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  context.addIdMapping(cst.child.value.id, identifierId)
  let identifier = AstIdentifier(identifierId, cst.child.value.child.value)

  context.addIdMapping(cst.id, id)
  AstLiteralStringPart(id, identifier)
}
fun lowerEscapedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstEscapedStringPart>,
): Maybe<AstStringPart> {
  let id = context.getExpressionId(parentId)

  let identifierId = AstIdentifierId(id, 0)
  let value = cst.child.value.map<AstIdentifier>({
    let validEscapeSequences = MutableMap.empty<String, String>()
    validEscapeSequences.set("🦄", "\🦄")
    validEscapeSequences.set("👍", "\👍")
    validEscapeSequences.set("n", "\n")
    validEscapeSequences.set("r", "\r")
    validEscapeSequences.set("t", "\t")
    validEscapeSequences.set("\\", "\\")

    let rawValue = it.child.value
    let value = (validEscapeSequences as Map<String, String>)
      .get(rawValue)
      .orElse({
        context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
        rawValue
      })
    context.addIdMapping(it.id, identifierId)
    AstIdentifier(identifierId, value)
  })
  if cst.child.value is None<CstNode<StringLiteralToken>> {
    context.addError(InvalidEscapeSequenceCompilerError(context.file, cst))
  }

  context.addIdMapping(cst.id, id)
  value.map<AstStringPart>({ value => AstLiteralStringPart(id, value) })
}
fun lowerInterpolatedStringPart(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstInterpolatedStringPart>,
): Maybe<AstStringPart> {
  let id = context.getExpressionId(parentId)

  if cst.child.closingCurlyBrace is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  context.addIdMapping(cst.id, id)
  if cst.child.expression is Some<CstNode<CstExpression>> {
    lowerExpression(context, parentId, cst.child.expression.unwrap())
        .map<AstStringPart>({ AstInterpolatedStringPart(id, it) })
  } else {
    context.addError(MissingExpressionInInterpolationCompilerError(context.file, cst))
    None<AstStringPart>()
  }
}

fun lowerLambdaExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLambdaExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)

  let valueParameters = cst.child.valueParameters
      .map<List<AstValueParameter>>({ lowerLambdaExpressionValueParameters(context, id, it) })
      .orElse({ List.empty<AstValueParameter>() })

  let expressions = (cst.child.expressions as Iterable<CstNode<CstExpression>>)
      .map<Maybe<AstExpression>>({ lowerExpression(context, id, it) })
      .maybeMap<AstExpression>({ it })
      .toList()

  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstLambdaExpression(id, valueParameters, expressions))
}
fun lowerLambdaExpressionValueParameters(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstLambdaExpressionValueParameters>,
): List<AstValueParameter> {
  let id = context.getExpressionId(parentId)

  let valueParameters = lowerValueParameterList(context, id, cst.child.valueParameters)

  context.addIdMapping(cst.id, id)
  valueParameters
}

fun lowerIdentifierExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstIdentifierExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)

  let value = lowerIdentifier(context, id, cst.child.value, 0)

  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstIdentifierExpression(id, value))
}

fun lowerGroupExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstGroupExpression>,
): Maybe<AstExpression> {
  let expression = cst.child.expression.flatMap<AstExpression>({
    lowerExpression(context, parentId, it)
  })
  if cst.child.expression is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
      ),
    )
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  return expression
}

fun lowerTupleExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstTupleExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)
  mut let isValid = true

  let expressions = MutableList.empty<AstExpression>()
  mut let punctuationExpectedNext = false
  for node in cst.child.expressions {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      let expression = lowerExpression(context, parentId, node.cast<CstExpression>())
      expression.do({ expressions.append(it) })
      if expression is None<AstExpression> { isValid = false }
      punctuationExpectedNext = true
    }
  }
  if (expressions as Iterable<AstExpression>).length() < 2 {
    isValid = false
    context.addError(
      ExpectedTwoOrMoreItemsInTupleCompilerError(
        context.file,
        cst.cast<CstTupleType | CstTupleExpression>(),
      ),
    )
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  if !isValid { return None<AstExpression>() }
  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstTupleExpression(id, expressions))
}

fun lowerPropertyExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstPropertyExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)
  mut let isValid = true

  let modifiers = lowerModifiers(context, id, cst.child.modifiers)

  let name = cst.child.name.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  if name is None<AstIdentifier> {
    context.addError(MissingPropertyNameCompilerError(context.file, cst))
    isValid = false
  }

  let type = if cst.child.type is None<(CstNode<PunctuationToken>, Maybe<CstNode<CstInlineType>>)> {
    None<AstInlineType>()
  } else {
    let type = cst.child.type.unwrap()
    if type.second is None<CstNode<CstInlineType>> {
      context.addError(
        ExpectedTypeCompilerError(
          context.file,
          cst.cast<CstTrait | CstImpl | CstType | CstNamedTupleTypeField | CstIntersectionType>(),
        ),
      )
      None<AstInlineType>()
    } else {
      lowerInlineType(context, id, type.second.unwrap())
    }
  }

  let initializer = cst.child.initializer.flatMap<AstExpression>({
    if it.child.expression is None<CstNode<CstExpression>> {
      context.addError(
        ExpectedExpressionCompilerError(
          context.file,
          it.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
        ),
      )
      None<AstExpression>()
    } else {
      lowerExpression(context, id, it.child.expression.unwrap())
    }
  })
  if (cst.child.initializer is None<CstDelegationBody>) {
    context.addError(MissingPropertyNameCompilerError(context.file, cst))
    isValid = false
  }

  if !isValid { return None<AstExpression>() }
  context.addIdMapping(cst.id, id)
  Some<AstExpression>(
    AstPropertyExpression(id, None<AstCandyDoc>(), modifiers, name.unwrap(), type, initializer),
  )
}

public class MissingPropertyNameCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstPropertyExpression>
}
impl MissingPropertyNameCompilerError: CompilerError {
  public fun id(): String { "missing-property-name" }

  public fun location(): Location { Location(file, node.child.keyword.child.span) }
  public fun title(): String { "Missing property name." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}

public class MissingPropertyInitializerCompilerError {
  public let file: FancyFile
  public let node: CstNode<CstPropertyExpression>
}
impl MissingPropertyInitializerCompilerError: CompilerError {
  public fun id(): String { "missing-property-initializer" }

  public fun location(): Location { Location(file, node.child.keyword.child.span) }
  public fun title(): String { "Missing property initializer." }
  public fun description(): String {
    /// TODO(JonasWanke): add a description for this error
    ""
  }
}


fun lowerBinaryExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstBinaryExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)
  mut let isValid = true

  if cst.child.leftOperand is None<CstNode<CstExpression>>
    || cst.child.rightOperand is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
      )
    )
  }

  let leftOperand = cst.child.leftOperand
      .flatMap<AstExpression>({ lowerExpression(context, id, it) })

  let operatorId = AstIdentifierId(id, 0)
  context.addIdMapping(cst.child.operator.id, operatorId)
  let operator = AstIdentifier(operatorId, cst.child.operator.child.punctuation)

  let rightOperand = cst.child.rightOperand
      .flatMap<AstExpression>({ lowerExpression(context, id, it) })

  context.addIdMapping(cst.id, id)
  if leftOperand is Some<AstExpression> && rightOperand is Some<AstExpression> {
    Some<AstExpression>(
      AstBinaryExpression(id, leftOperand.unwrap(), operator, rightOperand.unwrap()),
    )
  } else {
    None<AstExpression>()
  }
}

fun lowerNavigationExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstNavigationExpression>,
): Maybe<AstExpression> {
  if cst.child.target is None<CstNode<IdentifierToken>> {
    context.addError(
      ExpectedIdentifierCompilerError(
        context.file,
        cst.cast<CstNavigationExpression | CstValueArgument>(),
      ),
    )
    return lowerExpression(context, parentId, cst.child.receiver)
  }

  let id = context.getExpressionId(parentId)

  let receiver = lowerExpression(context, id, cst.child.receiver)

  let target = lowerIdentifier(context, id, cst.child.target.unwrap(), 0)

  context.addIdMapping(cst.id, id)
  receiver.map<AstExpression>({ receiver => AstNavigationExpression(id, receiver, target) })
}

fun lowerCallExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstCallExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)

  let receiver = lowerExpression(context, id, cst.child.receiver)

  let typeArguments = cst.child.typeArguments
      .map<List<AstTypeArgument>>({ lowerTypeArguments(context, id, it) })
      .orElse({ List.empty<AstTypeArgument>() })

  let valueArguments = lowerValueArguments(context, id, cst.child.valueArguments)

  context.addIdMapping(cst.id, id)
  receiver.map<AstExpression>({ receiver =>
    AstCallExpression(id, receiver, typeArguments, valueArguments)
  })
}

fun lowerValueArguments(
  context: LoweringContext,
  parentId: AstExpressionId,
  cst: CstNode<CstValueArguments>,
): List<AstValueArgument> {
  mut let index = 0
  let result = MutableList.empty<AstValueArgument>()
  mut let punctuationExpectedNext = false
  for node in cst.child.valueArguments {
    if node.child is PunctuationToken {
      if !punctuationExpectedNext {
        // TODO(JonasWanke)
      } else {
        punctuationExpectedNext = false
      }
    } else {
      if punctuationExpectedNext {
        // TODO(JonasWanke)
      }
      lowerValueArgument(context, parentId, node.cast<CstValueArgument>(), index)
          .do({ result.append(it) })
      index = index + 1
      punctuationExpectedNext = true
    }
  }

  if cst.child.closingParenthesis is None<CstNode<PunctuationToken>> {
    let upcastedCst = cst.cast<CstDeclarationContent
        | CstBlockBody
        | CstValueParameters
        | CstGroupType
        | CstFunctionTypeParameterTypes
        | CstTupleType
        | CstNamedTupleType
        | CstTypeParameters
        | CstTypeArguments
        | CstGroupExpression
        | CstTupleExpression
        | CstInterpolatedStringPart
        | CstValueArguments>()
    context.addError(MissingClosingBracketCompilerError(context.file, upcastedCst))
  }

  result
}
fun lowerValueArgument(
  context: LoweringContext,
  parentId: AstExpressionId,
  cst: CstNode<CstValueArgument>,
  index: Int,
): Maybe<AstValueArgument> {
  let id = AstExpressionId(parentId, index)

  let name = cst.child.name.flatMap<AstIdentifier>({
    if it.first is None<CstNode<IdentifierToken>> {
      context.addError(
        ExpectedIdentifierCompilerError(
          context.file,
          cst.cast<CstNavigationExpression | CstValueArgument>(),
        ),
      )
      None<AstIdentifier>()
    }
    it.first.map<AstIdentifier>({ lowerIdentifier(context, id, it, 0) })
  })

  let value = cst.child.value.flatMap<AstExpression>({ lowerExpression(context, id, it) })
  if cst.child.value is None<CstNode<CstExpression>> {
    context.addError(
      ExpectedExpressionCompilerError(
        context.file,
        cst.cast<CstExpressionBody | CstDelegationBody | CstGroupExpression | CstBinaryExpression | CstValueArgument>(),
      ),
    )
  }

  context.addIdMapping(cst.id, id)
  value.map<AstValueArgument>({ value => AstValueArgument(id, name, value) })
}

fun lowerReturnExpression(
  context: LoweringContext,
  parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  cst: CstNode<CstReturnExpression>,
): Maybe<AstExpression> {
  let id = context.getExpressionId(parentId)

  let value = cst.child.value.flatMap<AstExpression>({ lowerExpression(context, id, it) })

  context.addIdMapping(cst.id, id)
  Some<AstExpression>(AstReturnExpression(id, value))
}

// utility

class LoweringContext {
  static fun create(file: FancyFile): LoweringContext {
    LoweringContext(
      file,
      idMapping = MutableMap.empty<CstNodeId, AstNodeId>(),
      nextUnnamedDeclarationIndex = 0,
      nextTypeId = 0,
      nextExpressionId = 0,
      errors = MutableList.empty<CompilerError>(),
    )
  }

  let file: FancyFile

  let idMapping: MutableMap<CstNodeId, AstNodeId>
  fun addIdMapping(cstId: CstNodeId, astId: AstNodeId) {
    assert(
      !(idMapping as Map<CstNodeId, AstNodeId>).containsKey(cstId),
      "ID {cstId} already lowered to {astId}.",
    )
    idMapping.set(cstId, astId)
  }
  fun removeTypeIdMapping(astId: AstInlineTypeId) {
    idMapping.removeWhere({ _, value =>
      if !(value is AstInlineTypeId) { return false }
      // TODO(JonasWanke): this only works because type IDs are currently numbered per file
      (value as AstInlineTypeId).value == astId.value
    })
  }
  mut let nextUnnamedDeclarationIndex: Int
  fun getUnnamedDeclarationIndex(): Int {
    let index = nextUnnamedDeclarationIndex
    nextUnnamedDeclarationIndex = nextUnnamedDeclarationIndex + 1
    index
  }

  mut let nextTypeId: Int
  fun getInlineTypeId(
    parentId: AstDeclarationId
      | AstInlineTypeId
      | AstTypeParameterId
      | AstTypeArgumentId
      | AstValueParameterId
      | AstExpressionId,
    ): AstInlineTypeId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstInlineTypeId(parentId, nextTypeId)
    nextTypeId = nextTypeId + 1
    id
  }

  mut let nextExpressionId: Int
  fun getExpressionId(
    parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId,
  ): AstExpressionId {
    // TODO(JonasWanke): number these per parent when IDs implement `Equals & Hash`

    let id = AstExpressionId(parentId, nextExpressionId)
    nextExpressionId = nextExpressionId + 1
    id
  }

  let errors: MutableList<CompilerError>
  fun addError(error: CompilerError) { errors.append(error) }

  fun getResult(): (Map<CstNodeId, AstNodeId>, List<CompilerError>) {
    Tuple(idMapping, errors)
  }
}
