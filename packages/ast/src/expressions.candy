use ..declarations
use ..file
use ..node
use ..types

public class AstExpressionId {
  let declaration: AstDeclarationId
  let value: Int
}
impl AstExpressionId: AstNodeId


public trait /* enum */ AstExpression
impl AstExpression: AstNode


public class AstIntExpression {
  public let id: AstExpressionId
  public let value: Int
}
impl AstIntExpression: AstExpression


public class AstStringExpression {
  public let id: AstExpressionId
  public let parts: List<AstStringPart>
}
impl AstStringExpression: AstExpression

public trait /* enum */ AstStringPart

public class AstLiteralStringPart {
  public let id: AstExpressionId
  public let value: AstIdentifier
}
impl AstLiteralStringPart: AstStringPart

public class AstInterpolatedStringPart {
  public let id: AstExpressionId
  public let expression: AstExpression
}
impl AstInterpolatedStringPart: AstStringPart


public class AstLambdaExpression {
  public let id: AstExpressionId
  public let valueParameters: List<AstValueParameter>
  public let expressions: List<AstExpression>
}
impl AstLambdaExpression: AstExpression


public class AstIdentifierExpression {
  public let id: AstExpressionId
  public let value: String
}
impl AstIdentifierExpression: AstExpression


public class AstBinaryExpression {
  public let id: AstExpressionId

  public let leftOperand: Maybe<AstExpression>

  public let operator: String
  /// May be one of the following:
  ///
  /// * arithmetic: `+`, `-`, `*`, `/`, `~/`, `%`
  /// * assignment & comparison: `=`, `==`, `!=`, `<`, `<=`, `>`, `>=`
  /// * logical: `&`, `|`, `=>`
  ///
  /// TODO(JonasWanke): convert this to an enum when we support these

  public let rightOperand: Maybe<AstExpression>
}
impl AstBinaryExpression: AstExpression


public class AstLocalPropertyExpression {
  public let id: AstDeclarationId
  public let modifiers: List<String>
  public let isMutable: Bool
  public let name: Maybe<String>
  public let type: Maybe<AstCandyType>
  public let initializer: Maybe<AstExpression>
}
impl AstLocalPropertyExpression: AstExpression


public class AstNavigationExpression {
  public let id: AstExpressionId
  public let receiver: AstExpression
  public let target: String
}
impl AstNavigationExpression: AstExpression

public class AstCallExpression {
  public let id: AstExpressionId
  public let receiver: AstExpression
  public let typeArguments: List<AstTypeArgument>
  public let valueArguments: List<AstValueArgument>
}
impl AstCallExpression: AstExpression

public class AstValueArgument {
  public let id: AstExpressionId
  public let name: Maybe<String>
  public let value: Maybe<AstExpression>
}

public class AstTupleExpression {
  public let id: AstExpressionId
  public let valueArguments: List<AstExpression>
}
impl AstTupleExpression: AstExpression


public class AstReturnExpression {
  public let id: AstExpressionId
  public let value: Maybe<AstExpression>
}
impl AstReturnExpression: AstExpression
