use ..comment
use ..declarations
use ..file
use ..node
use ..types

public class AstExpressionId {
  let parentId: AstDeclarationId | AstBodyId | AstValueParameterId | AstExpressionId
  let value: Int
}
impl AstExpressionId: AstNodeId & Equals & Hash {
  fun equals(other: This): Bool {
    (parentId as Equals) == (other.parentId as Equals) &&
      (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parentId as Hash).hash<T>(hasher)
    (value as Hash).hash<T>(hasher)
  }
}


public trait /* enum */ AstExpression
impl AstExpression: AstNode & Equals & Hash


public class AstIntExpression {
  public let id: AstExpressionId
  public let value: Int
}
impl AstIntExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) && (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (value as Hash).hash<T>(hasher)
  }
}


public class AstStringExpression {
  public let id: AstExpressionId
  public let parts: List<AstStringPart>
}
impl AstStringExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (parts as Equals) == (other.parts as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (parts as Hash).hash<T>(hasher)
  }
}


public trait /* enum */ AstStringPart

public class AstLiteralStringPart {
  public let id: AstExpressionId
  public let value: AstIdentifier
}
impl AstLiteralStringPart: AstStringPart & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) && (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (value as Hash).hash<T>(hasher)
  }
}

public class AstInterpolatedStringPart {
  public let id: AstExpressionId
  public let expression: AstExpression
}
impl AstInterpolatedStringPart: AstStringPart & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) && (expression as Equals) == (other.expression as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (expression as Hash).hash<T>(hasher)
  }
}


public class AstLambdaExpression {
  public let id: AstExpressionId
  public let valueParameters: List<AstValueParameter>
  public let expressions: List<AstExpression>
}
impl AstLambdaExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (valueParameters as Equals) == (other.valueParameters as Equals) &&
      (expressions as Equals) == (other.expressions as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (valueParameters as Hash).hash<T>(hasher)
    (expressions as Hash).hash<T>(hasher)
  }
}


public class AstIdentifierExpression {
  public let id: AstExpressionId
  public let value: AstIdentifier
  public let typeArguments: List<AstTypeArgument>
}
impl AstIdentifierExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals)
      && (value as Equals) == (other.value as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (value as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
  }
}


public class AstPositionalTupleExpression {
  public let id: AstExpressionId
  public let expressions: List<AstExpression>
}
impl AstPositionalTupleExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (expressions as Equals) == (other.expressions as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (expressions as Hash).hash<T>(hasher)
  }
}


public class AstBinaryExpression {
  public let id: AstExpressionId

  public let leftOperand: AstExpression

  public let operator: AstIdentifier
  /// May be one of the following:
  ///
  /// * arithmetic: `+`, `-`, `*`, `/`, `~/`, `%`
  /// * assignment & comparison: `=`, `==`, `!=`, `<`, `<=`, `>`, `>=`
  /// * logical: `&`, `|`, `=>`
  ///
  /// TODO(never, JonasWanke): convert this to an enum when we support these

  public let rightOperand: AstExpression
}
impl AstBinaryExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (leftOperand as Equals) == (other.leftOperand as Equals) &&
      (operator as Equals) == (other.operator as Equals) &&
      (rightOperand as Equals) == (other.rightOperand as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (leftOperand as Hash).hash<T>(hasher)
    (operator as Hash).hash<T>(hasher)
    (rightOperand as Hash).hash<T>(hasher)
  }
}


public class AstPropertyExpression {
  public let id: AstExpressionId
  public let candyDoc: Maybe<AstCandyDoc>
  public let modifiers: List<AstIdentifier>
  public let name: AstIdentifier
  public let type: Maybe<AstInlineType>
  public let initializer: AstExpression
}
impl AstPropertyExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (candyDoc as Equals) == (other.candyDoc as Equals) &&
      (modifiers as Equals) == (other.modifiers as Equals) &&
      (name as Equals) == (other.name as Equals) &&
      (type as Equals) == (other.type as Equals) &&
      (initializer as Equals) == (other.initializer as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (candyDoc as Hash).hash<T>(hasher)
    (modifiers as Iterable<AstIdentifier>).hash<T>(hasher)
    (name as Hash).hash<T>(hasher)
    (type as Hash).hash<T>(hasher)
    (initializer as Hash).hash<T>(hasher)
  }
}


public class AstNavigationExpression {
  public let id: AstExpressionId
  public let receiver: AstExpression
  public let target: AstIdentifier
  public let typeArguments: List<AstTypeArgument>
}
impl AstNavigationExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && (target as Equals) == (other.target as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (receiver as Hash).hash<T>(hasher)
    (target as Hash).hash<T>(hasher)
    (typeArguments as Iterable<AstTypeArgument>).hash<T>(hasher)
  }
}

public class AstCallExpression {
  public let id: AstExpressionId
  public let receiver: AstExpression
  public let typeArguments: List<AstTypeArgument>
  public let valueArguments: List<AstValueArgument>
}
impl AstCallExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
      && (valueArguments as Equals) == (other.valueArguments as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (receiver as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
    (valueArguments as Hash).hash<T>(hasher)
  }
}

public class AstValueArgument {
  public let id: AstExpressionId
  public let name: Maybe<AstIdentifier>
  public let value: AstExpression
}
impl AstValueArgument: Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) &&
      (name as Equals) == (other.name as Equals) &&
      (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    (name as Hash).hash<T>(hasher)
    (value as Hash).hash<T>(hasher)
  }
}


public class AstReturnExpression {
  public let id: AstExpressionId
  public let value: Maybe<AstExpression>
}
impl AstReturnExpression: AstExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (id as Equals) == (other.id as Equals) && (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (id as Hash).hash<T>(hasher)
    value.hash<T>(hasher)
  }
}
