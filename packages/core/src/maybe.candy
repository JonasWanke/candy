use ..primitives

public trait Maybe<Value> {
  fun unwrap(): Value
  fun orElse(alternative: () => Value): Value
  fun map<Out>(mapper: (Value) => Out): Maybe<Out> { flatMap<Out>({ Some<Out>(mapper(it)) })}
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out>
  fun do(lambda: (Value) => Unit) { map<Unit>({ lambda(it) }) }
}

public class Some<Value> {
  let value: Value
}
impl<Value> Some<Value>: Maybe<Value> {
  fun unwrap(): Value { value }
  fun orElse(alternative: () => Value): Value { value }
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out> { mapper(value) }
}

// TODO(JonasWanke): remove type parameter when multi-impls are supported
public class None<Value>
impl<Value> None<Value>: Maybe<Value> {
  fun unwrap(): Value { throw "Unwrapped `None`." }
  fun orElse(alternative: () => Value): Value { alternative() }
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out> { None<Out>() }
}
