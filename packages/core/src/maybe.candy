use ..bool
use ..hash
use ..operators
use ..primitives

public trait Maybe<Value> {
  fun unwrap(): Value
  fun orElse(alternative: () => Value): Value
  fun map<Out>(mapper: (Value) => Out): Maybe<Out> { flatMap<Out>({ Some<Out>(mapper(it)) }) }
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out>
  fun cast<Out>(): Maybe<Out> { map<Out>({ it as Out }) }
  fun do(lambda: (Value) => Unit) { map<Unit>({ lambda(it) }) }
}

public class Some<Value> {
  let value: Value
}
impl<Value> Some<Value>: Maybe<Value> {
  fun unwrap(): Value { value }
  fun orElse(alternative: () => Value): Value { value }
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out> { mapper(value) }
}

// TODO(JonasWanke): remove type parameter when multi-impls are supported
public class None<Value>
impl<Value> None<Value>: Maybe<Value> {
  fun unwrap(): Value { throw "Unwrapped `None`." }
  fun orElse(alternative: () => Value): Value { alternative() }
  fun flatMap<Out>(mapper: (Value) => Maybe<Out>): Maybe<Out> { None<Out>() }
}

impl<T> Maybe<T> {
  fun unsafeEquals(other: Maybe<T>): Bool {
    if (this is None) && (other is None) { return true }
    if (this is Some) && (other is Some) {
      return (this.unwrap() as Equals) == (other.unwrap() as Equals)
    }
    return false
  }
  fun unsafeHash<T>(hasher: Hasher<T>) { this.do({ it.hash<T>(hasher) }) }
}
