use ...bool
use ...maybe
use ...numbers
use ..iterable
use ..array
public use .array_list

public trait List<Item>: Iterable<Item> {
  static fun empty<Item>(): List<Item> { ArrayList.empty<Item>() }
  static fun of1<Item>(first: Item): List<Item> {
    ArrayList.of1<Item>(first)
  }
  static fun of2<Item>(first: Item, second: Item): List<Item> {
    ArrayList.of2<Item>(first, second)
  }
  static fun of3<Item>(first: Item, second: Item, third: Item): List<Item> {
    ArrayList.of3<Item>(first, second, third)
  }
  static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): List<Item> {
    ArrayList.of4<Item>(first, second, third, fourth)
  }
  static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): List<Item> {
    ArrayList.of5<Item>(first, second, third, fourth, fifth)
  }

  // TODO(marcelgarus): Getterize!
  fun isEmpty(): Bool { length() == 0 }
}

public trait MutableList<Item>: List<Item> {
  static fun empty<Item>(): MutableList<Item> { ArrayList.empty<Item>() }
  static fun of1<Item>(first: Item): MutableList<Item> {
    ArrayList.of1<Item>(first)
  }
  static fun of2<Item>(first: Item, second: Item): MutableList<Item> {
    ArrayList.of2<Item>(first, second)
  }
  static fun of3<Item>(first: Item, second: Item, third: Item): MutableList<Item> {
    ArrayList.of3<Item>(first, second, third)
  }
  static fun of4<Item>(first: Item, second: Item, third: Item, fourth: Item): MutableList<Item> {
    ArrayList.of4<Item>(first, second, third, fourth)
  }
  static fun of5<Item>(first: Item, second: Item, third: Item, fourth: Item, fifth: Item): MutableList<Item> {
    ArrayList.of5<Item>(first, second, third, fourth, fifth)
  }
  
  fun set(index: Int /* UInt */, item: Item)
  // TODO(marcelgarus): Rename to add as soon as the naming conflict with + is resolved.
  fun append(item: Item)

  fun removeAt(index: Int /* UInt */): Item

  fun removeFirst(): Item { removeAt(0) }
  fun removeSecond(): Item { removeAt(1) }
  fun removeThird(): Item { removeAt(2) }
  fun removeFourth(): Item { removeAt(3) }
  fun removeFifth(): Item { removeAt(4) }

  fun removeLast(): Item { removeAt(length() - 1) }
  fun removeSecondLast(): Item { removeAt(length() - 2) }
  fun removeThirdLast(): Item { removeAt(length() - 3) }
  fun removeFourthLast(): Item { removeAt(length() - 4) }
  fun removeFifthLast(): Item { removeAt(length() - 5) }

  fun removeFirstWhere(check: (Item) => Bool): Maybe<Item> {
    mut let cursor = 0
    for item in this as Iterable<Item> {
      if check(item) {
        removeAt(cursor)
        return Some<Item>(item)
      }
      cursor = cursor + 1
    }
    return None<Item>()
  }

  fun clear() {
    while isNotEmpty() {
      removeLast()
    }
  }
}
