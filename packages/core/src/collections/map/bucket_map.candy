use ....bool
use ....hash
use ....maybe
use ....numbers
use ....operators
use ....todo
use ...array
use ...iterable
use ...map
use ..linked_hash_map

// TODO(marcelgarus): Make the `BucketMap` implementation way more efficient.
// TODO(marcelgarus): Typedef Bucket as LinkedHashMap.

class BucketMap<Key: Equals & Hash, Value> {
  let buckets: Array<LinkedHashMap<Key, Value>>
  mut let numEntries: Int

  fun bucketByHash(hash: Int): LinkedHashMap<Key, Value> { buckets.get(hash % buckets.length) }
  fun bucketByKey(key: Key): LinkedHashMap<Key, Value> { bucketByHash(hashByKey(key)) }
}
impl<Key: Equals & Hash, Value> BucketMap<Key, Value>: Map<Key, Value> {
  fun length(): Int { numEntries }

  fun get(key: Key): Maybe<Value> { bucketByKey(key).get(key) }

  fun entries(): Iterable<(Key, Value)> {
    todo("Implement BucketMap.entries")
  }
}
impl<Key: Equals & Hash, Value> BucketMap<Key, Value>: MutableMap<Key, Value> {
  fun set(key: Key, value: Value) {
    let bucket = bucketByKey(key)
    if !bucket.containsKey(key) {
      numEntries = numEntries + 1
    }
    bucket.set(key, value)
  }

  fun putIfAbsent(key: Key, ifAbsent: () => Value): Value {
    let bucket = bucketByKey(key)
    if !bucket.containsKey(key) {
      bucket.set(key, ifAbsent())
      numEntries = numEntries + 1
    }
    bucket.get(key).unwrap()
  }

  fun remove(key: Key): Maybe<Value> {
    let bucket = bucketByKey(key)
    if bucket.containsKey(key) {
      let result = bucket.remove(key)
      numEntries = numEntries - 1
      return result
    }
    None<Value>()
  }

  // TODO(marcelgarus): Implement `cast` more efficiently than the default one. We can do this by
  // using the precomputed `hash`es â€“ regardless of the type, those won't change. That also means
  // the buckets stay the same.
  // fun cast<NewKey, NewValue>(): Map<NewKey, NewValue>
}
