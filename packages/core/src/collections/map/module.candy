use ...bool
use ...hash
use ...maybe
use ...numbers
use ...operators
use ...todo
use ..iterable
use .bucket_map
use .linked_hash_map

// TODO(marcelgarus): Create type alias `MapKey` for `Equals & Hash`.

public trait Map<Key: Equals & Hash, Value> {
  static fun empty<Key: Equals & Hash, Value>(): Map<Key, Value> {
    MutableMap.empty<Key, Value>()
  }

  fun length(): Int
  fun isEmpty(): Bool { length() == 0 }
  fun isNotEmpty(): Bool { !isEmpty() }

  fun get(key: Key): Maybe<Value>
  fun containsKey(key: Key): Bool { get(key) is Some<Value> }

  fun entries(): Iterable<(Key, Value)>
  fun keys(): Iterable<Key> { entries().map<Key>({ it.first }) }
  fun values(): Iterable<Value> { entries().map<Value>({ it.second }) }
}

// TODO(marcelgarus): impl Map<Key, Value>: GetOperator<Key, Maybe<Value>>

public trait MutableMap<Key: Equals & Hash, Value>: Map<Key, Value> {
  static fun empty<Key: Equals & Hash, Value>(): MutableMap<Key, Value> {
    BucketMap.empty<Key, Value>()
  }

  fun set(key: Key, value: Value)

  fun putIfAbsent(key: Key, ifAbsent: () => Value): Value {
    let safeGet = get as ((Key) => Maybe<Value>)
    let value = safeGet(key)
    if value is Some<Value> {
      value.unwrap()
    } else {
      let value = ifAbsent()
      set(key, value)
      value
    }
  }

  fun remove(key: Key): Maybe<Value>
  fun removeWhere(selector: (Key, Value) => Bool) {
    for entry in (this as Map<Key, Value>) {
      if selector(entry.first, entry.second) { remove(entry.first) }
    }
  }

  fun clear() {
    for key in keys() {
      remove(key as Key)
    }
  }

  fun setAll(map: Map<Key, Value>) {
    for entry in map.entries() {
      set(entry.first, entry.second)
    }
  }

  fun cast<NewKey, NewValue>(): Map<NewKey, NewValue> {
    todo("Implement MutableMap.cast")
  }
}
