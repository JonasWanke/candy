trait SolverData: Comparable & Equals & Hash {
//   static fun canonical(n: /* UInt */ Int): This
//   /// Returns the `n`th canonical value of this type.
}

impl String: SolverData {
//   static fun canonical(n: /* UInt */ Int): This { "{n}" }
}

trait SolverType<Data: SolverData> {
  /// Either a `SolverVariable<T>` or a `SolverValue<T>`.

  let data: Data

  fun toString_(): String
  fun containsVariable(variable: SolverVariable<Data>): Bool

  fun substitute(variable: SolverVariable<Data>, substitution: SolverType<Data>): SolverType<Data> {
    substituteAll(Map.of1<SolverVariable<Data>, SolverType<Data>>(Tuple(variable, substitution)))
  }
  fun substituteAll(substitutions: Map<SolverVariable<Data>, SolverType<Data>>): SolverType<Data>

  fun canonicalize(canonical: (Int) => Data): SolverType<Data> {
    canonicalizeInternal(MutableMap.empty<SolverVariable<Data>, SolverVariable<Data>>(), canonical)
  }
  fun canonicalizeInternal(
    mapping: MutableMap<SolverVariable<Data>, SolverVariable<Data>>,
    canonical: (Int) => Data,
  ): SolverType<Data>

  public fun unify(other: SolverType<Data>): Maybe<Map<SolverVariable<Data>, SolverType<Data>>> {
    /// Unifies `this` type with the `other`. If unification succeeds, returns a map from variables
    /// to substitutions. Unification may fail if no variable substitutions exist that makes both
    /// types the same.
    ///
    /// Examples:
    ///
    /// * Unifying `String` with `String` succeeds. No substitutions necessary.
    /// * Unifying `Int` with `String` fails.
    /// * Unifying `Int` with `?A` succeeds with the substitution `?A = Int`.
    /// * Unifying `List<?A>` with `List<Set<?B>>` succeeds with the substitution `?A = Set<?B>`.
    /// * Unifying `Map<?A, ?A>` with `Map<Int, String>` fails.
    /// * Unifying `Map<?A, ?A>` with `Map<Int, Int>` succeeds with the subsitution `?A = Int`.
    /// * Unifying `Map<?A, ?A>` with `Map<?B, Int>` succeeds with the substitutions `?A = Int` and
    ///   `?B = Int`.
    /// * Unifying `Set<?A>` with `Set<?B>` succeeds with the substitution `?A = ?B`.
    /// * Unifying `?Batman` with `Na<?Batman>` fails because repeated substitution would lead to
    ///   types of infinite size:
    ///   `?Batman = Na<?Batman> = Na<Na<?Batman>> = ... = Na<Na<Na<Na<Na<Na<?Batman>>>>>> = ...`
    /// * Unifying `Map<?A, ?B>` with `Map<Ping<?B>, Pong<?A>>` fails because repeated substitution
    ///   would lead to types of infinite size:
    ///   `?A = Ping<?B> = Ping<Pong<?A>> = Ping<Pong<Ping<?B>>> = Ping<Pong<Ping<Pong<?A>>>> = ...`
    //
    // TODO(marcelgarus): Write property-based tests for this. For example, generate random types
    // and then check that the order of unifying doesn't matter and that applying the substitutions
    // actually results in the same type.

    if this is SolverVariable && other is SolverVariable {
      // If both are variables, we return a substitution with the lexicographically first one being
      // the one subsituted. For example, unifying `?B` with `?A` would yield the substitution
      // `?A = ?B`.
      let this_ = (this as SolverVariable<Data>)
      let other_ = (other as SolverVariable<Data>)

      if this_.data == other_.data {
        // Being equal to itself is no bound, so no substitution `?A = ?A` is necessary.
        return Some<Map<SolverVariable<Data>, SolverType<Data>>>(
          Map.empty<SolverVariable<Data>, SolverType<Data>>()
        )
      } else {
        if this_.data < other_.data {
          return Some<Map<SolverVariable<Data>, SolverType<Data>>>(
            Map.of1<SolverVariable<Data>, SolverType<Data>>(Tuple(this_, other_)),
          )
        } else {
          return Some<Map<SolverVariable<Data>, SolverType<Data>>>(
            Map.of1<SolverVariable<Data>, SolverType<Data>>(Tuple(other_, this_)),
          )
        }
      }
    }

    if this is SolverVariable && other is SolverValue {
      let this_ = (this as SolverVariable<Data>)
      
      if other.containsVariable(this_) {
        // This is an infinitely growing type. That's not allowed.
        return None<Map<SolverVariable<Data>, SolverType<Data>>>()
      }
      return Some<Map<SolverVariable<Data>, SolverType<Data>>>(
        Map.of1<SolverVariable<Data>, SolverType<Data>>(Tuple(this_, other))
      )
    }

    if this is SolverValue && other is SolverVariable {
      return other.unify(this)
    }

    let this_ = (this as SolverValue<Data>)
    let other_ = (other as SolverValue<Data>)

    if !(this_.data == other_.data)
      || !((this_.parameters as Iterable).length() == (other_.parameters as Iterable).length()) {
      return None<Map<SolverVariable<Data>, SolverType<Data>>>()
    }

    // To unify all types, we have a queue of substitutions that we try to bring into a common
    // solution space one by one.
    let solutionSpace = MutableMap.empty<SolverVariable<Data>, SolverType<Data>>()
    let queue: Maybe<MutableList<(SolverVariable<Data>, SolverType<Data>)>> = (this_.parameters as Iterable<SolverType>)
      .zip<SolverType<Data>>(other_.parameters as Iterable<SolverType<Data>>)
      .map<Maybe<Map<SolverVariable<Data>, SolverType<Data>>>>({ it.first.unify(it.second) })
      .foldLeft<Maybe<Iterable<Map<SolverVariable<Data>, SolverType<Data>>>>>(
        Some<Iterable<Map<SolverVariable<Data>, SolverType<Data>>>>(
          List.empty<Map<SolverVariable<Data>, SolverType<Data>>>(),
        ),
        { a, b =>
          if a is None { return None<Iterable<Map<SolverVariable<Data>, SolverType<Data>>>>() }
          if b is None { return None<Iterable<Map<SolverVariable<Data>, SolverType<Data>>>>() }
          return Some<Iterable<Map<SolverVariable<Data>, SolverType<Data>>>>(
            a.unwrap().followedBy(List.of1<Map<SolverVariable<Data>, SolverType<Data>>>(b.unwrap())),
          )
        },
      )
      .map<MutableList<(SolverVariable<Data>, SolverType<Data>)>>({
        it.expand<(SolverVariable<Data>, SolverType<Data>)>({ it.entries() }).toMutableList()
      })
    if queue is None {
      return None<Map<SolverVariable<Data>, SolverType<Data>>>()
    }
    let queue = queue.unwrap()

    while (queue as Iterable).isNotEmpty() {
      let substitution = queue.removeFirst()
      if (solutionSpace as Map<SolverVariable<Data>, SolverType<Data>>).containsKey(substitution.first) {
        let existingSubstitution = (solutionSpace as Map<SolverVariable<Data>, SolverType<Data>>)
          .get(substitution.first)
          .unwrap()
        let unified = existingSubstitution.unify(substitution.second)
        if unified is None {
          return None<Map<SolverVariable<Data>, SolverType<Data>>>()
        }
        queue.appendAll(unified.unwrap().entries())
      } else {
        solutionSpace.set(substitution.first, substitution.second)
        solutionSpace.updateAll({ it.substitute(substitution.first, substitution.second) })
        queue.updateAll({
          Tuple(it.first, it.second.substitute(substitution.first, substitution.second))
        })
        if (queue as Iterable<(SolverVariable<Data>, SolverType<Data>)>).any({
          it.second.containsVariable(it.first)
        }) {
          return None<Map<SolverVariable<Data>, SolverType<Data>>>()
        }
      }
    }

    Some<Map<SolverVariable<Data>, SolverType<Data>>>(solutionSpace)
  }
}
impl<Data> SolverType<Data>: Equals & Hash

class SolverVariable<Data: SolverData> {
  /// A type variable that needs to be substituted.
  ///
  /// These map to the type parameters in Candy. In the context of the solver,
  /// they are displayed with a leading question mark: `?name`
  ///
  /// Examples:
  ///
  /// * `?T`
  /// * `?0`

  let data: SolverData
}
impl<Data> SolverVariable<Data>: SolverType<Data> {
  fun toString_(): String { "?{data}" }
  fun containsVariable(variable: SolverVariable<Data>): Bool { data == variable.data }

  fun substituteAll(substitutions: Map<SolverVariable<Data>, SolverType<Data>>): SolverType<Data> {
    substitutions.get(SolverVariable<Data>(data)).orElse({ this })
  }

  fun canonicalizeInternal(
    mapping: MutableMap<SolverVariable<Data>, SolverVariable<Data>>,
    canonical: (Int) => Data,
  ): SolverVariable<Data> {
    mapping.putIfAbsent(this, {
      SolverVariable<Data>(canonical((mapping as Map).entries().length()) as SolverData)
    })
  }
}
impl<Data: SolverData> SolverVariable<Data>: Equals & Hash {
  fun equals(other: This): Bool { data == other.data }
  fun hash<T>(hasher: Hasher<T>) { data.hash<T>(hasher) }
}

class SolverValue<Data: SolverData> {
  /// A concrete type. May contain `SolverVariable`s inside its `parameters`.
  ///
  /// Examples:
  ///
  /// * `List<?T>`
  /// * `String`
  /// * `Set<Int>`
  /// * `Tuple<Int, String>`

  let data: Data
  let parameters: List<SolverType<Data>>
}
impl<Data: SolverData> SolverValue<Data>: SolverType<Data> {
  fun toString_(): String {
    mut let s = "{name}"
    if (parameters as Iterable).isNotEmpty() {
      s = "{s}<{(parameters as Iterable<SolverType<Data>>).map<String>({ it.toString_() }).join(", ")}>"
    }
    s
  }

  fun containsVariable(variable: SolverVariable<Data>): Bool {
    (parameters as Iterable<SolverType<Data>>).any({ it.containsVariable(variable) })
  }

  fun substituteAll(substitutions: Map<SolverVariable<Data>, SolverType<Data>>): SolverValue<Data> {
    SolverValue<Data>(
      name,
      (parameters as Iterable<SolverType<Data>>)
        .map<SolverType<Data>>({ it.substituteAll(substitutions) })
        .toList()
    )
  }

  fun canonicalizeInternal(
    mapping: MutableMap<SolverVariable<Data>, SolverVariable<Data>>,
    canonical: (Int) => Data,
  ): SolverValue<Data> {
    SolverValue<Data>(
      name,
      (parameters as Iterable<SolverType<Data>>)
        .map<SolverType<Data>>({ it.canonicalizeInternal(mapping) })
        .toList(),
    )
  }
}
impl SolverValue: Equals & Hash {
  fun equals(other: This): Bool {
    name == other.name
      && (parameters as Iterable<SolverType<Data>>)
        .unsafeEquals(other.parameters as Iterable<SolverType<Data>>)
  }
  fun hash<T>(hasher: Hasher<T>) {
    name.hash<T>(hasher)
    (parameters as Iterable).length().hash<T>(hasher)
    for parameter in parameters {
      (parameter as Hash).hash<T>(hasher)
    }
  }
}
