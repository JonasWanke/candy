use ..impls
use ..types

fun main() {
  debugUnify(string, string)
  debugUnify(int, string)
  debugUnify(int, a)
  debugUnify(list(a), list(set(b)))
  debugUnify(map(a, a), map(int, string))
  debugUnify(map(a, a), map(int, int))
  debugUnify(map(a, a), map(b, int))
  debugUnify(set(a), set(b))
  debugUnify(a, list(a))
  debugUnify(map(a, b), map(list(b), list(a)))

  debugSolveEqualsImpl(foo)
  debugSolveEqualsImpl(int)
  debugSolveEqualsImpl(a)
  debugSolveEqualsImpl(maybe(foo))
  debugSolveEqualsImpl(maybe(int))
  debugSolveEqualsImpl(list(maybe(int)))
  debugSolveEqualsImpl(list(a))
}

fun debugUnify(first: SolverType<String>, second: SolverType<String>) {
  mut let s = "Unifying {first.toString_()} and {second.toString_()}"
  let result = first.unify(second)
  if result is None {
    print("{s}: not possible")
  } else {
    let substitutions = result.unwrap()
    if substitutions.isEmpty() {
      print("{s}: possible, no substitutions necessary")
    } else {
      print("{s}: possible, with these substitutions: {substitutions.entries().map<String>({ "{it.first.toString_()} = {it.second.toString_()}" }).join(", ")}")
    }
  }
}

fun debugSolveEqualsImpl(type: SolverType<String>) {
  let environment = Environment<String, String>(
    List.of4<SolverRule<String, String>>(
      // impl Int: Equals
      SolverRule(equalsImpl(int), List.empty<SolverGoal<String, String>>()),
      // impl<T: Equals> Maybe<T>: Equals
      SolverRule(equalsImpl(maybe(a)), List.of1<SolverGoal<String, String>>(equalsImpl(a))),
      // impl<T: Equals> Iterable<T>: Equals
      SolverRule(
        equalsImpl(a),
        List.of2<SolverGoal<String, String>>(iterableImpl(b, a), equalsImpl(b)),
      ),
      // impl<T> List<T>: Iterable<T>
      SolverRule(iterableImpl(a, list(a)), List.empty<SolverGoal<String, String>>()),
    ),
  )
  print("Does {type.toString_()} implement Equals? {environment.solve(equalsImpl(type)).toString_()}")
}

let noParams = List.empty<SolverType<String>>()
let string = SolverValue<String>("String", noParams)
let int = SolverValue<String>("Int", noParams)
let foo = SolverValue<String>("Foo", noParams)
fun maybe(t: SolverType<String>): SolverType<String> {
  SolverValue<String>("Maybe", List.of1<SolverType<String>>(t))
}
fun list(t: SolverType<String>): SolverType<String> {
  SolverValue<String>("List", List.of1<SolverType<String>>(t))
}
fun set(t: SolverType<String>): SolverType<String> {
  SolverValue<String>("Set", List.of1<SolverType<String>>(t))
}
fun map(key: SolverType<String>, value: SolverType<String>): SolverType<String> {
  SolverValue<String>("Map", List.of2<SolverType<String>>(key, value))
}
let a = SolverVariable<String>("A")
let b = SolverVariable<String>("B")
fun equalsImpl(t: SolverType<String>): SolverGoal<String, String> { SolverGoal<String, String>("Equals", List.of1<SolverType<String>>(t)) }
fun iterableImpl(t: SolverType<String>, iterable: SolverType<String>): SolverGoal<String, String> {
  SolverGoal<String, String>("Iterable", List.of2<SolverType<String>>(t, iterable))
}
