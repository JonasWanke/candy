use ..impls
use ..solver
use ..types

fun main() {
  debug(string, string)
  debug(int, string)
  debug(int, a)
  debug(list(a), list(set(b)))
  debug(map(a, a), map(int, string))
  debug(map(a, a), map(int, int))
  debug(map(a, a), map(b, int))
  debug(set(a), set(b))
  debug(a, list(a))
  debug(map(a, b), map(list(b), list(a)))

  let solution = Environment(
    List.of4<SolverRule>(
      // impl Int: Equals
      SolverRule(equalsImpl(int), List.empty<SolverGoal>()),
      // impl<T: Equals> Maybe<T>: Equals
      SolverRule(equalsImpl(maybe(a)), List.of1<SolverGoal>(equalsImpl(a))),
      // impl<T: Equals> Iterable<T>: Equals
      SolverRule(equalsImpl(a), List.of2<SolverGoal>(iterableImpl(b, a), equalsImpl(b))),
      // impl<T> List<T>: Iterable<T>
      SolverRule(iterableImpl(a, list(a)), List.empty<SolverGoal>()),
    ),
  ).solve(equalsImpl(int))
  print(solution.toString_())
}

fun debug(first: SolverType, second: SolverType) {
  mut let s = "Unifying {first.toString_()} and {second.toString_()}"
  let result = first.unify(second)
  if result is None {
    print("{s}: not possible")
  } else {
    let substitutions = result.unwrap()
    if substitutions.isEmpty() {
      print("{s}: possible, no substitutions necessary")
    } else {
      print("{s}: possible, with these substitutions: {substitutions.entries().map<String>({ "{it.first.toString_()} = {it.second.toString_()}" }).join(", ")}")
    }
  }
}

let noParams = List.empty<SolverType>()
let string = SolverValue("String", noParams)
let int = SolverValue("Int", noParams)
fun maybe(t: SolverType): SolverType { SolverValue("Maybe", List.of1<SolverType>(t)) }
fun list(t: SolverType): SolverType { SolverValue("List", List.of1<SolverType>(t)) }
fun set(t: SolverType): SolverType { SolverValue("Set", List.of1<SolverType>(t)) }
fun map(key: SolverType, value: SolverType): SolverType {
  SolverValue("Map", List.of2<SolverType>(key, value))
}
let a = SolverVariable("A")
let b = SolverVariable("B")
fun equalsImpl(t: SolverType): SolverGoal { SolverGoal("Equals", List.of1<SolverType>(t)) }
fun iterableImpl(t: SolverType, iterable: SolverType): SolverGoal {
  SolverGoal("Iterable", List.of2<SolverType>(t, iterable))
}
