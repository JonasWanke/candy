use ..types

class SolverGoal<Trait: Equals & Hash, Data: SolverData> {
  /// The fact that a type implements a trait.
  ///
  /// In the context of the solver, this is displayed as `trait(type)`.
  ///
  /// Examples:
  ///
  /// * `Clone(List<Int>)`: the fact that `List<Int>` implements `Clone`
  /// * `Any(?T)`: the fact that `?T` implements `Any`
  /// * `Clone(?T)`: the fact that `?T` implements `Clone`
  /// * `Iterable(?T, ?L)`: the fact that `?L` implements `Iterable<?T>`

  let trait_: Trait
  let parameters: List<SolverType<Data>>

  fun toString_(): String {
    "{trait_}({(parameters as Iterable<SolverType<Data>>).map<String>({ it.toString_() }).join(", ")})"
  }
  fun unify(other: SolverGoal<Trait, Data>, canonical: (Int) => Data): Maybe<Map<SolverVariable<Data>, SolverType<Data>>> {
    if !(trait_ == other.trait_) { return None }
    SolverValue<Data>(canonical(0), parameters)
      .unify(SolverValue<Data>(canonical(0), other.parameters))
  }
  fun substituteAll(
    substitutions: Map<SolverVariable<Data>, SolverType<Data>>,
  ): SolverGoal<Trait, Data> {
    SolverGoal<Trait, Data>(
      trait_,
      (parameters as Iterable<SolverType<Data>>)
        .map<SolverType<Data>>({ it.substituteAll(substitutions) })
        .toList(),
    )
  }
  fun canonicalize(canonical: (Int) => Data): SolverGoal<Trait, Data> {
    SolverGoal<Trait, Data>(
      trait_,
      (SolverValue<Data>(canonical(0), parameters).canonicalize(canonical) as SolverValue<Data>)
        .parameters,
    )
  }
}
impl<Trait: Equals & Hash, Data: SolverData> SolverGoal<Trait, Data>: Equals & Hash {
  fun equals(other: This): Bool {
    trait_ == other.trait_
      && (parameters as Iterable<SolverType<Data>>)
        .zip<SolverType<Data>>(other.parameters)
        .map<Bool>({ (it.first as Equals) == (it.second as Equals) })
        .all({ it })
  }
  fun hash<T>(hasher: Hasher<T>) {
    trait_.hash<T>(hasher)
    for parameter in parameters {
      (parameter as Hash).hash<T>(hasher)
    }
  }
}

class SolverRule<Trait: Equals & Hash, Data: SolverData> {
  /// An inference rule. Usually generated based on impls.
  ///
  /// In the context of the solver, these are displayed as `goal <- subgoals`.
  ///
  /// Examples:
  /// * `Clone(Tuple<?0, ?1>) <- Clone(?0), Clone(?1)`: the fact that `Tuple<?0, ?1>` implements
  ///   `Clone` if both `?0` and `?1` implement `Clone`
  /// * `Any(?T) <- <nothing>`: the fact that every `?T` implements `Any`

  let goal: SolverGoal<Trait, Data>
  let subgoals: List<SolverGoal<Trait, Data>>

  fun toString_(): String {
    "{goal.toString_()} <- {(subgoals as Iterable<SolverGoal<Trait, Data>>).map<String>({ it.toString_() }).join(", ")}"
  }
}
impl SolverRule: Equals & Hash {
  fun equals(other: This): Bool {
    (goal as Equals) == (other.goal as Equals)
      && (subgoals as Iterable<SolverType<Data>>)
        .zip<SolverType<Data>>(other.subgoals as Iterable<SolverType<Data>>)
        .map<Bool>({ (it.first as Equals) == (it.second as Equals) })
        .all({ it })
  }
  fun hash<T>(hasher: Hasher<T>) {
    goal.hash<T>(hasher)
    for subgoal in subgoals {
      subgoal.hash<T>(hasher)
    }
  }
}

class Environment<Trait: Equals & Hash, Data: SolverData> {
  let rules: List<SolverRule<Trait, Data>>

  fun solve(goal: SolverGoal<Trait, Data>): SolverSolution<Trait, Data> {
    Solver<Trait, Data>(rules, MutableMap.empty<SolverGoal<Trait, Data>, SolverTree<Trait, Data>>())
      .solve(goal)
  }
}


trait /* enum */ SolverSolution<Trait: Equals & Hash, Data: SolverData> {
  fun toString_(): String
}

class SolverSolutionUnique<Trait: Equals & Hash, Data: SolverData> {
  /// Indicates that there is exactly one type that can fulfill the goal.

  let refinedGoal: SolverGoal<Trait, Data>

  fun toString_(): String { "Unique({refinedGoal.toString_()})" }
}
impl<Trait: Equals & Hash, Data: SolverData> SolverSolutionUnique<Trait, Data>: SolverSolution<Trait, Data>

class SolverSolutionAmbiguous<Trait: Equals & Hash, Data: SolverData> {
  /// Indicates that there may be multiple types that can fulfill the goal.

  fun toString_(): String { "Ambiguous" }
}
impl<Trait: Equals & Hash, Data: SolverData> SolverSolutionAmbiguous<Trait, Data>: SolverSolution<Trait, Data>

class SolverSolutionImpossible<Trait: Equals & Hash, Data: SolverData> {
  /// Indicates that it's impossible to fulfill the goal.

  fun toString_(): String { "Impossible" }
}
impl<Trait: Equals & Hash, Data: SolverData> SolverSolutionImpossible<Trait, Data>: SolverSolution<Trait, Data>


class Solver<Trait: Equals & Hash, Data: SolverData> {
  let rules: List<SolverRule<Trait, Data>>

  let cache: MutableMap<SolverGoal<Trait, Data>, SolverTree<Trait, Data>>
  /// Sometimes, the same goal needs to be reached multiple times.
  ///
  /// For example, when checking whether `Clone(Tuple<Int, Int>)`, it doesn't make sense to prove
  /// `Clone(Int)` twice.
  ///
  /// This also allows us to detect cycles and resolve them.

  fun solve(goal: SolverGoal<Trait, Data>): SolverSolution<Trait, Data> {
    let goal = goal.canonicalize()
    cache
      .putIfAbsent(goal, {
        SolverTree(
          goal,
          None<SolverSolution<Trait, Data>>(),
          false,
          MutableList.empty<SolverStrand<Trait, Data>>(),
        )
      })
      .solve(this)
  }
}

// Solutions that solving a goal might produce.

class SolverTree<Trait: Equals & Hash, Data: SolverData> {
  let goal: SolverGoal<Trait, Data>
  mut let solution: Maybe<SolverSolution<Trait, Data>>
  mut let isCurrentlyBeingSolved: Bool
  let strands: MutableList<SolverStrand<Trait, Data>>

  fun solve(context: Solver<Trait, Data>): SolverSolution<Trait, Data> {
    if solution is Some { return solution.unwrap() }
    if isCurrentlyBeingSolved {
      solution = Some<SolverSolution<Trait, Data>>(SolverSolutionAmbiguous<Trait, Data>())
      isCurrentlyBeingSolved = false
      return solution.unwrap()
    }
    isCurrentlyBeingSolved = true
    strands.appendAll(
      (context.rules as Iterable<SolverRule<Trait, Data>>)
        .where({ it.goal.unify(goal) is Some })
        .map<SolverStrand<Trait, Data>>({
          let result = it.goal.unify(goal).unwrap()
          SolverStrand<Trait, Data>(
            it.goal.substituteAll(result),
            result.toMutable(),
            (it.subgoals as Iterable<SolverGoal<Trait, Data>>)
              .map<SolverGoal<Trait, Data>>({ it.substituteAll(result) })
              .toMutableList(),
          )
        })
    )
    let strandsAndSolutions = (strands as Iterable<SolverStrand<Trait, Data>>)
      .map<(SolverStrand<Trait, Data>, SolverSolution<Trait, Data>)>({
        Tuple(it, it.solve(context))
      })
      .where({ !(it.second is SolverSolutionImpossible) })
      .toList()
    if (strandsAndSolutions as Iterable).length() > 1 {
      return SolverSolutionAmbiguous<Trait, Data>()
    }
    if (strandsAndSolutions as Iterable).isEmpty() {
      return SolverSolutionImpossible<Trait, Data>()
    }
    let strandAndSolution = (strandsAndSolutions as Iterable<(SolverStrand<Trait, Data>, SolverSolution<Trait, Data>)>)
      .single()
      .unwrap()
    let strand = strandAndSolution.first
    let solution = strandAndSolution.second
    if solution is SolverSolutionAmbiguous {
      return SolverSolutionAmbiguous<Trait, Data>()
    }
    let solution = (solution as SolverSolutionUnique<Trait, Data>)
    let substitutions = strand.goal.unify(solution.refinedGoal).unwrap()
    let refinedGoal = goal.substituteAll(substitutions)
    SolverSolutionUnique<Trait, Data>(refinedGoal)
  }
}

class SolverStrand<Trait: Equals & Hash, Data: SolverData> {
  /// A thread exploring possible solutions.

  let goal: SolverGoal<Trait, Data>
  let solutionSpace: MutableMap<SolverVariable<Trait, Data>, SolverType<Data>>
  let subgoals: MutableList<SolverGoal<Trait, Data>>

  fun solve(context: Solver<Trait, Data>): SolverSolution<Trait, Data> {
    while (subgoals as Iterable<SolverGoal<Trait, Data>>).isNotEmpty() {
      let subgoal = subgoals.removeFirst().canonicalize()
      let solution = context.solve(subgoal)
      if solution is SolverSolutionImpossible {
        return SolverSolutionImpossible<Trait, Data>()
      }
      if solution is SolverSolutionUnique {
        // Integrate the solution into the solution space.
        let refinedGoal = (solution as SolverSolutionUnique<Trait, Data>).refinedGoal
        let substitutions = subgoal.unify(refinedGoal).unwrap()
        for substitution in substitutions.entries() {
          let variable = substitution.first
          let type = substitution.second
          let sub = (solutionSpace as Map<SolverVariable<Trait, Data>, SolverType<Data>>).get(variable)
          if sub is None {
            solutionSpace.set(variable, type)
          } else {
            let newSubstitutions = sub.unwrap().unify(type)
            if newSubstitutions is None {
              return SolverSolutionImpossible<Trait, Data>()
            }
            solutionSpace.updateAll({ it.substituteAll(newSubstitutions.unwrap()) })
          }
        }
      }
    }
    SolverSolutionUnique<Trait, Data>(goal.substituteAll(solutionSpace))
  }
}
