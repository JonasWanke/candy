use ...declarations
use ...types
use ..types

class SolverGoal {
  /// The fact that a type implements a trait.
  ///
  /// In the context of the solver, this is displayed as `trait(type)`.
  ///
  /// Examples:
  ///
  /// * `Clone(List<Int>)`: the fact that `List<Int>` implements `Clone`
  /// * `Any(?T)`: the fact that `?T` implements `Any`
  /// * `Clone(?T)`: the fact that `?T` implements `Clone`
  /// * `Iterable(?T, ?L)`: the fact that `?L` implements `Iterable<?T>`

  let trait_: HirTrait
  let parameters: List<SolverType>

  fun toString_(): String {
    "{trait_}({(parameters as Iterable<SolverType>).map<String>({ it.toString_() }).join(", ")})"
  }
  fun unify(other: SolverGoal): Maybe<Map<SolverVariable, SolverType>> {
    if !(trait_ == other.trait_) { return None<Map<SolverVariable, SolverType>>() }
    SolverValue(canonicalVariable(0) as HirType, parameters)
      .unify(SolverValue(canonicalVariable(0) as HirType, other.parameters))
  }
  fun substituteAll(substitutions: Map<SolverVariable, SolverType>): SolverGoal {
    SolverGoal(
      trait_,
      (parameters as Iterable<SolverType>)
        .map<SolverType>({ it.substituteAll(substitutions) })
        .toList(),
    )
  }
  fun canonicalize(): SolverGoal {
    SolverGoal(
      trait_,
      (SolverValue(canonicalVariable(0) as HirType, parameters).canonicalize() as SolverValue).parameters,
    )
  }
}
impl SolverGoal: Equals & Hash {
  fun equals(other: This): Bool {
    trait_ == other.trait_
      && (parameters as Iterable<SolverType>)
        .zip<SolverType>(other.parameters)
        .map<Bool>({ (it.first as Equals) == (it.second as Equals) })
        .all({ it })
  }
  fun hash<T>(hasher: Hasher<T>) {
    trait_.hash<T>(hasher)
    for parameter in parameters {
      (parameter as Hash).hash<T>(hasher)
    }
  }
}

class SolverRule {
  /// An inference rule. Usually generated based on impls.
  ///
  /// In the context of the solver, these are displayed as `goal <- subgoals`.
  ///
  /// Examples:
  /// * `Clone(Tuple<?0, ?1>) <- Clone(?0), Clone(?1)`: the fact that `Tuple<?0, ?1>` implements
  ///   `Clone` if both `?0` and `?1` implement `Clone`
  /// * `Any(?T) <- <nothing>`: the fact that every `?T` implements `Any`

  let goal: SolverGoal
  let subgoals: List<SolverGoal>

  fun toString_(): String {
    "{goal.toString_()} <- {(subgoals as Iterable<SolverGoal>).map<String>({ it.toString_() }).join(", ")}"
  }
}
impl SolverRule: Equals & Hash {
  fun equals(other: This): Bool {
    (goal as Equals) == (other.goal as Equals)
      && (subgoals as Iterable<SolverType>)
        .zip<SolverType>(other.subgoals as Iterable<SolverType>)
        .map<Bool>({ (it.first as Equals) == (it.second as Equals) })
        .all({ it })
  }
  fun hash<T>(hasher: Hasher<T>) {
    goal.hash<T>(hasher)
    for subgoal in subgoals {
      subgoal.hash<T>(hasher)
    }
  }
}

class Environment {
  let rules: List<SolverRule>

  fun solve(goal: SolverGoal): SolverSolution {
    Solver(rules, MutableMap.empty<SolverGoal, SolverTree>()).solve(goal)
  }
}


trait /* enum */ SolverSolution {
  fun toString_(): String
}

class SolverSolutionUnique {
  /// Indicates that there is exactly one type that can fulfill the goal.

  let refinedGoal: SolverGoal

  fun toString_(): String { "Unique({refinedGoal.toString_()})" }
}
impl SolverSolutionUnique: SolverSolution

class SolverSolutionAmbiguous {
  /// Indicates that there may be multiple types that can fulfill the goal.

  fun toString_(): String { "Ambiguous" }
}
impl SolverSolutionAmbiguous: SolverSolution

class SolverSolutionImpossible {
  /// Indicates that it's impossible to fulfill the goal.

  fun toString_(): String { "Impossible" }
}
impl SolverSolutionImpossible: SolverSolution


class Solver {
  let rules: List<SolverRule>

  let cache: MutableMap<SolverGoal, SolverTree>
  /// Sometimes, the same goal needs to be reached multiple times.
  ///
  /// For example, when checking whether `Clone(Tuple<Int, Int>)`, it doesn't make sense to prove
  /// `Clone(Int)` twice.
  ///
  /// This also allows us to detect cycles and resolve them.

  fun solve(goal: SolverGoal): SolverSolution {
    let goal = goal.canonicalize()
    cache
      .putIfAbsent(goal, {
        SolverTree(goal, None<SolverSolution>(), false, MutableList.empty<SolverStrand>())
      })
      .solve(this)
  }
}

// Solutions that solving a goal might produce.

class SolverTree {
  let goal: SolverGoal
  mut let solution: Maybe<SolverSolution>
  mut let isCurrentlyBeingSolved: Bool
  let strands: MutableList<SolverStrand>

  fun solve(context: Solver): SolverSolution {
    if solution is Some { return solution.unwrap() }
    if isCurrentlyBeingSolved {
      solution = Some<SolverSolution>(SolverSolutionAmbiguous())
      isCurrentlyBeingSolved = false
      return solution.unwrap()
    }
    isCurrentlyBeingSolved = true
    strands.appendAll(
      (context.rules as Iterable<SolverRule>)
        .where({ it.goal.unify(goal) is Some })
        .map<SolverStrand>({
          let result = it.goal.unify(goal).unwrap()
          SolverStrand(
            it.goal.substituteAll(result),
            result.toMutable(),
            (it.subgoals as Iterable<SolverGoal>)
              .map<SolverGoal>({ it.substituteAll(result) })
              .toMutableList(),
          )
        })
    )
    let strandsAndSolutions = (strands as Iterable<SolverStrand>)
      .map<(SolverStrand, SolverSolution)>({
        Tuple(it, it.solve(context))
      })
      .where({ !(it.second is SolverSolutionImpossible) })
      .toList()
    if (strandsAndSolutions as Iterable).length() > 1 {
      return SolverSolutionAmbiguous()
    }
    if (strandsAndSolutions as Iterable).isEmpty() {
      return SolverSolutionImpossible()
    }
    let strandAndSolution = (strandsAndSolutions as Iterable<(SolverStrand, SolverSolution)>)
      .single()
      .unwrap()
    let strand = strandAndSolution.first
    let solution = strandAndSolution.second
    if solution is SolverSolutionAmbiguous {
      return SolverSolutionAmbiguous()
    }
    let solution = (solution as SolverSolutionUnique)
    let substitutions = strand.goal.unify(solution.refinedGoal).unwrap()
    let refinedGoal = goal.substituteAll(substitutions)
    SolverSolutionUnique(refinedGoal)
  }
}

class SolverStrand {
  /// A thread exploring possible solutions.

  let goal: SolverGoal
  let solutionSpace: MutableMap<SolverVariable, SolverType>
  let subgoals: MutableList<SolverGoal>

  fun solve(context: Solver): SolverSolution {
    while (subgoals as Iterable<SolverGoal>).isNotEmpty() {
      let subgoal = subgoals.removeFirst().canonicalize()
      let solution = context.solve(subgoal)
      if solution is SolverSolutionImpossible { return SolverSolutionImpossible() }
      if solution is SolverSolutionUnique {
        // Integrate the solution into the solution space.
        let refinedGoal = (solution as SolverSolutionUnique).refinedGoal
        let substitutions = subgoal.unify(refinedGoal).unwrap()
        for substitution in substitutions.entries() {
          let variable = substitution.first
          let type = substitution.second
          let sub = (solutionSpace as Map<SolverVariable, SolverType>).get(variable)
          if sub is None {
            solutionSpace.set(variable, type)
          } else {
            let newSubstitutions = sub.unwrap().unify(type)
            if newSubstitutions is None {
              return SolverSolutionImpossible()
            }
            solutionSpace.updateAll({ it.substituteAll(newSubstitutions.unwrap()) })
          }
        }
      }
    }
    SolverSolutionUnique(goal.substituteAll(solutionSpace))
  }
}
