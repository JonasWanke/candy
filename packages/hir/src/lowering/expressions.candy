use ast
use compiler_utils
use incremental

use ..declarations
use ..file
use ..resolving
use ...declarations
use ...expressions
use ...file
use ...types

fun lowerFunctionBody(
  context: QueryContext<List<CompilerError>>,
  function: HirFunction,
): (List<HirValueExpressionUri>, Map<HirValueExpressionUri, HirValueExpression>) {
  query<(List<HirValueExpressionUri>, Map<HirValueExpressionUri, HirValueExpression>), List<CompilerError>>(context, "lowerFunctionBody", function, {
    let ast = function.ast(context)
    let loweringContext = LoweringContext.forFunction(context, function)
    todo("")
  })
}

class BodyGlobalState {
  let context: QueryContext<List<CompilerError>>
  let function: HirFunction
  let expressions: Map<HirValueExpressionUri, (HirValueExpression, HirInlineType)>
  mut let nextExpressionId: Int
  let errors: List<CompilerError>
}
class LoweringContext {
  let global: BodyGlobalState
  let parent: Maybe<LoweringContext>
  let localProperties: Map<String, HirValueExpressionUri>

  static fun forFunction(
    context: QueryContext<List<CompilerError>>,
    function: HirFunction,
  ): LoweringContext {
    mut let loweringContext = LoweringContext(
      BodyGlobalState(
        context,
        function,
        Map.empty<HirValueExpressionUri, (HirValueExpression, HirInlineType)>(),
        0,
        List.empty<CompilerError>(),
      ),
      None<LoweringContext>(),
      Map.empty<String, HirValueExpressionUri>(),
    )

    if (function.parent is HirTrait | HirImpl && !function.isStatic(context)) {
      let result = loweringContext.register(
        HirThisValueExpression(),
        HirThisType(function.parent as HirTrait | HirImpl),
      )
      loweringContext = LoweringContext(
        result.first.global,
        result.first.parent,
        result.first.localProperties.copyAndSet("this", result.second),
      )
    }

    for parameter in function.valueParameters(context) {
      // TODO(marcelgarus): `this` is not a valid parameter name.
      let result = loweringContext.register(
        HirParameterReferenceValueExpression(parameter),
        parameter.type(context),
      )
      loweringContext = LoweringContext(
        result.first.global,
        result.first.parent,
        loweringContext.localProperties.copyAndSet(parameter.name, result.second),
      )
    }
    loweringContext
  }
}
impl LoweringContext {
  fun register(
    expression: HirValueExpression,
    expressionType: HirInlineType,
  ): (LoweringContext, HirValueExpressionUri) {
    let uri = HirValueExpressionUri(this.global.function, this.global.nextExpressionId)
    Tuple(
      LoweringContext(
        BodyGlobalState(
          this.global.context,
          this.global.function,
          this.global.expressions.copyAndSet(uri, Tuple(expression, expressionType)),
          this.global.nextExpressionId + 1,
          this.global.errors,
        ),
        this.parent,
        this.localProperties,
      ),
      uri,
    )
  }

  fun registerError(error: CompilerError): (LoweringContext, HirValueExpressionUri) {
    let contextWithError = LoweringContext(
      BodyGlobalState(
        this.global.context,
        this.global.function,
        this.global.expressions,
        this.global.nextExpressionId,
        this.global.errors.copyAndAdd(error),
      ),
      this.parent,
      this.localProperties,
    )
    contextWithError.register(HirErrorValueExpression(), HirErrorType())
  }

  fun resolve(
    context: QueryContext<List<CompilerError>>,
    name: String,
  ): Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType> {
    (this.localProperties as Map<String, HirValueExpressionUri>).get(name)
      .map<Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>>({
        Set.of1<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>(it)
      })
      .orElse({
        // TODO(JonasWanke): Check type parameters of the function.
        this.parent
          .map<Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>>({
            it.resolve(context, name)
          })
          .orElse({
            (resolveIdentifier(context, name, this.global.function) as Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType>)
          })
      })
  }

  // fun lowerLambda(
  //   context: QueryContext<List<CompilerError>>,
  //   lambda: AstLambdaExpression,
  // ): LoweringContext {
  //   let context = LoweringContext(
  //     this.global,
  //     Some<LoweringContext>(this),
  //     MutableMap.empty<String, HirValueExpressionUri>(),
  //   )
  //   let parameters = 
  //   for parameter in function.valueParameters(context) {
  //     let uri = context.register(HirParameterReferenceValueExpression(parameter))
  //     context.localProperties.set(parameter.name, uri)
  //   }
  //   context
  // }

  fun lowerExpressionToValueExpression(
    context: QueryContext<List<CompilerError>>,
    expression: AstExpression,
  ): (LoweringContext, HirValueExpressionUri) {
    let lowered = this.lowerExpression(context, expression)
    if (lowered.second is HirTypeExpression || lowered is HirModuleExpression) {
      lowered.first.registerError(InvalidValueExpressionError(lowered.second as HirTypeExpression | HirModuleExpression))
    } else {
      Tuple(lowered.first, lowered.second as HirValueExpressionUri)
    }
  }

  /// Lowers and registers the expression on this context and returns the uri.
  fun lowerExpression(
    context: QueryContext<List<CompilerError>>,
    expression: AstExpression,
  ): (LoweringContext, HirValueExpressionUri | HirTypeExpression | HirModuleExpression) {
    if (expression is AstIntExpression) {
      return this.register(
        HirIntValueExpression((expression as AstIntExpression).value),
        HirNamedType.coreInt(this.global.context),
      )
    }

    if (expression is AstStringExpression) {
      // For String expressions, the interpolation is desugared string into multiple calls to `+`.
      // "{name} is a great {type}" -> "" + name + " is a great " + type
      mut let result = this.register(
        HirStringValueExpression(""),
        HirNamedType.coreString(this.global.context),
      )

      for part in (expression as AstStringExpression).parts {
        let expressionToAdd: HirValueExpressionUri = if (part is AstLiteralStringPart) {
          Tuple(result.first, HirStringValueExpression((part as AstLiteralStringPart).value.value))
        } else {
          let expressionToStringify = result.first.lowerExpressionToValueExpression(
            context,
            (part as AstInterpolatedStringPart).expression,
          )
          let expressionType = expressionToStringify.first.typeOf(
            context,
            this.global.function,
            this.global.expressions,
            expressionToStringify.second,
          )
          let implementsToString = isAssignableTo(
            context,
            expressionType,
            HirTrait.coreString(context),
            (this.global.function as HasPackageAndPath).package(),
          )
          if (!implementsToString) {
            expressionToStringify.first.registerError(
              InvalidInterpolatedExpressionError(expressionToStringify),
            )
          } else {
            expressionToStringify.first.register(
              HirFunctionCallValueExpression(
                Some<HirValueExpressionUri | HirTypeExpression>(expressionToStringify.second),
                HirFunction.coreToString(context),
                Map.empty<String, HirInlineType>(),
                Map.empty<String, HirValueExpressionUri>(),
              ),
              HirNamedType.coreString(this.global.context),
            )
          }
        }

        result = expressionToAdd.first.register(
          HirFunctionCallValueExpression(
            result,
            // TODO(marcelgarus): Directly call the `String`'s `add` function for better performance
            // (and in case someone implements `+` for `String` a second time).
            HirFunction.infixPlus(context),
            Map.empty<String, HirInlineType>(),
            Map.of1<String, HirValueExpressionUri>(Tuple("other", expressionToAdd.second)),
          ),
          HirNamedType.coreString(this.global.context),
        )
      }
      return result
    }

    if (expression is AstLambdaExpression) {
      let expression = (expression as AstLambdaExpression)
      return this.register(HirLambdaValueExpression(
        (expression.valueParameters as Iterable<AstValueParameter>)
          .map<HirLambdaParameter>({ this.lowerParameter(context, it) })
          .toList(),
        (expression.expressions as Iterable<AstExpression>)
          .map<HirValueExpressionUri>({ this.lowerExpressionToValueExpression(context, it) })
          .toList(),
      ))
    }

    if (expression is AstIdentifierExpression) {
      let expression = (expression as AstIdentifierExpression)
      let name = expression.identifier.name
      let possibleProperties = this.resolve(context, name)
      if (possibleProperties.isEmpty()) {
        return this.registerError(UnresolvedIdentifierError(name))
      }

      let property = possibleProperties.first().unwrap()

      if (property is HirFunction) {
        return this.registerError(UncalledFunctionError(property as HirFunction))
      }
      assert(possibleProperties.length() == 1, "Ambiguous lowering can only occur for overloaded functions.")

      if (property is HirValueExpressionUri) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirValueExpressionUri))
        }
        return Tuple(this, property as HirValueExpressionUri)
      }

      if (property is HirModule) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirModule))
        }
        return Tuple(this, HirModuleExpression(property as HirModule))
      }

      if (property is HirParameterType) {
        if ((expression.typeArguments as Iterable<AstTypeArgument>).isNotEmpty()) {
          this.registerError(InvalidTypeArgumentsError(property as HirParameterType))
        }
        return Tuple(this, property as HirParameterType)
      }

      // That leaves us with `HirType` and `HirTrait` and lots of fun…
      let typeArguments = (expression.typeArguments as Iterable<AstTypeArgument>)
        .map<HirInlineType>({
          astInlineTypeToHirInlineType(context, it.type, this.global.function)
        })
        .toList()
      
      let typeParameters = (property as HasTypeParameters).typeParameters(context)
      let suppliedTypeArgumentCount = (typeArguments as Iterable<HirInlineType>).length()
      let requiredTypeArgumentCount = (typeParameters as Iterable<HirParameterType>).length()
      if (!(suppliedTypeArgumentCount == requiredTypeArgumentCount)) {
        return this.registerError(
          WrongNumberOfTypeArgumentsError(suppliedTypeArgumentCount, requiredTypeArgumentCount),
        )
      }

      let anyTypeArgumentIsInvalid = (typeArguments as Iterable<HirInlineType>)
        .zip<HirParameterType>(typeParameters)
        .any({
          let argument = it.first
          let parameter = it.second
          let upperBound = parameter.upperBound(context)
          if (!isAssignableTo(context, argument, upperBound, (this.global.function as HasPackageAndPath).package())) {
            context.registerError(InvalidTypeArgumentError(argument, upperBound))
            return false
          }
          true
        })
      if (anyTypeArgumentIsInvalid) {
        return this.register(HirErrorValueExpression(), HirErrorType())
      }

      return Tuple(
        this,
        HirTypeExpression(HirNamedType(parameter as HirTrait | HirType, typeArguments)),
      )
    }

    if (expression is AstTupleExpression) {
      let expression = (expression as AstTupleExpression)
      mut let context = this
      mut let parameters = MutableList.empty<HirValueExpressionUri>()
      for expression in expression.expressions {
        let loweringResult = context.lowerExpressionToValueExpression(context, expression)
        context = loweringResult.first
        parameters.append(loweringResult.second)
      }
      return this.register(
        HirNamedTupleValueExpression(
          (fieldNames as Iterable<String>).zip(parameters).unsafeToMap(),
        ),
        HirNamedTupleType(
          (fieldNames as Iterable<String>)
            .zip(parameters.map<HirInlineType>(context.typeOf(it)))
            .unsafeToMap(),
        ),
      )
    }

    if (expression is AstBinaryExpression) {
      let expression = (expression as AstBinaryExpression)
      mut let function = (None<HirFunction>() as Maybe<HirFunction>)
      let name = expression.identifier.name
      if (name == "==") { function = Some<HirFunction>(HirFunction.infixEqualEqual(context)) }
      if (name == "!=") { function = Some<HirFunction>(HirFunction.infixExclamationEqual(context)) }
      if (name == "<")  { function = Some<HirFunction>(HirFunction.infixLess(context)) }
      if (name == "<=") { function = Some<HirFunction>(HirFunction.infixLessEqual(context)) }
      if (name == ">")  { function = Some<HirFunction>(HirFunction.infixGreater(context)) }
      if (name == ">=") { function = Some<HirFunction>(HirFunction.infixGreaterEqual(context)) }
      if (name == "+")  { function = Some<HirFunction>(HirFunction.infixPlus(context)) }
      if (name == "-")  { function = Some<HirFunction>(HirFunction.infixMinus(context)) }
      if (name == "*")  { function = Some<HirFunction>(HirFunction.infixStar(context)) }
      if (name == "/")  { function = Some<HirFunction>(HirFunction.infixSlash(context)) }
      if (name == "//") { function = Some<HirFunction>(HirFunction.infixSlashSlash(context)) }
      if (name == "%")  { function = Some<HirFunction>(HirFunction.infixPercent(context)) }
      if (name == "&")  { function = Some<HirFunction>(HirFunction.infixAmpersand(context)) }
      if (name == "|")  { function = Some<HirFunction>(HirFunction.infixBar(context)) }
      if (name == "=>") { function = Some<HirFunction>(HirFunction.infixEqualGreater(context)) }
      if (function is None<HirFunction>) { throw "Unknown binary operator: {name}" }

      let loweredLeft = this.lowerExpressionToValueExpression(expression.leftOperand)
      let loweredRight = loweredLeft.first.lowerExpressionToValueExpression(expression.rightOperand)
      return this.register(
        HirFunctionCallValueExpression(
          loweredLeft.second,
          function.unwrap(),
          Map.empty<String, HirInlineType>(),
          Map.of1<String, HirValueExpressionUri>(Tuple("other", loweredRight.second)),
        ),
        todo("marcelgarus: Find the correct impl and retrieve the return type"),
      )
    }

    if (expression is AstPropertyExpression) {
      // TODO(marcelgarus): `this` is not a valid property name.
      let expression = (expression as AstPropertyExpression)
      let result = this.lowerExpression(context, expression.initializer.unwrap())
      let context = LoweringContext(
        result.first,
        result.first.parent,
        result.first.localProperties.copyAndSet(expression.name, result.second),
      )
      return Tuple(context, result.second)
    }

    if (expression is AstNavigationExpression) {
      // This is an AstNavigationExpression that has is not inside an AstCallExpression – otherwise,
      // the lowering of the surrounding AstCallExpression would have also handled the inner
      // AstNavigationExpression. So, this is a function invocation without any parameters.
      // But that doesn't work for now.
      todo("Function call with omitted parentheses")
    }

    if (expression is AstCallExpression) {
      let expression = (expression as AstCallExpression)
      let receiver = expression.receiver

      let contextAndNameAndReceiver = if (receiver is AstIdentifierExpression) {
        Tuple(this, (receiver as AstIdentifierExpression).value.name, None<HirValueExpressionUri>())
      } else {
        let lowered = this.lowerExpressionToValueExpression(receiver.receiver)
        Tuple(
          lowered.first,
          (receiver as AstNavigationExpression).target.name,
          Some<HirValueExpressionUri>(lowered.second),
        )
      }
      mut let context = contextAndNameAndReceiver.first
      let name = contextAndNameAndReceiver.second
      let receiver = contextAndNameAndReceiver.third

      let function: HirFunction = context.resolve(context, name)
      // TODO: Support overloading.
      let function = if (function.length() == 1) {
        function.single().unwrap()
      } else {
        return context.registerError(UnsupportedFeatureCompilerError(
          None<Location>(),
          "Function overloading is not yet supported.",
        ))
      }

      // TODO: This is a work in progress. Continue working on it.
      let typeArguments = expression.typeArguments.map<String, HirInlineType>({ name, value =>
        Tuple(name, astInlineTypeToHirInlineType(context, value, this.global.function))
      })
      let valueArguments = MutableMap.empty<String, HirValueExpressionUri>()
      for argument in expression.valueArguments.entries() {
        let lowered = context.lowerExpressionToValueExpression(context, argument.second)
        context = lowered.first
        valueArguments.set(argument.first, lowered.second)
      }

      return this.register(
        HirFunctionCallValueExpression(receiver, function, typeArguments, valueArguments),
        todo("function call type"),
      )
    }

    if (expression is AstReturnExpression) {
      let expression = (expression as AstReturnExpression)
      let returnValue = expression.value.orElse({ HirExpression.unit(context) })
      let lowered = this.lowerExpressionToValueExpression(context, returnValue)
      return this.register(
        HirReturnValueExpression(this.global.function, lowered.second),
        HirNamedType.coreNever(this.global.context),
      )
    }

    assert(false, "Unreachable")
  }

  fun lowerParameter(context: QueryContext<List<CompilerError>>, parameter: AstValueParameter): HirLambdaParameter {
    HirLambdaParameter(
      parameter.name.value,
      // TODO(marcelgarus): Support type inference for parameters.
      parameter.type.map<HirInlineType>({ astInlineTypeToHirInlineType(context, it) })
        .expect("Lambda parameter without specified type."),
    )
  }

  fun typeOf(uri: HirValueExpressionUri): HirInlineType {
    this.global.expressions.get(uri).unwrap().second

    // if (expression is HirLambdaValueExpression) {
    //   // TODO(marcelgarus): Get the supertype of all occurrences of `return` and the last expression.
    //   return expression.returnType
    // }
    // if (expression is HirFunctionCallValueExpression) {
    //   return expression.function.returnType
    // }
    // if (expression is HirValueExpressionCallValueExpression) {
    //   return (typeOf(expression.receiver) as HirFunctionType).returnType
    // }
    // if (expression is HirNamedTupleValueExpression) {
    //   return HirNamedTupleType(
    //     expression.valueArguments
    //       .map<String, HirInlineType>({ Tuple(it.first, typeOf(context, scope, uriMapping, it.second)) }),
    //   )
    // }
    // if (expression is HirNamedTupleFieldAccessValueExpression) {
    //   return (typeOf(context, scope, uriMapping, expression.receiver) as HirNamedTupleType).types
    //     .firstWhere({ it.first == expression.name }).second
    // }
    // throw "Unknown expression type: {expression}"
  }
}

public class InvalidValueExpressionError {
  public let expression: HirTypeExpression | HirModuleExpression
}
impl InvalidValueExpressionError: CompilerError {
  public fun id(): String { "invalid-value-expression" }

  public fun location(): Location {
    todo("Implement InvalidValueExpressionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Cannot use this expression here; expected a value expression." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the non-value expression: {this.expression}"
  }
}

public class InvalidInterpolatedExpressionError {
  public let expression: HirValueExpressionUri
}
impl InvalidInterpolatedExpressionError: CompilerError {
  public fun id(): String { "invalid-interpolated-expression" }

  public fun location(): Location {
    todo("Implement InvalidInterpolatedExpressionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "This expression does not implement ToString." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the non-ToString expression: {this.expression}"
  }
}

public class UnresolvedIdentifierError {
  public let identifier: String
}
impl UnresolvedIdentifierError: CompilerError {
  public fun id(): String { "unresolved-identifier" }

  public fun location(): Location {
    todo("Implement UnresolvedIdentifierError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Unresolved identifier." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "The unresolved identifier is {this.identifier}."
  }
}

public class UncalledFunctionError {
  public let function: HirFunction
}
impl UncalledFunctionError: CompilerError {
  public fun id(): String { "uncalled-function" }

  public fun location(): Location {
    todo("Implement UncalledFunctionError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "You didn't call a function." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "The uncalled function or one of the overloads is {this.function}."
  }
}

public class InvalidTypeArgumentsError {
  public let inner: HirValueExpressionUri | HirModule | HirParameterType
}
impl InvalidTypeArgumentsError: CompilerError {
  public fun id(): String { "invalid-type-arguments" }

  public fun location(): Location {
    todo("Implement InvalidTypeArgumentsError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Cannot add type arguments to module or type parameter references, or some expressions." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "This is the improper expression: {this.inner}"
  }
}

public class WrongNumberOfTypeArgumentsError {
  public let suppliedCount: Int
  public let requiredCount: Int
}
impl WrongNumberOfTypeArgumentsError: CompilerError {
  public fun id(): String { "wrong-number-of-type-arguments" }

  public fun location(): Location {
    todo("Implement WrongNumberOfTypeArgumentsError.location") // TODO(marcelgarus)
  }
  public fun title(): String {
    "Wrong number of type arguments were supplied: {this.suppliedCount}, required: {this.requiredCount}."
  }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}
public class InvalidTypeArgumentError {
  public let actualType: HirInlineType
  public let upperBound: HirInlineType
}
impl InvalidTypeArgumentError: CompilerError {
  public fun id(): String { "invalid-type-arguments" }

  public fun location(): Location {
    todo("Implement InvalidTypeArgumentError.location") // TODO(marcelgarus)
  }
  public fun title(): String {
    "Type argument is not assignable to the type parameter's upper bound."
  }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    "Type argument was {this.actualType}, but is not assignable to {this.upperBound}."
  }
}
