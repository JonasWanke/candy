use ast
use compiler_utils
use incremental

use ..declarations
use ..file
use ...declarations
use ...expressions
use ...file
use ...types

fun lowerFunctionBody(
  context: QueryContext<List<CompilerError>>,
  function: HirFunction,
): (List<HirValueExpressionUri>, Map<HirValueExpressionUri, HirValueExpression>) {
  query<List<HirValueExpression>, List<CompilerError>>(context, "lowerFunctionBody", function, {
    let ast = function.ast(context)
    let context = LoweringContext(
      NameScope(None<LoweringContext>(), MutableMap.empty<String, HirValueExpressionUri>()),
      MutableMap.empty<HirValueExpressionUri, HirValueExpression>(),
      0,
    )
  })
}

class BodyGlobalState {
  let function: HirFunction
  let expressions: MutableMap<HirValueExpressionUri, HirValueExpression>
  mut let nextExpressionId: Int
}
class LoweringContext {
  let global: BodyGlobalState
  let parent: Maybe<LoweringContext>
  let localProperties: MutableMap<String, HirValueExpressionUri>
}
impl LoweringContext {
  fun register(expression: HirValueExpression): HirValueExpressionUri {
    let uri = HirValueExpressionUri(
      this.global.function,
      this.global.nextExpressionId,
    )
    this.global.nextExpressionId = this.global.nextExpressionId + 1
    this.global.expressions.put(uri, expression)
    uri
  }

  fun resolve(
    context: QueryContext<List<CompilerError>>,
    name: String,
  ): Set<HirValueExpressionUri | HirModule | HirType | HirTrait | HirFunction | HirParameterType> {
    this.localProperties.get(name).or({
      this.parent
        .map<Maybe<HirValueExpressionUri>>({ it.resolve(context, name) })
        .orElse({ resolveIdentifier(context, name, this.global.function) })
    })
  }

  /// Lowers and registers the expression on this context and returns the uri.
  fun lowerExpression(
    context: QueryContext<List<CompilerError>>,
    expression: AstExpression,
  ): HirValueExpression | HirTypeExpression | HirModuleExpression {
    if (expression is AstIntExpression) {
      return this.register(HirIntValueExpression((expression as AstIntExpression).value))
    }

    if (expression is AstStringExpression) {
      // For String expressions, the interpolation is desugared string into multiple calls to `+`.
      // "{name} is a great {type}" -> "" + name + " is a great " + type
      mut let stringUri = this.register(HirStringValueExpression(""))

      for part in (expression as AstStringExpression).parts {
        let expressionToAdd: HirExpression = if (part is AstLiteralStringPart) {
          (part as AstLiteralStringPart).value.value
        } else {
          this.lowerExpression(context, (part as AstInterpolatedStringPart).expression)
        }

        stringUri = this.register(HirFunctionCallValueExpression(
          stringUri,
          // TODO(marcelgarus): Directly call the `String`'s `add` function for better performance
          // (and in case someone implements `+` for `String` a second time).
          HirFunction.infixPlus(context),
          Map.empty<String, HirInlineType>(),
          Map.of1<String, HirValueExpressionUri>(Tuple("other", this.register(expressionToAdd))),
        ))
      }
      return stringUri
    }

    if (expression is AstLambdaExpression) {
      let expression = (expression as AstLambdaExpression)
      return HirLambdaValueExpression(
        (expression.valueParameters as Iterable<AstValueParameter>)
          .map<HirLambdaParameter>({ this.lowerParameter(context, it) })
          .toList(),
        (expression.expressions as Iterable<AstExpression>)
          .map<HirValueExpressionUri>({ this.lowerExpression(context, it) })
          .toList(),
      )
    }

    if (expression is AstIdentifierExpression) {
      let expression = (expression as AstIdentifierExpression)
      let name = expression.identifier.name
      let property = this.resolve(context, name)
    }

    if (expression is AstTupleExpression) {
      let expression = (expression as AstTupleExpression)
      return HirTupleValueExpression(
        (expression.expressions as Iterable<AstExpression>)
          .map<HirValueExpressionUri>({ this.lowerExpression(context, it) })
          .toList(),
      )
    }

    if (expression is AstBinaryExpression) {
      let expression = (expression as AstBinaryExpression)
      mut let function = HirFunction.infixEqualEqual(context)
      let name = expression.identifier.name
      if (name == "==") { function = HirFunction.infixEqualEqual(context) }
      if (name == "!=") { function = HirFunction.infixExclamationEqual(context) }
      if (name == "<")  { function = HirFunction.infixLess(context) }
      if (name == "<=") { function = HirFunction.infixLessEqual(context) }
      if (name == ">")  { function = HirFunction.infixGreater(context) }
      if (name == ">=") { function = HirFunction.infixGreaterEqual(context) }
      if (name == "+")  { function = HirFunction.infixPlus(context) }
      if (name == "-")  { function = HirFunction.infixMinus(context) }
      if (name == "*")  { function = HirFunction.infixStar(context) }
      if (name == "/")  { function = HirFunction.infixSlash(context) }
      if (name == "//") { function = HirFunction.infixSlashSlash(context) }
      if (name == "%")  { function = HirFunction.infixPercent(context) }
      if (name == "&")  { function = HirFunction.infixAmpersand(context) }
      if (name == "|")  { function = HirFunction.infixBar(context) }
      if (name == "=>") { function = HirFunction.infixEqualGreater(context) }
      return HirFunctionCallValueExpression(
        this.lowerExpression(expression.leftOperand),
        function,
        Map.empty<String, HirInlineType>(),
        Map.of1<String, HirValueExpressionUri>(this.lowerExpression(expression.rightOperand)),
      )
    }

    if (expression is AstPropertyExpression) {
      let expression = (expression as AstPropertyExpression)
      let uri = this.lowerExpression(context, expression.initializer.unwrap())
      this.localProperties.put(expression.name, uri)
    }

    if (expression is AstNavigationExpression) {
      // This ia an AstNavigationExpression that has is not inside an AstCallExpression â€“ otherwise,
      // the lowering of the surrounding AstCallExpression would have also handled the inner
      // AstNavigationExpression. So, this is a function invocation without any parameters.
      // But that doesn't work for now.
      todo("Function call with omitted parentheses")
    }

    if (expression is AstCallExpression) {
      let expression = (expression as AstCallExpression)
      let receiver = expression.receiver
      let typeArguments = expression.typeArguments
      let valueArguments = expression.valueArguments

      if (receiver is AstIdentifierExpression) {
        // This is a top-level function, defined globally.
        let function = this.resolve(context, name)
        if (function.length() == 1) {
          return HirFunctionCallValueExpression(
            None<HirValueExpressionUri>(), // No receiver.
            function.single(),
            typeArguments.update({
              (this.resolve(context, it.name).single() as HirTypeExpression).type
            }),
            valueArguments.update({
              (this.resolve(context, it.name).single() as HirValueExpressionUri)
            }),
          )
        }
      }
      if (receiver is AstNavigationExpression) {
        // This is a function defined in an impl.
        let function = resolve(context, name)
        if (function.length() == 1) {
          return HirFunctionCallValueExpression(
            Some<HirValueExpressionUri>(this.lowerExpression(receiver)),
            function.single(),
            typeArguments.update({
              (this.resolve(context, it.name).single() as HirTypeExpression).type
            }),
            valueArguments.update({
              (this.resolve(context, it.name).single() as HirValueExpressionUri)
            }),
          )
        }
      }
      todo("Lower lambda")
    }

    if (expression is AstReturnExpression) {
      let expression = (expression as AstReturnExpression)
      let returnValue = expression.value.orElse({ HirExpression.unit(context) })
      return HirReturnValueExpression(
        this.global.function,
        this.lowerExpression(context, returnValue),
      )
    }
  }

  fun lowerParameter(context: QueryContext<List<CompilerError>>, parameter: AstValueParameter): HirLambdaParameter {
    HirLambdaParameter(
      parameter.name.value,
      // TODO(marcelgarus): Support type inference for parameters.
      parameter.type.map<HirInlineType>({ astInlineTypeToHirInlineType(context, it) })
        .expect("Lambda parameter without specified type."),
    )
  }
}
