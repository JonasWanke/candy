use ast
use compiler_utils
use incremental

use ..types
use ...declarations
use ...expressions
use ...types

// These impls make declarative information from the AST available in the HIR.

trait MightNotExist {
  fun doesExist(context: QueryContext<List<CompilerError>>): Bool
}
trait HasAst<Ast> {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<Ast>
}
trait CanBeStatic {
  fun isStatic(context: QueryContext<List<CompilerError>>): Bool
}

fun fileToHirModule(context: QueryContext<List<CompilerError>>, file: FancyFile): HirModule {
  // TODO(never, marcelgarus): Implement this as a static function on `HirModule` (`HirModule fromFile`) as
  // soon as adding static functions through impls works.

  query<HirModule, List<CompilerError>>(context, "HirModule.fromFile", (file as Equals & Hash), {
    mut let path = file.path
    if path.baseNameWithoutExtension() == ".candy" {
      path = path.parent().unwrap()
    }
    let module = ((if path.parent() is None {
      HirTopLevelModule(file.package)
    } else {
      fileToHirModule(context, FancyFile(file.package, path.parent().unwrap()))
        .innerModule(path.baseNameWithoutExtension())
    }) as HirModule)
    Tuple(module, List.empty<CompilerError>())
  })
}

trait HasPackageAndPath {
  fun package(): Package
  fun path(): List<String>
}
impl HirDeclaration: HasPackageAndPath {
  fun package(): Package
  fun path(): List<String>
}
impl HirTopLevelModule: HasPackageAndPath {
  fun package(): Package { this.parent }
  fun path(): List<String> { List.empty<String>() }
}
impl HirInnerModule: HasPackageAndPath {
  fun package(): Package { (this.parent as HasPackageAndPath).package() }
  fun path(): List<String> {
    (this.parent as HasPackageAndPath).path().followedByList(List.of1<String>(this.name()))
  }
}
impl HirTrait: HasPackageAndPath {
  fun package(): Package { (this.parent as HasPackageAndPath).package() }
  fun path(): List<String> {
    (this.parent as HasPackageAndPath).path().followedByList(List.of1<String>(this.name()))
  }
}
impl HirImpl: HasPackageAndPath {
  fun package(): Package { (this.parent as HasPackageAndPath).package() }
  fun path(): List<String> {
    (this.parent as HasPackageAndPath).path().followedByList(List.of1<String>(this.name()))
  }
}
impl HirType: HasPackageAndPath {
  fun package(): Package { (this.parent as HasPackageAndPath).package() }
  fun path(): List<String> {
    (this.parent as HasPackageAndPath).path().followedByList(List.of1<String>(this.name()))
  }
}
impl HirFunction: HasPackageAndPath {
  fun package(): Package { (this.parent as HasPackageAndPath).package() }
  fun path(): List<String> {
    (this.parent as HasPackageAndPath).path().followedByList(List.of1<String>(this.name()))
  }
}

public trait HasDeclarations {
  fun declarations(context: QueryContext<List<CompilerError>>): List<HirDeclaration> {
    /// Returns the child declarations of this declaration.
    ///
    /// Note that some declarations can never have any child declarations (for example, functions or
    /// properties). These always return empty lists.

    this.realDeclarations(context).orElse({ List.empty<HirDeclaration>() })
      .followedByList(this.syntheticDeclarations(context).map<HirDeclaration>({ it.id }).toList())
  }

  fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>>

  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<Any>>
  /// Getter for ast declarations, but type unsafe. Still useful if it's immediately followed by
  /// `whereType()`.

  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration>

  fun syntheticDeclaration(context: QueryContext<List<CompilerError>>): Maybe<HirSyntheticDeclaration> {
    query<Maybe<HirSyntheticDeclaration>, List<CompilerError>>(
      context, "HasDeclarations.syntheticDeclaration", this, {
      if (this.isSynthetic()) {
        let declaration = this.parent
          .syntheticDeclarations(context)
          .singleWhere({ it.id == this })
        assert(
          declaration is Some<HirSyntheticDeclaration>,
          "This should have a synthetic declaration",
        )
        declaration
      } else {
        None<HirSyntheticDeclaration>()
      }
    })
  }
}
impl HirDeclaration: HasDeclarations

public trait HasTypeParameters: Equals & Hash {
  fun typeParameters(context: QueryContext<List<CompilerError>>): List<HirParameterType>
}
fun hirParameterTypesFromAstTypeParameters(
  declaration: HirTrait | HirImpl | HirType | HirFunction,
  typeParameters: List<AstTypeParameter>,
): List<HirParameterType> {
  (typeParameters as Iterable<AstTypeParameter>)
    .map<HirParameterType>({ HirParameterType(declaration, it.name.value) })
    .toList()
}

public trait HasVisibility {
  fun isPublic(context: QueryContext<List<CompilerError>>): Bool
}
public fun isPublicFromModifiers(modifiers: List<AstIdentifier>): Bool {
  // TODO(never, JonasWanke): This should resolve modifier names when we support custom annotations.
  (modifiers as Iterable<AstIdentifier>).any({ it.value == "public" })
}

// TODO(never, marcelgarus): `HirModule`s implement the `HasDeclarations` trait. Because the Dart lowering
// is weird, we can't just add impls to traits (they will be mixed in, but the subclasses only
// implement the trait, losing the specific implementation).
// So, we put the code of the impl into the following few functions, which are used by the concrete
// types `HirTopLevelModule` and `HirInnerModule`, passing themselves as parameters.

fun astOfModule(context: QueryContext<List<CompilerError>>, moduleHir: HirModule): Maybe<AstFile | AstModule> {
  /// Returns the ast of the given `moduleHir`, or `None` if it's synthetic.
  
  query<Maybe<AstFile | AstModule>, List<CompilerError>>(context, "HirModule.ast", (moduleHir as Equals & Hash), {
    // These are all the ways that modules can be declared with decreasing priority:
    //
    // 1. By creating directories.
    // 2. By creating files.
    // 3. By creating inline modules.
    //
    // First, go into directories with correct names as long as possible. Then, look for a file with
    // the name of the next submodule, defaulting to module.candy if it doesn't exist. Finally, read
    // that file and find a inline module nested.

    if ((moduleHir as HirDeclaration).isSynthetic()) {
      return Tuple(None<AstFile | AstModule>(), List.empty<CompilerError>())
    }

    let package = (moduleHir as HasPackageAndPath).package()
    mut let segments = (moduleHir as HasPackageAndPath).path() as Iterable<String>
    mut let path = Path.parse("src")

    // Follow the directory structure down as much as possible.
    while segments.isNotEmpty() {
      // TODO(never, marcelgarus): Move this into the while condition once the && is lazy.
      let newPath = path.child(segments.first().unwrap())
      let resolvedPath = FancyFile(package, newPath).getResolvedPath(context)
      if !Directory(resolvedPath).doesExist() { break unit }

      path = newPath
      segments = segments.skip(1)
    }

    // Choose the correct file, default to ".candy".
    //
    // TODO(never, marcelgarus): Inline the condition into the `if` once the && is lazy.
    mut let condition = segments.isNotEmpty()
    if condition {
      condition = FancyFile(package, path.child("{segments.first().unwrap()}.candy"))
        .doesExist(context)
    }
    if condition {
      path = path.child("{segments.first().unwrap()}.candy")
      segments = segments.skip(1)
    } else {
      path = path.child(".candy")
    }
    if !FancyFile(package, path).doesExist(context) {
      throw "File at {path} doesn't exist."
    }

    let ast = parseAstOfFile(context, FancyFile(package, path)).first
    if segments.isNotEmpty() {
      todo("never, marcelgarus: Support getting the AST of inline modules by navigating through the AST.")
    }

    return Tuple(Some<AstFile | AstModule>(ast), List.empty<CompilerError>())
  })
}
fun astDeclarationsOfModule(
  context: QueryContext<List<CompilerError>>,
  module: HirModule,
): Maybe<List<AstModule | AstTrait | AstImpl | AstType | AstFunction>> {
  query<
    Maybe<List<AstModule | AstTrait | AstImpl | AstType | AstFunction>>,
    List<CompilerError>,
  >(context, "HirModule.astDeclarations", (module as Equals & Hash), {
    let ast = astOfModule(context, module)
    if ast is None<AstFile | AstModule> {
      return Tuple(
        None<List<AstModule | AstTrait | AstImpl | AstType | AstFunction>>(),
        List.empty<CompilerError>(),
      )
    }
    let ast = ast.unwrap()
    let declarations = if (ast is AstFile) {
      (ast as AstFile).declarations
    } else {
      (ast as AstModule).innerDeclarations
    }
    return Tuple(
      Some<List<AstModule | AstTrait | AstImpl | AstType | AstFunction>>(declarations),
      List.empty<CompilerError>(),
    )
  })
}
fun realDeclarationsOfModule(
  context: QueryContext<List<CompilerError>>,
  module: HirModule,
): Maybe<List<HirDeclaration>> {
  query<Maybe<List<HirDeclaration>>, List<CompilerError>>(
    context,
    "HirModule.realDeclarations",
    module as Equals & Hash,
    {
      mut let implDisambiguator = 0
      mut let functionDisambiguator = 0
      astDeclarationsOfModule(context, module)
        .map<List<HirDeclaration>>({
          let declarations = (it as Iterable<AstModule | AstTrait | AstImpl | AstType | AstFunction>)
            .map<HirDeclaration>({
              if (it is AstModule) { return HirInnerModule(module, (it as AstModule).name.value) as HirDeclaration }
              if (it is AstTrait) {
                return HirTrait(module, (it as AstTrait).name.value) as HirDeclaration
              }
              if (it is AstImpl) {
                let impl_ = HirImpl(module, implDisambiguator)
                implDisambiguator = implDisambiguator + 1
                return impl_ as HirDeclaration
              }
              if (it is AstType) { return HirType(module, (it as AstType).name.value) as HirDeclaration }
              if (it is AstFunction) {
                let function = HirFunction(module, (it as AstFunction).name.value, functionDisambiguator)
                functionDisambiguator = functionDisambiguator + 1
                return function as HirDeclaration
              }
              throw "Shouldn't reach this."
            })
            .toMutableList()
          astOfModule(context, module).do({
            if (it is AstFile) {
              for useLine in (it as AstFile).useLines {
                if (useLine.target is AstLocalRelativeUseLineTarget) {
                  let target = (useLine.target as AstLocalRelativeUseLineTarget)
                  if target.parentNavigations == 0 {
                    (target.path as Iterable<AstIdentifier>).single().do({
                      declarations.appendAll(declarationsOfModule(context, module.innerModule(it.value)))
                    })
                  }
                }
              }
            }
          })
          declarations
        })
        .orElse({ (module as HirDeclaration).syntheticDeclarations() })
      Tuple(declarations, List.empty<CompilerError>())
    }
  )
}
fun syntheticDeclarationsOfModule(
  context: QueryContext<List<CompilerError>>,
  module: HirModule,
): List<HirSyntheticDeclaration> {
  query<List<HirSyntheticDeclaration>, List<CompilerError>>(
    context, "HirModule.syntheticDeclarations", module as Equals & Hash, {
    let declarations = this.syntheticDeclaration(context)
      .map<List<HirSyntheticDeclaration>>({ (it as HirSyntheticModule).declarations() })
      .orElse({
        // TODO(never): Run macros.
        List.empty<HirSyntheticDeclaration>()
      })
    Tuple(declarations, List.empty<CompilerError>())
  })
}
impl HirModule: MightNotExist & HasAst<AstFile | AstModule> & HasDeclarations {
  fun doesExist(context: QueryContext<List<CompilerError>>): Bool
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstFile | AstModule>
  fun astDeclarations(
    context: QueryContext<List<CompilerError>>,
  ): List<AstModule | AstTrait | AstImpl | AstType | AstFunction>
  
  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration>
}
impl HirTopLevelModule: MightNotExist & HasAst<AstFile | AstModule> & HasDeclarations {
  fun doesExist(context: QueryContext<List<CompilerError>>): Bool {
    astOfModule(context, this) is Some<AstFile | AstModule>
  }
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstFile | AstModule> {
    astOfModule(context, this)
  }
  fun astDeclarations(
    context: QueryContext<List<CompilerError>>,
  ): List<AstModule | AstTrait | AstImpl | AstType | AstFunction> {
    astDeclarationsOfModule(context, this)
  }
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    astDeclarations(context) as List<Any>
  }
  public fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>> {
    realDeclarationsOfModule(context, this)
  }
  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration> {
    syntheticDeclarationsOfModule(this)
  }
}
impl HirInnerModule: MightNotExist & HasAst<AstFile | AstModule> & HasDeclarations {
  fun doesExist(context: QueryContext<List<CompilerError>>): Bool {
    (this as HirDeclaration).isSynthetic()
      || (astOfModule(context, this) is Some<AstFile | AstModule>)
  }
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstFile | AstModule> {
    astOfModule(context, this)
  }
  fun astDeclarations(
    context: QueryContext<List<CompilerError>>,
  ): List<AstModule | AstTrait | AstImpl | AstType | AstFunction> {
    astDeclarationsOfModule(context, this)
  }
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    astDeclarations(context) as List<Any>
  }
  public fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>> {
    realDeclarationsOfModule(context, this)
  }
  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration> {
    syntheticDeclarationsOfModule(this)
  }
}

impl HirTrait: HasAst<AstTrait> & HasDeclarations & HasTypeParameters & HasVisibility {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstTrait> {
    query<Maybe<AstTrait>, List<CompilerError>>(context, "HirTrait.ast", this, {
      let ast = ((parent as HasDeclarations).typeUnsafeAstDeclarations(context) as Iterable<Any>)
        .whereType<AstTrait>()
        .singleWhere({ it.name.value == name_ })
      Tuple(ast, List.empty<CompilerError>())
    })
  }

  fun astDeclarations(
    context: QueryContext<List<CompilerError>>
  ): List<AstTrait | AstType | AstFunction> {
    query<List<AstTrait | AstType | AstFunction>, List<CompilerError>>(
      context,
      "HirTrait.astDeclarations",
      this,
      { Tuple(ast(context).innerDeclarations, List.empty<CompilerError>()) },
    )
  }
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    astDeclarations(context) as List<Any>
  }

  public fun realDeclarations(
    context: QueryContext<List<CompilerError>>,
  ): Maybe<List<HirDeclaration>> {
    query<Maybe<List<HirDeclaration>>, List<CompilerError>>(
      context,
      "HirTrait.realDeclarations",
      this,
      {
        let declarations = astDeclarations(context).map<List<HirDeclaration>>({
        mut let functionDisambiguator = 0
        (it as Iterable<AstTrait | AstType | AstFunction>)
          .map<HirDeclaration>({
            if (it is AstFunction) {
              let function = HirFunction(this, (it as AstFunction).name.value, functionDisambiguator)
              functionDisambiguator = functionDisambiguator + 1
              return (function as HirDeclaration)
            }
            throw "Shouldn't reach this."
          })
          .toList()
        })
        Tuple(declarations, List.empty<CompilerError>())
      }
    )
  }

  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration> {
    (this.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
      .whereType<HirNamedType>()
      .map<>({
        (it as HirInlineType).allFunctionsWithSubstitutions()
      })
    List.empty<HirSyntheticDeclaration>()
  }

  fun typeParameters(context: QueryContext<List<CompilerError>>): List<HirParameterType> {
    query<List<HirParameterType>, List<CompilerError>>(context, "HirTrait.typeParameters", this, {
      Tuple(
        hirParameterTypesFromAstTypeParameters(this, ast(context).typeParameters),
        List.empty<CompilerError>(),
      )
    })
  }

  fun isPublic(context: QueryContext<List<CompilerError>>): Bool {
    query<Bool, List<CompilerError>>(context, "HirTrait.isPublic", this, {
      Tuple(isPublicFromModifiers(ast(context).modifiers), List.empty<CompilerError>())
    })
  }
}

impl HirImpl: HasAst<AstImpl> & HasDeclarations & HasTypeParameters {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstImpl> {
    query<Maybe<AstImpl>, List<CompilerError>>(context, "HirImpl.ast", this, {
      let ast = ((parent as HasDeclarations).typeUnsafeAstDeclarations(context) as Iterable<Any>)
        .whereType<AstImpl>()
        .get(disambiguator)
      Tuple(ast, List.empty<CompilerError>())
    })
  }

  fun astDeclarations(context: QueryContext<List<CompilerError>>): List<AstFunction> {
    query<List<AstFunction>, List<CompilerError>>(context, "HirImpl.astDeclarations", this, {
      Tuple(ast(context).innerDeclarations, List.empty<CompilerError>())
    })
  }
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    astDeclarations(context) as List<Any>
  }

  public fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>> {
    query<Maybe<List<HirDeclaration>>, List<CompilerError>>(context, "HirImpl.realDeclarations", this, {
      let declarations = ast(context).map<List<HirDeclaration>>({
        mut let functionDisambiguator = 0
        (it.innerDeclarations as Iterable<AstFunction>)
          .map<HirDeclaration>({
            if (it is AstFunction) {
              let function = HirFunction(this, (it as AstFunction).name.value, functionDisambiguator)
              functionDisambiguator = functionDisambiguator + 1
              return (function as HirDeclaration)
            }
            throw "Shouldn't reach this."
          })
          .toList()
      })
      Tuple(declarations, List.empty<CompilerError>())
    })
  }

  fun syntheticDeclarations(context: QueryContext<List<CompilerError>>): List<HirSyntheticDeclaration> {
    if (this.isSynthetic()) { return List.empty<HirSyntheticDeclaration>() }
    it.implementedTrait(context)
      .maybeMap<HirNamedType>({
        if (this is HirErrorType) { return None() }
        Some<HirNamedType>(this as HirNamedType)
      })
      .map<List<HirSyntheticDeclaration>>({
        let trait = (it.declaration as HirTrait)
        let parentFunctions = (trait.declarations(context) as Iterable<HirDeclaration>)
          .cast<HirFunction>()
        let overwrittenFunctions = this.realDeclarations(context)
          .whereType<HirFunction>()
          .map<HirFunction>({ it.parentFunction(context) })
          .toSet()
        let nonOverwrittenFunctions = parentFunctions
          .where({ !overwrittenFunctions.contains(it) })
          .toList()
        let upperBound = trait.upperBound(context)
        let substitutions = upperBound.substitutionMap(context)
        nonOverwrittenFunctions
          .map<HirSyntheticDeclaration>({
            HirSyntheticFunction(
              it,
              it.modifiers,
              it.name.value,
              it.typeParameters(context)
                .map<HirSyntheticTypeParameter>({
                  HirSyntheticTypeParameter(it.name.value, it.upperBound.substitute(substitutions))
                })
                .toList(),
              it.valueParameters(context)
                .map<HirSyntheticValueParameter>({
                  HirSyntheticValueParameter(
                    it.name.value,
                    it.type.substitute(substitutions),
                    it.defaultValue.map<HirSyntheticExpression>({
                      // TODO: Lower default value to HirSyntheticExpressions.
                    }),
                  )
                })
                .toList(),
              it.returnType(context),
              it.body(context), // TODO: Lower to HirSyntheticBody
            )
          })
          .toList()
      })
      .orElse({ List.empty<HirSyntheticDeclaration>() })
  }

  fun typeParameters(context: QueryContext<List<CompilerError>>): List<HirParameterType> {
    query<List<HirParameterType>, List<CompilerError>>(context, "HirImpl.typeParameters", this, {
      Tuple(
        hirParameterTypesFromAstTypeParameters(this, ast(context).typeParameters),
        List.empty<CompilerError>(),
      )
    })
  }

  fun isPublic(context: QueryContext<List<CompilerError>>): Bool {
    query<Bool, List<CompilerError>>(context, "HirImpl.isPublic", this, {
      Tuple(isPublicFromModifiers(ast(context).modifiers), List.empty<CompilerError>())
    })
  }
}

impl HirType: HasAst<AstType> & HasDeclarations & HasTypeParameters & HasVisibility {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstType> {
    query<Maybe<AstType>, List<CompilerError>>(context, "HirType.ast", this, {
      let ast = ((parent as HasDeclarations).typeUnsafeAstDeclarations(context) as Iterable<Any>)
        .whereType<AstType>()
        .where({ it.name.value == name_ })
        .single()
      Tuple(ast, List.empty<CompilerError>())
    })
  }

  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    List.empty<Any>()
  }

  public fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>> {
    query<Maybe<List<HirDeclaration>>, List<CompilerError>>(
      context,
      "HirType.realDeclarations",
      this, {
      let declarations = if (this.isSynthetic() {
        None<List<HirDeclaration>>()
      } else {
        Some<List<HirDeclaration>>(List.empty<HirDeclaration>())
      }
      Tuple(declarations, List.empty<CompilerError>())
    })
  }

  fun typeParameters(context: QueryContext<List<CompilerError>>): List<HirParameterType> {
    query<List<HirParameterType>, List<CompilerError>>(context, "HirType.typeParameters", this, {
      Tuple(
        hirParameterTypesFromAstTypeParameters(this, ast(context).typeParameters),
        List.empty<CompilerError>(),
      )
    })
  }

  fun isPublic(context: QueryContext<List<CompilerError>>): Bool {
    query<Bool, List<CompilerError>>(context, "HirType.isPublic", this, {
      Tuple(isPublicFromModifiers(ast(context).modifiers), List.empty<CompilerError>())
    })
  }
}

impl HirFunction: HasAst<AstFunction> & HasDeclarations & CanBeStatic & HasTypeParameters & HasVisibility {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstFunction> {
    query<Maybe<AstFunction>, List<CompilerError>>(context, "HirFunction.ast", this, {
      let ast = ((parent as HasDeclarations).typeUnsafeAstDeclarations(context) as Iterable<Any>)
        .whereType<AstFunction>()
        .get(disambiguator)
      Tuple(ast, List.empty<CompilerError>())
    })
  }
  
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    List.empty<Any>()
  }
  public fun realDeclarations(context: QueryContext<List<CompilerError>>): Maybe<List<HirDeclaration>> {
    query<Maybe<List<HirDeclaration>>, List<CompilerError>>(
      context,
      "HirFunction.realDeclarations",
      this, {
      let declarations = if (this.isSynthetic() {
        None<List<HirDeclaration>>()
      } else {
        Some<List<HirDeclaration>>(List.empty<HirDeclaration>())
      }
      Tuple(declarations, List.empty<CompilerError>())
    })
  }

  fun isStatic(context: QueryContext<List<CompilerError>>): Bool {
    query<Bool, List<CompilerError>>(context, "HirFunction.isStatic", this, {
      // TODO(never, JonasWanke): This should resolve modifier names when we support custom annotations.
      let modifiers = (ast(context).modifiers as Iterable<AstIdentifier>)
      Tuple(modifiers.any({ it.value == "static" }), List.empty<CompilerError>())
    })
  }

  fun typeParameters(context: QueryContext<List<CompilerError>>): List<HirParameterType> {
    query<List<HirParameterType>, List<CompilerError>>(context, "HirFunction.typeParameters", this, {
      Tuple(
        hirParameterTypesFromAstTypeParameters(this, ast(context).typeParameters),
        List.empty<CompilerError>(),
      )
    })
  }

  fun valueParameters(context: QueryContext<List<CompilerError>>): List<HirValueParameter> {
    query<List<HirValueParameter>, List<CompilerError>>(context, "HirFunction.valueParameters", this, {
      Tuple(
        (ast(context).valueParameters as Iterable<AstValueParameter>)
          .map<HirValueParameter>({ HirValueParameter(this, it.name.value) })
          .toList(),
        List.empty<CompilerError>(),
      )
    })
  }

  fun isPublic(context: QueryContext<List<CompilerError>>): Bool {
    query<Bool, List<CompilerError>>(context, "HirFunction.isPublic", this, {
      Tuple(isPublicFromModifiers(ast(context).modifiers), List.empty<CompilerError>())
    })
  }

  fun parentFunction(context: QueryContext<List<CompilerError>>): Maybe<HirFunction> {
    query<Maybe<HirFunction>, List<CompilerError>>(context, "HirFunction.parentFunction", this, {
      let parentIsImplWithoutTrait = this.parent is HirImpl
        && (this.parent as HirImpl).implementedTrait(context) is None<HirInlineType>
      if (this.parent is HirModule || parentIsImplWithoutTrait) {
        return Tuple(None<HirFunction>(), List.empty<CompilerError>())
      }

      let parentType = if (this.parent is HirTrait) {
        (this.parent as HirTrait).upperBound(context)
      } else {
        (this.parent as HirImpl).implementedTrait(context).unwrap()
      }
      let parentType = (parentType as HirNamedType)
      assert(parentType.declaration is HirTrait, "Impls can only implement traits")

      let scope = this.package()
      let substitutionMap = parentType.substitutionMap(context)
      let valueParameters = this.valueParameters(context)
      let returnType = this.returnType(context)
      let functionCandidates = parentType
        .instanceFunctions(context, scope)
        .items()
        .where({
          if (!(it.name() == this.name())) {
            return false
          }
          let otherReturnType = it.returnType(context)
          if (!isAssignableTo(context, returnType, otherReturnType, scope)) {
            return false
          }
          let otherValueParameters = it.valueParameters(context)
          if (!((valueParameters as Iterable<HirValueParameter>).length() == (otherValueParameters as Iterable<HirValueParameter>).length())) {
            return false
          }
          valueParameters
            .zip(otherValueParameters as Iterable<HirValueParameter>)
            .all({
              let parameter = it.first
              let otherParameter = it.second
              parameter.name == otherParameter.name
                && isAssignableTo(context, otherParameter.type(context), parameter.type(context), scope)
            })
        })
        .toList()
      let functionCandidates = (functionCandidates as Iterable<HirFunction>)

      if (functionCandidates.length() > 1) {
        return Tuple(
          Some<HirFunction>(functionCandidates.first().unwrap()),
          List.of1<CompilerError>(TraitsWithConflictingFunctionsImplementedCompilerError(this)),
        )
      }
      Tuple(functionCandidates.single(), List.empty<CompilerError>())
    })
  }
}

public class TraitsWithConflictingFunctionsImplementedCompilerError {
  public let function: HirFunction
}
impl TraitsWithConflictingFunctionsImplementedCompilerError: CompilerError {
  public fun id(): String { "traits-with-conflicting-functions-implemented" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement TraitsWithConflictingFunctionsImplementedCompilerError.location")
  }
  public fun title(): String { "A function matches multiple functions in parent traits: {this.function}" }
  public fun description(): String {
    /// TODO(never, marcelgarus): add a description for this error
    ""
  }
}


impl HirValueParameter: HasAst<AstValueParameter> {
  fun ast(context: QueryContext<List<CompilerError>>): Maybe<AstValueParameter> {
    query<Maybe<AstValueParameter>, List<CompilerError>>(context, "HirValueParameter.ast", this, {
      if (this.scope is HirValueExpressionUri) {
        todo("never, Implement HirValueParameter.ast(…) for lambda parameters")
      }

      let ast = ((scope as HirFunction).ast(context)
        .flatMap<AstValueParameter>({
          it.valueParameters as Iterable<AstValueParameter>)
            .singleWhere({ it.name.value == this.name })
        })
      Tuple(ast, List.empty<CompilerError>())
    })
  }

  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    query<HirInlineType, List<CompilerError>>(context, "HirValueParameter.type", this, {
      if (this.scope is HirValueExpressionUri) {
        todo("never, Implement HirValueParameter.type(…) for lambda parameters")
      }

      let inlineType = (this.scope as HirFunction).syntheticDeclaration()
        .map<HirInlineType>({
          it.valueParameters
            .singleWhere({ it.name == this.name })
            .unwrap()
            .type
        })
        .orElse({
          astInlineTypeToHirInlineType(
            context,
            this.ast(context).unwrap().type.unwrap(),
            this.scope as HirFunction,
          )
        })
      Tuple(inlineType, List.empty<CompilerError>())
    })
  }
}

impl HirInlineType {
  fun allFunctionsWithSubstitutions(context: QueryContext<List<CompilerError>>, scope: Package): Set<(HirFunction, Map<HirInlineType, HirInlineType)> {
    query<Set<(HirFunction, Map<HirInlineType, HirInlineType)>, List<CompilerError>>(
      context, "HirInlineType.allFunctionsWithSubstitutions", DataTuple2<HirInlineType, Package>(this, scope), {
      let result = getAllImplsWithSubstitutionsFor(context, this, scope)
        .expand<(HirFunction, Map<HirInlineType, HirInlineType>)>({
          (it.first.declarations(context) as Iterable<HirDeclaration>)
            .whereType<HirFunction>()
            .map<(HirFunction, Map<HirInlineType, HirInlineType>)>()
            .toSet()
        })
      Tuple(result, List.empty<CompilerError>())
    })
  }

  fun staticFunctionsWithSubstitutions(context: QueryContext<List<CompilerError>>, scope: Package): Set<(HirFunction, Map<HirInlineType, HirInlineType>)> {
    query<Set<(HirFunction, Map<HirInlineType, HirInlineType>)>, List<CompilerError>>(
      context, "HirInlineType.staticFunctionsWithSubstitutions", DataTuple2<HirInlineType, Package>(this, scope), {
      this.allFunctionsWithSubstitutions(context, scope).items().where({ it.first.isStatic(context) }).toSet()
    })
  }

  fun instanceFunctionsWithSubstitutions(context: QueryContext<List<CompilerError>>, scope: Package): Set<(HirFunction, Map<HirInlineType, HirInlineType>)> {
    query<Set<(HirFunction, Map<HirInlineType, HirInlineType>)>, List<CompilerError>>(
      context, "HirInlineType.instanceFunctionsWithSubstitutions", DataTuple2<HirInlineType, Package>(this, scope), {
      this.allFunctionsWithSubstitutions(context, scope).items().where({ !it.first.isStatic(context) }).toSet()
    })
  }

  fun instanceFunctionsWithSubstitutionsMatchingName(context: QueryContext<List<CompilerError>>, name: String, scope: Package): Set<(HirFunction, Map<HirInlineType, HirInlineType>)> {
    query<Set<(HirFunction, Map<HirInlineType, HirInlineType>)>, List<CompilerError>>(
      context, "HirInlineType.instanceFunctionsWithSubstitutionsMatchingName",
      DataTuple3<HirInlineType, String, Package>(this, name, scope), {
      this.instanceFunctionsWithSubstitutions(context, scope).items().where({ it.first.name() == name }).toSet()
    })
  }

  fun leafInstanceFunctionsWithSubstitutionsMatchingName(
    context: QueryContext<List<CompilerError>>,
    name: String,
    scope: Package,
  ): Set<(HirFunction, Map<String, HirInlineType>)> {
    query<Set<(HirFunction, Map<String, HirInlineType>)>, List<CompilerError>>(
      context, "HirInlineType.leafInstanceFunctionsWithSubstitutionsMatchingName",
      DataTuple3<HirInlineType, String, Package>(this, name, scope), {
      let functions = this.instanceFunctionsWithSubstitutionsMatchingName(context, name, scope)
      let parentFunctions = functions.items()
        .map<HirFunction>({ it.first.parentFunction(context) })
        .toSet()
      let functions = functions.items()
        .whereNot({ parentFunction.contains(it) })
        .toSet()
      Tuple(functions, List.empty<CompilerError>())
    })
  }
}
