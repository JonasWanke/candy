use ast
use compiler_utils
use incremental

use ...declarations
use ...types
use ..declarations

/// These impls make type system information available.

impl HirReflectionType: HasDeclarations {
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    List.empty<Any>()
  }
  public fun declarations(context: QueryContext<List<CompilerError>>): List<HirDeclaration> {
    List.empty<HirDeclaration>()
  }
}

// TODO(marcelgarus): Convert this into extension methods on Ast as soon as impls for types from
// other packages work.
fun astInlineTypeToHirInlineType(
  context: QueryContext<List<CompilerError>>,
  astType: AstInlineType,
  scope: HirDeclaration,
): HirInlineType {
  todo("Implement")
}

// TODO(marcelgarus): Convert this into extension methods on Ast as soon as impls for types from
// other packages work.
fun astTypeToHirType(
  context: QueryContext<List<CompilerError>>,
  astType: AstType,
  scope: HirDeclaration,
): HirType {
  query<HirType, List<CompilerError>>(
    context,
    "AstType.hir",
    DataTuple2<AstType, HirDeclaration>(astType, scope) as Equals & Hash,
    {
      if (astType is AstNamedType) {
        let nameParts = ((astType as AstNamedType).nameParts as Iterable<AstIdentifier>)
          .map<String>({ it.value })

        // Try to find the first part of the `nameParts`. Then, find children inside its
        // declarations.
        // TODO(marcelgarus): When resolving `Foo Bar`, we currently accept a `Bar` next to `Foo` if
        // `Foo` itself doesn't contain a `Bar`, as the resolver traverses parent scopes.
        mut let candidates = nameParts.first().unwrap().resolveIdentifier(context, scope)
        for namePart in nameParts.skip(1) {
          candidates = ((candidates as Iterable<HirDeclaration>)
            .expand<HirDeclaration>({
              namePart.resolveIdentifier(context, it) as Iterable<HirDeclaration>
            })
            .toSet() as Set<HirType | HirTrait | HirProperty | HirFunction | HirModule>)
        }

        // There should only be one candidate left.
        let declaration = (candidates as Iterable<HirDeclaration>).single().unwrap()
        assert((declaration is HirType) || (declaration is HirTrait), "Declaration should be HirType or HirTrait.")

        return Tuple(
          HirNamedType(
            declaration as HirTrait | HirType,
            ((astType as AstNamedType).typeArguments as Iterable<AstTypeArgument>)
              .map<HirType>({ astInlineTypeToHirInlineType(context, it.type, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstFunctionType) {
        return Tuple(
          HirFunctionType(
            (astType as AstFunctionType).receiverType
              .map<HirType>({ astTypeToHirType(context, it, scope) }),
            ((astType as AstFunctionType).parameterTypes as Iterable<AstType>)
              .map<HirType>({ astTypeToHirType(context, it, scope) })
              .toList(),
            astTypeToHirType(context, (astType as AstFunctionType).returnType, scope),
          ),
          List.empty<CompilerError>()
        )
      }

      if (astType is AstTupleType) {
        return Tuple(
          HirTupleType(
            ((astType as AstTupleType).types as Iterable<AstType>)
              .map<HirType>({ astTypeToHirType(context, it, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstUnionType) {
        return Tuple(
          HirUnionType(
            ((astType as AstUnionType).types as Iterable<AstType>)
              .map<HirType>({ astTypeToHirType(context, it, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstIntersectionType) {
        return Tuple(
          HirIntersectionType(
            ((astType as AstIntersectionType).types as Iterable<AstType>)
              .map<HirType>({ astTypeToHirType(context, it, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      todo("Implement astTypeToHirType for {astType}")
    }
  )
}

fun getAllImpls(context: QueryContext<List<CompilerError>>): List<HirImpl> {
  todo("Implement getAllImpls")
}

fun makeSureImplsAreNotConflicting(context: QueryContext<List<CompilerError>>) {
  query<HirType, List<CompilerError>>( context, "HirType.implements", this as Equals & Hash, {
    for implsForSameTrait in getAllImpls(context).groupBy({ it.trait_ }).values() {
      for impl1 in implsForSameTrait {
        for impl2 in implsForSameTrait {
          let unified = impl1.type.unify(impl2.type)
          if unified is Some {
            // Unifying the impl types succeeded. This means there's a type to which both impls
            // apply. That's bad.
            impl1.type.substitute(unified.unwrap())
            return Tuple(
              unit,
              ConflictingImplsCompilerError(
                impl1,
                impl2,
                unified,
              )
            )
          }
        }
      }
    }
  })
}

public class ConflictingImplsCompilerError {
  public let impl1: HirImpl
  public let impl2: HirImpl
  public let conflictingType: HirType
}
impl ConflictingImplsCompilerError: CompilerError {
  public fun id(): String { "conflicting-impls" }

  public fun location(): Location {
    Location(file, node.cast<CstDeclarationWithName>().child.name.unwrap().child.span)
  }
  public fun title(): String { "Conflicting impls." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}
