use ast
use compiler_utils
use incremental

use ...declarations
use ...types
use ..declarations

/// These impls make type system information available.

impl HirReflectionType: HasDeclarations {
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    List.empty<Any>()
  }
  public fun declarations(context: QueryContext<List<CompilerError>>): List<HirDeclaration> {
    List.empty<HirDeclaration>()
  }
}

// TODO(marcelgarus): Convert this into extension methods on Ast as soon as impls for types from
// other packages work.
fun astInlineTypeToHirInlineType(
  context: QueryContext<List<CompilerError>>,
  astType: AstInlineType,
  scope: HirDeclaration,
): HirInlineType {
  query<HirInlineType, List<CompilerError>>(
    context,
    "astInlineTypeToHirInlineType",
    DataTuple2<AstInlineType, HirDeclaration>(astType, scope) as Equals & Hash,
    {
      if (astType is AstNamedType) {
        let nameParts = ((astType as AstNamedType).nameParts as Iterable<AstIdentifier>)
          .map<String>({ it.value })

        // Try to find the first part of the `nameParts`. Then, find children inside its
        // declarations.
        // TODO(marcelgarus): When resolving `Foo Bar`, we currently accept a `Bar` next to `Foo` if
        // `Foo` itself doesn't contain a `Bar`, as the resolver traverses parent scopes.
        mut let candidates = nameParts.first().unwrap().resolveIdentifier(context, scope)
        for namePart in nameParts.skip(1) {
          candidates = ((candidates as Iterable<HirDeclaration>)
            .expand<HirDeclaration>({
              namePart.resolveIdentifier(context, it) as Iterable<HirDeclaration>
            })
            .toSet() as Set<HirType | HirTrait | HirFunction | HirModule>)
        }

        // There should be exactly one candidate left.
        if (candidates as Iterable).isEmpty() {
          return Tuple(
            HirErrorType(),
            List.of1<CompilerError>(UnknownTypeCompilerError(astType as AstNamedType)),
          )
        }
        if (candidates as Iterable).length() > 1 {
          return Tuple(
            HirErrorType(),
            List.of1<CompilerError>(
              // This cast from `Set<HirType | HirTrait | HirFunction | HirModule>` to
              // `Set<HirType | HirTrait | HirModule>`succeeds because the name is uppercase, so no
              // functions get resolved.
              AmbiguousTypeCompilerError(candidates as Set<HirType | HirTrait | HirModule>),
            ),
          )
        }
        let declaration = (candidates as Iterable<HirDeclaration>).single().unwrap()
        assert((declaration is HirType) || (declaration is HirTrait), "Declaration should be HirType or HirTrait.")

        let types = ((astType as AstNamedType).typeArguments as Iterable<AstTypeArgument>)
          .map<HirInlineType>({
            it.type
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .orElse({ HirErrorType() })
          })
          .toList()
        return Tuple(
          HirNamedType((declaration as HirTrait | HirType), types),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstFunctionType) {
        return Tuple(
          HirFunctionType(
            (astType as AstFunctionType).receiverType
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) }),
            ((astType as AstFunctionType).parameterTypes as Iterable<AstInlineType>)
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .toList(),
            astInlineTypeToHirInlineType(context, (astType as AstFunctionType).returnType, scope),
          ),
          List.empty<CompilerError>()
        )
      }

      if (astType is AstTupleType) {
        return Tuple(
          HirTupleType(
            ((astType as AstTupleType).types as Iterable<AstInlineType>)
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstNamedTupleType) {
        return Tuple(
          HirNamedTupleType(
            ((astType as AstNamedTupleType).types as Iterable<AstNamedTupleTypeField>)
              .map<(String, HirInlineType)>({
                Tuple(it.name.value, astInlineTypeToHirInlineType(context, it.type, scope))
              })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstEnumType) {
        let loweredVariants = ((astType as AstEnumType).variants as Iterable<AstEnumTypeVariant>)
          .map<(String, Maybe<HirInlineType>)>({
            let valueType = it.valueType.map<HirInlineType>({ valueType =>
              astInlineTypeToHirInlineType(context, valueType, scope)
            })
            Tuple(it.name.value, valueType)
          })
          .toList()
        return Tuple(
          HirEnumType(
            (loweredVariants as Iterable<(String, Maybe<HirInlineType>)>)
              .unsafeToMap<String, Maybe<HirInlineType>>(),
          ),
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstIntersectionType) {
        return Tuple(
          HirIntersectionType(
            ((astType as AstIntersectionType).types as Iterable<AstInlineType>)
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .toList(),
          ),
          List.empty<CompilerError>(),
        )
      }

      todo("Implement astInlineTypeToHirInlineType for {astType}")
    }
  )
}

fun getAllImpls(context: QueryContext<List<CompilerError>>): List<HirImpl> {
  todo("Implement getAllImpls")
}

fun makeSureImplsAreNotConflicting(context: QueryContext<List<CompilerError>>) {
  query<HirType, List<CompilerError>>( context, "HirType.implements", unit as Equals & Hash, {
    todo("Implement makeSureImplsAreNotConflicting")
    // for implsForSameTrait in (getAllImpls(context) as Iterable<HirImpl>).groupBy({ it.trait_ }).values() {
    //   for impl1 in implsForSameTrait {
    //     for impl2 in implsForSameTrait {
    //       let unified = impl1.type.unify(impl2.type)
    //       if unified is Some {
    //         // Unifying the impl types succeeded. This means there's a type to which both impls
    //         // apply. That's bad.
    //         impl1.type.substitute(unified.unwrap())
    //         return Tuple(
    //           unit,
    //           ConflictingImplsCompilerError(
    //             impl1,
    //             impl2,
    //             unified,
    //           )
    //         )
    //       }
    //     }
    //   }
    // }
  })
}

impl HirType {
  fun implFor(context: QueryContext<List<CompilerError>>, trait_: HirTrait): Maybe<HirImpl> {
    query<Maybe<HirImpl>, List<CompilerError>>( context, "HirType.implements", this as Equals & Hash, {
      todo("Implement HirType.implFor")
      // let impls = (getAllImpls(context) as Iterable<HirImpl>).where({ it.trait_ == trait_ }).where({
      //   it.type_.unify(this) is Some
      // })
    })
  }
}

public class ConflictingImplsCompilerError {
  public let impl1: HirImpl
  public let impl2: HirImpl
  public let conflictingType: HirType
}
impl ConflictingImplsCompilerError: CompilerError {
  public fun id(): String { "conflicting-impls" }

  public fun location(): Location {
    todo("Implement ConflictingImplsCompilerError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Conflicting impls." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}

public class AmbiguousTypeCompilerError {
  public let candidates: Set<HirType | HirTrait | HirModule>
}
impl AmbiguousTypeCompilerError: CompilerError {
  public fun id(): String { "ambiguous-type" }

  public fun location(): Location {
    todo("Implement AmbiguousTypeCompilerError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Ambiguous type. Candidates are {candidates}." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}

public class UnknownTypeCompilerError {
  public let astType: AstNamedType
}
impl UnknownTypeCompilerError: CompilerError {
  public fun id(): String { "could-not-resolve-type" }

  public fun location(): Location {
    todo("Implement UnknownTypeCompilerError.location") // TODO(marcelgarus)
  }
  public fun title(): String { "Couldn't resolve type {astType.nameParts}." }
  public fun description(): String {
    /// TODO(marcelgarus): add a description for this error
    ""
  }
}
