use ast
use compiler_utils
use incremental

use ...declarations
use ...expressions
use ...types
use ...solver
use ..declarations
use ..resolving

/// These impls make type system information available.

impl HirReflectionType: HasDeclarations {
  fun typeUnsafeAstDeclarations(context: QueryContext<List<CompilerError>>): List<Any> {
    List.empty<Any>()
  }
  public fun declarations(context: QueryContext<List<CompilerError>>): List<HirDeclaration> {
    List.empty<HirDeclaration>()
  }
}

// TODO(never, marcelgarus): Convert this into extension methods on Ast as soon as impls for types from
// other packages work.
public fun astInlineTypeToHirInlineType(
  context: QueryContext<List<CompilerError>>,
  astType: AstInlineType,
  scope: HirDeclaration,
): HirInlineType {
  query<HirInlineType, List<CompilerError>>(
    context,
    "astInlineTypeToHirInlineType",
    DataTuple2<AstInlineType, HirDeclaration>(astType, scope) as Equals & Hash,
    {
      if (astType is AstNamedType) {
        let nameParts = ((astType as AstNamedType).nameParts as Iterable<AstIdentifier>)
          .map<String>({ it.value })

        if ((nameParts as Iterable).length() == 1) {
          if (nameParts as Iterable<String>).first().unwrap() == "This" {
            if (scope is HirTrait || scope is HirImpl) {
              return Tuple(
                HirThisType(scope as HirTrait | HirImpl) as HirInlineType,
                List.empty<CompilerError>(),
              )
            } else {
              return Tuple(
                HirErrorType() as HirInlineType,
                List.of1<CompilerError>(
                  ThisTypeCanOnlyBeUsedInImplOrTraitCompilerError((astType as AstNamedType), scope),
                ),
              )
            }
          }
        }

        // Try to find the first part of the `nameParts`. Then, find children inside its
        // declarations.
        // TODO(never, marcelgarus): When resolving `Foo Bar`, we currently accept a `Bar` next to `Foo` if
        // `Foo` itself doesn't contain a `Bar`, as the resolver traverses parent scopes.
        mut let candidates = resolveIdentifier(context, nameParts.first().unwrap(), scope)
        for namePart in nameParts.skip(1) {
          candidates = (candidates as Iterable<HirDeclaration>)
            .expand<HirModule | HirType | HirTrait | HirFunction | HirParameterType>({
              if (it is HirDeclaration) {
                resolveIdentifier(context, namePart, it).items()
              } else {
                List.empty<HirModule | HirType | HirTrait | HirFunction | HirParameterType>()
              }
            })
            .toSet()
        }
        let candidates = candidates.items()
          .where({ !(it is HirModule) })
          // This cast from `HirType | HirTrait | HirFunction | HirParameterType` to
          // `HirType | HirTrait | HirParameterType` succeeds because the name is uppercase, so no
          // functions get resolved.
          .cast<HirType | HirTrait | HirParameterType>()
          .toSet()

        // There should be exactly one candidate left.
        if (candidates.items() as Iterable).isEmpty() {
          return Tuple(
            HirErrorType() as HirInlineType,
            List.of1<CompilerError>(UnknownTypeCompilerError(astType as AstNamedType)),
          )
        }
        if (candidates.items() as Iterable).length() > 1 {
          return Tuple(
            HirErrorType() as HirInlineType,
            List.of1<CompilerError>(
              AmbiguousTypeCompilerError(
                candidates as Set<HirModule | HirType | HirTrait | HirParameterType>,
              ),
            ),
          )
        }
        let candidate = (candidates.items() as Iterable<HirType | HirTrait | HirParameterType>).single().unwrap()
        if (candidate is HirParameterType) {
          return Tuple(candidate as HirParameterType, List.empty<CompilerError>())
        }
        let declaration = (candidate as HirTrait | HirType)

        let types = ((astType as AstNamedType).typeArguments as Iterable<AstTypeArgument>)
          .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it.type, scope) })
          .toList()
        return Tuple(HirNamedType(declaration, types) as HirInlineType, List.empty<CompilerError>())
      }

      if (astType is AstFunctionType) {
        return Tuple(
          HirFunctionType(
            (astType as AstFunctionType).receiverType
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) }),
            ((astType as AstFunctionType).parameterTypes as Iterable<AstInlineType>)
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .toList(),
            astInlineTypeToHirInlineType(context, (astType as AstFunctionType).returnType, scope),
          ) as HirInlineType,
          List.empty<CompilerError>()
        )
      }

      if (astType is AstStructType) {
        return Tuple(
          HirStructType(
            ((astType as AstStructType).types as Iterable<AstStructTypeField>)
              .map<(String, HirInlineType)>({
                Tuple(it.name.value, astInlineTypeToHirInlineType(context, it.type, scope))
              })
              .toList(),
          ) as HirInlineType,
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstEnumType) {
        let loweredVariants = ((astType as AstEnumType).variants as Iterable<AstEnumTypeVariant>)
          .map<(String, HirInlineType)>({
            let valueType = it.valueType
              .map<HirInlineType>({ valueType =>
                astInlineTypeToHirInlineType(context, valueType, scope)
              })
              .orElse({ HirNamedType.coreNothing(context) })
            Tuple(it.name.value, valueType)
          })
          .toList()
        return Tuple(
          HirEnumType(
            (loweredVariants as Iterable<(String, HirInlineType)>)
              .unsafeToMap<String, HirInlineType>(),
          ) as HirInlineType,
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstIntersectionType) {
        return Tuple(
          HirIntersectionType(
            ((astType as AstIntersectionType).types as Iterable<AstInlineType>)
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, scope) })
              .toList(),
          ) as HirInlineType,
          List.empty<CompilerError>(),
        )
      }

      if (astType is AstErrorType) {
        return Tuple(HirErrorType(), List.empty<CompilerError>())
      }

      throw "Unknown AST type: {astType}"
    }
  )
}

impl HirParameterType {
  fun upperBound(context: QueryContext<List<CompilerError>>): HirInlineType {
    query<HirInlineType, List<CompilerError>>(context, "HirParameterType.upperBound", this, {
      let ast = (this.declaration as HasAst).ast(context)
      let upperBound = ast.map({
        let astTypeParameter = ((it as AstWithTypeParameters)
          .typeParameters as Iterable<AstTypeParameter>)
          .singleWhere({ it.name.value == this.name })
          .unwrap()
        astTypeParameter.upperBound
          .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, this.declaration) })
          .orElse({ HirNamedType.coreAny(context) })
      }).orElse({
        let declaration = this.syntheticDeclarations(context).unwrap()
        if (declaration is HirSyntheticTrait) {
          return (declaration as HirSyntheticTrait).typeParameters.singleWhere({ it.name == this.name }).unwrap()
        }
        if (declaration is HirSyntheticImpl) {
          return (declaration as HirSyntheticImpl).typeParameters.singleWhere({ it.name == this.name }).unwrap()
        }
        if (declaration is HirSyntheticType) {
          return (declaration as HirSyntheticType).typeParameters.singleWhere({ it.name == this.name }).unwrap()
        }
        if (declaration is HirSyntheticFunction) {
          return (declaration as HirSyntheticFunction).typeParameters.singleWhere({ it.name == this.name }).unwrap()
        }
        throw "Unknown synthetic declaration: {declaration}"
      })
      Tuple(upperBound, List.empty<CompilerError>())
    })
  }
}

impl HirTrait {
  fun thisType(context: QueryContext<List<CompilerError>>): HirNamedType {
    query<HirNamedType, List<CompilerError>>(context, "HirTrait.thisType", this, {
      Tuple(
        HirNamedType(this, this.typeParameters(context)),
        List.empty<CompilerError>(),
      )
    })
  }
  fun upperBound(context: QueryContext<List<CompilerError>>): List<HirNamedType | HirErrorType> {
    // TODO(never): return a set, not a list
    query<HirInlineType, List<CompilerError>>(context, "HirTrait.upperBound", this, {
      let upperBounds = this.ast(context)
        .upperBound
        .map<List<HirNamedType | HirErrorType>>({
          let rawUpperBound = astInlineTypeToHirInlineType(context, it, this)
          if (rawUpperBound is HirNamedType || rawUpperBound is HirErrorType) {
            return List.of1<HirNamedType | HirErrorType>(rawUpperBound as HirNamedType | HirErrorType)
          }
          if (rawUpperBound is HirIntersectionType) {
            return rawUpperBound.types
              .map<HirNamedType | HirErrorType>({
                if (it is HirNamedType || it is HirErrorType) {
                  return (it as HirNamedType | HirErrorType)
                }
                throw "Unexpected type in upper bound of trait {this}: `{it}`."
              })
              .toList()
          }
          throw "Upper bound of trait {this} is invalid: `{rawUpperBound}`."
        })
        .orElse({ List.empty<HirNamedType | HirErrorType>() })
        .followedByList(List.of1<HirNamedType | HirErrorType>(HirNamedType.coreAny(context)))
        .toSet()
        .toList()
      Tuple(upperBounds, List.empty<CompilerError>())
    })
  }
}

impl HirImpl {
  fun constraints(context: QueryContext<List<CompilerError>>): Map<HirParameterType, HirInlineType> {
    // The type constraints of an impl. For example, `impl[T: Equals] Foo[T]: Equals` has the
    // constraints `T: Equals`.

    query<Map<HirParameterType, HirInlineType>, List<CompilerError>>(
      context, "HirImpl.constraints", this, {
      Tuple(
        (this.typeParameters(context) as Iterable<HirParameterType>)
          .map<(HirParameterType, HirInlineType)>({ Tuple(it, it.upperBound(context)) })
          .unsafeToMap<HirParameterType, HirInlineType>(),
        List.empty<CompilerError>(),
      )
    })
  }

  fun baseType(context: QueryContext<List<CompilerError>>): HirNamedType | HirErrorType {
    // The base type of an impl. For example, `impl Foo[Int]` has the base type `Foo[Int]`.

    query<HirNamedType, List<CompilerError>>(context, "HirImpl.baseType", this as Equals & Hash, {
      Tuple(
        this.syntheticDeclaration(context)
          .map<HirNamedType | HirErrorType>({ it.baseType })
          .orElse({
            astInlineTypeToHirInlineType(context, this.ast(context).type, this) as HirNamedType | HirErrorType
          }),
        List.empty<CompilerError>(),
      )
    })
  }

  fun implementedTrait(context: QueryContext<List<CompilerError>>): Maybe<HirInlineType> {
    // TODO(never): tighten the return type to `HirErrorType | HirNamedType`
    // The implemented trait of this impl. For example, `impl Foo: Equals` implements trait
    // `Equals`, whereas `impl Foo { ... }` implements none.

    query<Maybe<HirInlineType>, List<CompilerError>>(context, "HirImpl.implementedTrait", this as Equals & Hash, {
      if (this.isSynthetic()) {
        return Tuple(
          this.syntheticDeclaration(context).unwrap().implementedTrait,
          List.empty<CompilerError>(),
        )
      }

      let traits = this.ast(context).unwrap().traits
      if !((traits as Iterable).length() == 1) {
        // TODO(never, marcelgarus): Support impls for more than one trait.
        return Tuple(
          None<HirInlineType>(),
          List.empty<CompilerError>(
            // UnsupportedFeatureCompilerError(
            //   Some<Location>(Location(, Span(0, 1))),
            //   "This impl is for more than one trait: {this}",
            // ),
          ),
        )
      }
      Tuple(
        Some<HirInlineType>(
          astInlineTypeToHirInlineType(
            context,
            (traits as Iterable).cast<AstInlineType>().single().unwrap(),
            // TODO(never, marcelgarus): Directly cast this into a `Iterable<AstInlineType>` when the Dart
            // type system gets good enough.
            this,
          ),
        ),
        List.empty<CompilerError>(),
      )
    })
  }
}

impl HirType {
  fun thisType(context: QueryContext<List<CompilerError>>): HirInlineType {
    query<HirInlineType, List<CompilerError>>(context, "HirTrait.thisType", this, {
      Tuple(
        HirNamedType(this, this.typeParameters(context)),
        List.empty<CompilerError>(),
      )
    })
  }
  fun type(context: QueryContext<List<CompilerError>>): Maybe<HirInlineType> {
    query<Maybe<HirInlineType>, List<CompilerError>>(context, "HirType.type", this, {
      Tuple(
        this.syntheticDeclaration(context)
          .map<Maybe<HirInlineType>>({ Some<HirInlineType>(it.type) })
          .orElse({
            this.ast(context).unwrap().type
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, this) })
          }),
        List.empty<CompilerError>(),
      )
    })
  }
}

impl HirFunction {
  fun thisType(context: QueryContext<List<CompilerError>>): Maybe<HirThisType> {
    query<HirInlineType, List<CompilerError>>(context, "HirFunction.thisType", this, {
      Tuple(
        if (this.parent is HirTrait | HirImpl && !this.isStatic(context)) {
          Some<HirThisType>(HirThisType(this.parent as HirTrait | HirImpl))
        } else {
          None<HirThisType>()
        },
        List.empty<CompilerError>(),
      )
    })
  }
  fun returnType(context: QueryContext<List<CompilerError>>): HirInlineType {
    query<HirInlineType, List<CompilerError>>(context, "HirFunction.returnType", this, {
      Tuple(
        this.syntheticDeclaration(context)
          .map<HirInlineType>({ it.returnType })
          .orElse({
            this.ast(context).returnType
              .map<HirInlineType>({ astInlineTypeToHirInlineType(context, it, this) })
              .orElse({ HirNamedType.coreNothing(context) })
          }),
        List.empty<CompilerError>(),
      )
    })
  }
}

fun getAllImplsInScope(context: QueryContext<List<CompilerError>>, scope: Package): Set<HirImpl> {
  query<Set<HirImpl>, List<CompilerError>>(context, "getAllImplsInScope", scope as Equals & Hash, {
    let impls = (scope.getAllPackagesInCompilationOrder(context) as Iterable<Package>)
      .map<Set<HirImpl>>({ package => getAllImplsOfModule(context, HirTopLevelModule(package)) })
      .foldLeft<Set<HirImpl>>(Set.empty<HirImpl>(), { a, b => a.union(b) })
    Tuple(impls, List.empty<CompilerError>())
  })
}
fun getAllImplsOfModule(context: QueryContext<List<CompilerError>>, module: HirModule): Set<HirImpl> {
  query<Set<HirImpl>, List<CompilerError>>(context, "getAllImplsOfModule", module as Equals & Hash, {

    let declarations = (declarationsOfModule(context, module) as Iterable<HirDeclaration>)
    let impls = declarations
      .whereType<HirModule>()
      .expand<HirImpl>({ (getAllImplsOfModule(context, it) as Iterable<HirImpl>) })
      .followedBy(declarations.whereType<HirImpl>())
      .toSet()
    Tuple(impls, List.empty<CompilerError>())
  })
}

fun hirImplToSolverRules(
  context: QueryContext<List<CompilerError>>,
  hirImpl: HirImpl,
): Set<SolverRule> {
  query<Set<SolverRule>, List<CompilerError>>(
    context,
    "hirImplToSolverRules",
    hirImpl as Equals & Hash, {
    // Lower the constraints. For example, in the impl `impl[T: Equals] Foo[T]: Equals`, the
    // `solverConstraints` are a list containing `Equals(?T)`.
    let rules = MutableSet.empty<SolverRule>()
    let solverConstraints = MutableList.empty<SolverGoal>()
    for constraint in hirImpl.constraints(context).entries() {
      let result = hirInlineTypeToSolverTypeAndGoalsAndRules(context, constraint.second)
      rules.addAll(result.third.items())
      solverConstraints.appendAll(
        (result.second as Iterable<SolverGoal>).map<SolverGoal>({
          it.substituteAll(
            Map.of1<SolverVariable, SolverType>(
              Tuple(
                result.first as SolverVariable,
                SolverVariable(Some<HirParameterType>(constraint.first)),
              ),
            ),
          )
        }),
      )
    }

    // Lower the base type. For example, in the impl `impl Iterable[Int]: Foo`, the base type
    // `Iterable[Int]` gets lowered to `?0` with the goal `Iterable(Int, ?0)`.
    let baseType = hirImpl.baseType(context)
    let result = hirInlineTypeToSolverTypeAndGoalsAndRules(context, baseType)
    rules.addAll(result.third.items())
    solverConstraints.appendAll(result.second)
    let solverBase = result.first

    // Lower the trait. For example, in the impl `impl Foo: Iterable[Int]`, the implemented trait
    // `Iterable[Int]` gets lowered to `?0` with the goals `Iterable(Int, ?0)`. Impls that don't
    // implement a trait – like `impl Foo { ... }` – don't correspond to a `SolverRule` and cause
    // this function to return `None`.
    let traitType = hirImpl.implementedTrait(context)
    if (traitType is None) { return Tuple(Set.empty<SolverRule>(), List.empty<CompilerError>()) }
    if (traitType.unwrap() is HirErrorType) {
      return Tuple(Set.empty<SolverRule>(), List.empty<CompilerError>())
    }
    let traitType = (traitType.unwrap() as HirNamedType)
    let result = hirInlineTypeToSolverTypeAndGoalsAndRules(context, traitType)
    let solverTrait = (result.first as SolverVariable) // Traits get lowered to `SolverVariable`s.
    let traitGoals = result.second
    rules.addAll(result.third.items())
    if ((traitGoals as Iterable).length() > 1) {
      // TODO(never, marcelgarus): We can't implement a trait that contains another trait yet, like
      // `Iterable<Equals>`. This does work in Rust (with boxing and explicit dynamism), so we'll
      // probably have to look at how to put general-purpose logic implications in our solver (like
      // `A B -> C D` instead of only having one implicative result like `A B -> C` in the solver).
      // Or we need to somehow reduce this to multiple simple rules.
      // For now, we're probably fine with only implementing "simple" traits like `Iterable<Int>`.
      // (As "primitive" types like `List` etc. are also traits, resolving this todo is somewhat of
      // a priority.)
      return Tuple(
        Set.empty<SolverRule>(),
        List.of1<CompilerError>(CannotImplementTraitOfTraitCompilerError(hirImpl)),
      )
    }
    assert((traitGoals as Iterable).length() == 1, "Should never happen.")
    let traitGoal = (traitGoals as Iterable<SolverGoal>).single().unwrap()

    // Let's play this through for the impl `impl[T: Equals] Iterable[T]: Equals`.
    //
    // These would be the values calculated above:
    //
    // * `constraints`: list with goal `Equals(?T)`
    // * `solverBase`: type `?0` and goal `Iterable(?T, ?0)`
    // * `solverTrait`: type `?1` and goal `Equals(?1)`
    //
    // The goal that this impl wants to achieve can be calculated by taking the `solverTrait`, which
    // is guaranteed to have only one goal `Equals(?1)`, and replacing the `solverTrait`'s type `?1`
    // with the `solverBase` type `?0` – which results in `Equals(?0)`.
    // To achieve that goal, we have to satisfy the goals of the `solverBase` and the `constraints`.
    // So, our total `SolverRule` would look like this: `Equals(?0) <- Iterable(?T, ?0), Equals(?T)`
    Tuple(
      Set.of1<SolverRule>(
        SolverRule(
          hirImpl,
          traitGoal.substituteAll(Map.of1<SolverVariable, SolverType>(Tuple(solverTrait, solverBase))),
          solverConstraints,
        ),
      ).union(rules),
      List.empty<CompilerError>(),
    )
  })
}

fun hirInlineTypeToSolverTypeAndGoalsAndRules(
  context: QueryContext<List<CompilerError>>,
  inlineType: HirInlineType,
): (SolverType, List<SolverGoal>, Set<SolverRule>) {
  /// Turns a `HirInlineType` into a `SolverType` and a list of `SolverGoal`s as well as a set of
  /// `SolverRule`s.

  query<
    (SolverType, List<SolverGoal>, Set<SolverRule>),
    List<CompilerError>,
  >(context, "hirInlineTypeToSolverTypeAndGoalsAndRules", inlineType, {
    let loweringContext = LoweringContext.create(context)
    let result = loweringContext.hirInlineTypeToSolverTypeAndGoals(inlineType)
    Tuple(Tuple(result.first, result.second, loweringContext.rules), List.empty<CompilerError>())
  })
}

class LoweringContext {
  let context: QueryContext<List<CompilerError>>

  mut let nextCanonicalIndex: Int
  fun getNextCanonicalVariable(): HirParameterType {
    let result = canonicalVariable(this.nextCanonicalIndex)
    this.nextCanonicalIndex = this.nextCanonicalIndex + 1
    result
  }

  let rules: MutableSet<SolverRule>

  static fun create(context: QueryContext<List<CompilerError>>): LoweringContext {
    let loweringContext = LoweringContext(context, 0, MutableSet.empty<SolverRule>())
    let errorType = HirType.syntheticError(context)
    loweringContext.rules.insert(SolverRule(
      errorType,
      SolverGoal(errorType, List.of1<SolverType>(SolverVariable.error())),
      List.empty<SolverGoal>(),
    ))
    loweringContext
  }

  fun hirInlineTypeToSolverTypeAndGoals(
    hirType: HirInlineType,
  ): (SolverVariable, List<SolverGoal>) {
    if (hirType is HirErrorType) {
      return Tuple(SolverVariable(None<HirParameterType>()), List.empty<SolverGoal>())
    }
    if (hirType is HirNamedType) {
      /// Example:
      ///
      /// hirInlineTypeToSolverStuff(Foo[String, Int]) == (
      ///   ?0,
      ///   Foo(?0, ?1, ?2), String(?1), Int(?2),
      ///   [
      ///     Foo($Foo[?1, ?2], ?1, ?2) <- <empty>,
      ///     Foo($Never, ?1, ?2) <- <empty>,
      ///     Foo(?0, ?1, ?2) <- Error(?0),
      ///     ## Generated transitively:
      ///     String($String) <- <empty>,
      ///     String($Never) <- <empty>,
      ///     String(?0) <- Error(?0),
      ///     Int($Int) <- <empty>,
      ///     Int($Never) <- <empty>,
      ///     Int(?0) <- Error(?0),
      ///     Error(?0) <- <empty>,
      ///     Any(?0) <- <empty>,
      ///   ],
      /// )

      let declaration = (hirType as HirNamedType).declaration
      let goals = MutableList.empty<SolverGoal>()
      let solverParameters = MutableList.empty<SolverType>()
      this.registerHirTypeOrTraitSolverRules(declaration)
      for parameter in (hirType as HirNamedType).parameterTypes {
        let result = this.hirInlineTypeToSolverTypeAndGoals(parameter)
        solverParameters.append(result.first)
        goals.appendAll(result.second)
      }
      // We'll return a substitution that will have to satisfy the trait. For example, given the
      // trait `Equals`, we'll return `?0` with the goal `Equals(?0)`. The `?0` is this
      // substitution.
      let substitution = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      goals.append(
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(substitution)),
        ),
      )
      return Tuple(substitution, goals as List<SolverGoal>)
    }
    // TODO(never, marcelgarus): For now, we only support impls for nominal types. If we want to support
    // `impl A | B: Equals` or `impl (name: String, age: UInt): Clone`, we'll need to add support
    // for other `HirInlineTypes` as well.
    if (hirType is HirFunctionType) {
      let goals = MutableList.empty<SolverGoal>()
      let solverParameters = MutableList.empty<SolverType>()
      let declaration = this.registerFunctionSolverRules(hirType as HirFunctionType)
      
      let types = functionType.receiverType
        .map<List<HirInlineType>>({ List.of1<HirInlineType>(it) })
        .orElse(List.empty<HirInlineType>())
        .followedByList(functionType.parameterTypes)
        .followedByList(List.of1<HirInlineType>(functionType.returnType))
      for parameter in types {
        let result = this.hirInlineTypeToSolverTypeAndGoals(parameter)
        solverParameters.append(result.first)
        goals.appendAll(result.second)
      }
      // We'll return a substitution that will have to satisfy the trait. For example, given the
      // trait `Equals`, we'll return `?0` with the goal `Equals(?0)`. The `?0` is this
      // substitution.
      let substitution = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      goals.append(
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(substitution)),
        ),
      )
      return Tuple(substitution, goals as List<SolverGoal>)
    }
    if (hirType is HirStructType) {
      /// Example:
      ///
      /// hirInlineTypeToSolverStuff((foo: String, bar: Int)) == (
      ///   ?0,
      ///   Struct$bar$foo(?1, ?2, ?0), Int(?1), String(?2),
      ///   [
      ///     Struct$bar$foo(?0, ?1, $Struct$bar$foo[?0, ?1]) <- <empty>,
      ///     Struct$bar$foo(?0, ?1, $Never) <- <empty>,
      ///     Struct$bar$foo(?0, ?1, ?2) <- Error(?2),
      ///     ## Generated transitively:
      ///     String($String) <- <empty>,
      ///     String($Never) <- <empty>,
      ///     String(?0) <- Error(?0),
      ///     Int($Int) <- <empty>,
      ///     Int($Never) <- <empty>,
      ///     Int(?0) <- Error(?0),
      ///     Error(?0) <- <empty>,
      ///     Any(?0) <- <empty>,
      ///   ],
      /// )

      let goals = MutableList.empty<SolverGoal>()
      let solverParameters = MutableList.empty<SolverType>()
      let declaration = this.registerStructSolverRules(hirType as HirStructType)
      let types = ((hirType as HirStructType).types.sortedBy<String>({ it.first }) as Iterable<(String, HirInlineType)>)
        .map<HirInlineType>({ it.second })
      for parameter in types {
        let result = this.hirInlineTypeToSolverTypeAndGoals(parameter)
        solverParameters.append(result.first)
        goals.appendAll(result.second)
      }
      // We'll return a substitution that will have to satisfy the trait. For example, given the
      // trait `Equals`, we'll return `?0` with the goal `Equals(?0)`. The `?0` is this
      // substitution.
      let substitution = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      goals.append(
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(substitution)),
        ),
      )
      return Tuple(substitution, goals as List<SolverGoal>)
    }
    if (hirType is HirEnumType) {
      let goals = MutableList.empty<SolverGoal>()
      let solverParameters = MutableList.empty<SolverType>()
      let declaration = this.registerEnumSolverRules(hirType as HirEnumType)
      let types = ((hirType as HirEnumType).variants.entries().toList().sortedBy<String>({ it.first }) as Iterable<(String, HirInlineType)>)
        .map<HirInlineType>({ it.second })
      for parameter in types {
        let result = this.hirInlineTypeToSolverTypeAndGoals(parameter)
        solverParameters.append(result.first)
        goals.appendAll(result.second)
      }
      // We'll return a substitution that will have to satisfy the trait. For example, given the
      // trait `Equals`, we'll return `?0` with the goal `Equals(?0)`. The `?0` is this
      // substitution.
      let substitution = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      goals.append(
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(substitution)),
        ),
      )
      return Tuple(substitution, goals as List<SolverGoal>)
    }
    if (hirType is HirIntersectionType) {
      /// Example:
      ///
      /// hirInlineTypeToSolverStuff(Equals & Hash) == (
      ///   ?0,
      ///   Equals(?0), Hash(?0)
      ///   [
      ///     ## Generated transitively:
      ///     Equals($Equals) <- <empty>,
      ///     Equals($Never) <- <empty>,
      ///     Equals(?0) <- Error(?0),
      ///     Hash($Hash) <- <empty>,
      ///     Hash($Never) <- <empty>,
      ///     Hash(?0) <- Error(?0),
      ///     Error(?0) <- <empty>,
      ///     Any(?0) <- <empty>,
      ///   ],
      /// )

      let goals = MutableList.empty<SolverGoal>()
      let substitution = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      for type_ in (hirType as HirIntersectionType).types {
        let result = this.hirInlineTypeToSolverTypeAndGoals(type_)
        let substitutions = Map.of1<SolverVariable, SolverType>(Tuple(result.first, substitution))
        let substitutedGoals = (result.second as Iterable<SolverGoal>)
          .map<SolverGoal>({ it.substituteAll(substitutions) })
        goals.appendAll(substitutedGoals)
      }
      return Tuple(substitution, goals as List<SolverGoal>)
    }
    if (hirType is HirThisType) {
      let declaration = (hirType as HirThisType).declaration
      if (declaration is HirTrait) {
        // We don't need to lower `This` types in traits to solver types because we only use impls
        // for logical type solving.
        throw "Don't call hirTypeToSolverType for a This type in a trait"
      }
      if (declaration is HirImpl) {
        // If a `This` type is used inside an impl, it just assumes the solver type of the base
        // type.
        //
        // Whether that solver type is a `SolverVariable` or `SolverValue` depends on whether the
        // impl is for a trait or type:
        //
        // * `impl Int: InfixAmpersand[This, Int]` has the lowered base type `Int`, so the `This`
        //   gets replaced with `Int`, resulting in `InfixAmpersand(Int, Bool)`.
        // * `impl And: InfixAmpersand[This, Bool]` has the lowered base type `?0` with the
        //   additional goal `And(?0)`, so the `This` gets replaced with `?0`, resulting in
        //   `InfixAmpersand(?0, Bool) <- And(?0)`.
        let loweredBaseType = this.hirInlineTypeToSolverTypeAndGoals(
          (declaration as HirImpl).baseType(context),
        )
        let baseSolverType = loweredBaseType.first
        return Tuple(baseSolverType, List.empty<SolverGoal>())
      }
    }
    if (hirType is HirParameterType) {
      return Tuple(
        SolverVariable(Some<HirParameterType>(hirType as HirParameterType)),
        List.empty<SolverGoal>(),
      )
    }
    if (hirType is HirReflectionType) {
      todo("soon, marcelgarus: Handle HirReflectionType")
    }

    throw "Unexpected HirType: {hirType}"
  }

  fun registerHirTypeOrTraitSolverRules(declaration: HirType | HirTrait) {
    // We create several synthetic types and impls to allow for correct handling of error types
    // and the `Never` type.
    //
    // Example 1:
    //
    // registerHirTypeOrTraitSolverRules(Int) -> [
    //   Int($Int) <- <empty>,
    //   Int($Never) <- <empty>,
    //   Int(?0) <- Error(?0),
    //   Error(?0) <- <empty>,
    //   Any(?0) <- <empty>,
    // ]
    //
    // Example 2:
    //
    // registerHirTypeOrTraitSolverRules(LinkedList) -> [
    //   LinkedList(?0, $LinkedList(?0)) <- <empty>,
    //   LinkedList(?0, $Never) <- <empty>,
    //   LinkedList(?0, ?1) <- Error(?1),
    //   Error(?0) <- <empty>,
    //   Any(?0) <- <empty>,
    // ]

    let goals = MutableList.empty<SolverGoal>()
    let solverParameters = MutableList.empty<SolverType>()
    for parameter in (declaration as HasTypeParameters).typeParameters(context) {
      let result = this.hirInlineTypeToSolverTypeAndGoals(parameter.upperBound(context))
      solverParameters.append(result.first)
      goals.appendAll(result.second)
    }

    if (declaration is HirTrait) {
      // Upper bounds
      let upperBounds = (declaration.upperBound(context) as Iterable<HirNamedType | HirErrorType>)
        .whereType<HirNamedType>()
      let variable = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      for upperBound in upperBounds {
        let result = hirInlineTypeToSolverTypeAndGoals(upperBound)
        this.rules.insert(SolverRule(
          upperBound,
          SolverGoal(upperBound.declaration, List.of1<SolverType>(variable)),
          List.of1<SolverGoal>(SolverGoal(declaration, List.of1<SolverType>(variable))),
        ))
      }
    }

    if (declaration is HirType) {
      // Any(?T) <- T(?T)
      let anyType = HirTrait.coreAny(context)
      let variable = SolverVariable(Some<HirParameterType>(this.getNextCanonicalVariable()))
      this.rules.insert(SolverRule(
        declaration as HirType,
        SolverGoal(anyType, List.of1<SolverType>(variable)),
        List.of1<SolverGoal>(SolverGoal(declaration, List.of1<SolverType>(variable))),
      ))

      // T($T) <- <empty>
      let primitive = HirType((declaration as HirType).parent, "${(declaration as HirType).name()}")
      let primitive = SolverValue(primitive, solverParameters)
      this.rules.insert(
        SolverRule(
          declaration as HirType,
          SolverGoal(
            declaration,
            (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(primitive)),
          ),
          goals,
        ),
      )
    }

    // T($Never) <- <empty>
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(
          List.of1<SolverType>(SolverValue(HirType.coreNever(context), List.empty<SolverType>())),
        ),
      ),
      List.empty<SolverGoal>(),
    ))

    // T(?0) <- Error(?0)
    let errorType = HirType.syntheticError(context)
    let errorVariable = SolverVariable.error()
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(errorVariable)),
      ),
      List.of1<SolverGoal>(SolverGoal(errorType, List.of1<SolverType>(errorVariable))),
    ))
  }

  fun registerFunctionSolverRules(functionType: HirFunctionType): HirType {
    // We create several synthetic types and impls to allow for correct handling of error types
    // and the `Never` type.
    //
    // For example:
    //
    // registerFunctionSolverRules(Int.(Int) -> String) -> [
    //   Function$2(?0, ?1, ?2, $Function$2(?0, ?1, ?2)) <- <empty>,
    //   Function$2(?0, ?1, ?2, $Never) <- <empty>,
    //   Function$2(?0, ?1, ?2, ?3) <- Error(?3),
    //   ## Generated transitively:
    //   Int($Int) <- <empty>,
    //   Int($Never) <- <empty>,
    //   Int(?0) <- Error(?0),
    //   String($String) <- <empty>,
    //   String($Never) <- <empty>,
    //   String(?0) <- Error(?0),
    //   Error(?0) <- <empty>,
    //   Any(?0) <- <empty>,
    // ]

    let allParameterTypes = functionType.receiverType
      .map<List<HirInlineType>>({ List.of1<HirInlineType>(it) })
      .orElse(List.empty<HirInlineType>())
      .followedByList(functionType.parameterTypes)
    let totalParameterCount = (allParameterTypes as Iterable<HirParameterType>).length()
    let declaration = HirType(HirModule.syntheticFunctionTypes(this.context), "Function${totalParameterCount}")

    let goals = MutableList.empty<SolverGoal>()
    let solverParameters = MutableList.empty<SolverType>()
    mut let parameterIndex = 0
    for inlineType in allParameterTypes.followedByList(List.of1<HirInlineType>(functionType.returnType)) {
      // This adds rules for the specific "type arguments".
      this.hirInlineTypeToSolverTypeAndGoals(inlineType)
      solverParameters.append(
        SolverVariable(Some<HirParameterType>(canonicalVariable(parameterIndex))),
      )
      parameterIndex = parameterIndex + 1
    }

    // T($T) <- <empty>
    let primitive = HirType(declaration.parent, "${declaration.name()}")
    let primitive = SolverValue(primitive, solverParameters)
    this.rules.insert(
      SolverRule(
        declaration,
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(primitive)),
        ),
        goals,
      ),
    )

    // T($Never) <- <empty>
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(
          List.of1<SolverType>(SolverValue(HirType.coreNever(context), List.empty<SolverType>())),
        ),
      ),
      List.empty<SolverGoal>(),
    ))

    // T(?0) <- Error(?0)
    let errorType = HirType.syntheticError(context)
    let errorVariable = SolverVariable.error()
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(errorVariable)),
      ),
      List.of1<SolverGoal>(SolverGoal(errorType, List.of1<SolverType>(errorVariable))),
    ))

    declaration
  }

  fun registerStructSolverRules(tupleType: HirStructType): HirType {
    // We create several synthetic types and impls to allow for correct handling of error types
    // and the `Never` type.
    //
    // For example:
    //
    // registerStructSolverRules((foo: String, bar: Int)) -> [
    //   Struct$bar$foo(?0, ?1, $Struct$bar$foo(?0, ?1)) <- <empty>,
    //   Struct$bar$foo(?0, ?1, $Never) <- <empty>,
    //   Struct$bar$foo(?0, ?1, ?2) <- Error(?2),
    //   ## Generated transitively:
    //   String($String) <- <empty>,
    //   String($Never) <- <empty>,
    //   String(?0) <- Error(?0),
    //   Int($Int) <- <empty>,
    //   Int($Never) <- <empty>,
    //   Int(?0) <- Error(?0),
    //   Error(?0) <- <empty>,
    //   Any(?0) <- <empty>,
    // ]

    let fieldNames = (tupleType.types as Iterable<(String, HirInlineType)>)
      .map<String>({ it.first })
      .toList()
      .unsafeSorted()
    let fieldNames = (fieldNames as Iterable<String>).join("$")
    let declaration = HirType(HirModule.syntheticStructTypes(this.context), "Struct${fieldNames}")

    let goals = MutableList.empty<SolverGoal>()
    let solverParameters = MutableList.empty<SolverType>()
    mut let parameterIndex = 0
    for inlineType in (tupleType.types as Iterable<(String, HirInlineType)>).map<HirInlineType>({ it.second }) {
      // This adds rules for the specific "type arguments".
      this.hirInlineTypeToSolverTypeAndGoals(inlineType)
      solverParameters.append(
        SolverVariable(Some<HirParameterType>(canonicalVariable(parameterIndex))),
      )
      parameterIndex = parameterIndex + 1
    }

    // T($T) <- <empty>
    let primitive = HirType(declaration.parent, "${declaration.name()}")
    let primitive = SolverValue(primitive, solverParameters)
    this.rules.insert(
      SolverRule(
        declaration,
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(primitive)),
        ),
        goals,
      ),
    )

    // T($Never) <- <empty>
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(
          List.of1<SolverType>(SolverValue(HirType.coreNever(context), List.empty<SolverType>())),
        ),
      ),
      List.empty<SolverGoal>(),
    ))

    // T(?0) <- Error(?0)
    let errorType = HirType.syntheticError(context)
    let errorVariable = SolverVariable.error()
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(errorVariable)),
      ),
      List.of1<SolverGoal>(SolverGoal(errorType, List.of1<SolverType>(errorVariable))),
    ))

    declaration
  }

  fun registerEnumSolverRules(enumType: HirEnumType): HirType {
    // We create several synthetic types and impls to allow for correct handling of error types
    // and the `Never` type.
    //
    // For example:
    //
    // registerEnumSolverRules(Foo String | Bar Int) -> [
    //   Enum$Bar$Foo(?0, ?1, $Enum$Bar$Foo(?0, ?1)) <- <empty>,
    //   Enum$Bar$Foo(?0, ?1, $Never) <- <empty>,
    //   Enum$Bar$Foo(?0, ?1, ?2) <- Error(?2),
    //   ## Generated transitively:
    //   String($String) <- <empty>,
    //   String($Never) <- <empty>,
    //   String(?0) <- Error(?0),
    //   Int($Int) <- <empty>,
    //   Int($Never) <- <empty>,
    //   Int(?0) <- Error(?0),
    //   Error(?0) <- <empty>,
    //   Any(?0) <- <empty>,
    // ]

    let variantNames = enumType.variants.keys.toList().unsafeSorted()
    let variantNames = (variantNames as Iterable<String>).join("$")
    let declaration = HirType(HirModule.syntheticEnumTypes(this.context), "Enum${variantNames}")

    let goals = MutableList.empty<SolverGoal>()
    let solverParameters = MutableList.empty<SolverType>()
    mut let parameterIndex = 0
    for inlineType in enumType.variants.values().map<HirInlineType>({ it.second }) {
      // This adds rules for the specific "type arguments".
      this.hirInlineTypeToSolverTypeAndGoals(inlineType)
      solverParameters.append(
        SolverVariable(Some<HirParameterType>(canonicalVariable(parameterIndex))),
      )
      parameterIndex = parameterIndex + 1
    }

    // T($T) <- <empty>
    let primitive = HirType(declaration.parent, "${declaration.name()}")
    let primitive = SolverValue(primitive, solverParameters)
    this.rules.insert(
      SolverRule(
        declaration,
        SolverGoal(
          declaration,
          (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(primitive)),
        ),
        goals,
      ),
    )

    // T($Never) <- <empty>
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(
          List.of1<SolverType>(SolverValue(HirType.coreNever(context), List.empty<SolverType>())),
        ),
      ),
      List.empty<SolverGoal>(),
    ))

    // T(?0) <- Error(?0)
    let errorType = HirType.syntheticError(context)
    let errorVariable = SolverVariable.error()
    this.rules.insert(SolverRule(
      declaration,
      SolverGoal(
        declaration,
        (solverParameters as List<SolverType>).followedByList(List.of1<SolverType>(errorVariable)),
      ),
      List.of1<SolverGoal>(SolverGoal(errorType, List.of1<SolverType>(errorVariable))),
    ))

    declaration
  }
}


fun getSolverEnvironmentOfScope(context: QueryContext<List<CompilerError>>, scope: Package): Environment {
  query<Environment, List<CompilerError>>(
    context, "getSolverEnvironmentOfScope", scope as Equals & Hash, {
    let rules = getAllImplsInScope(context, scope).items()
      .map<Set<SolverRule>>({ hirImplToSolverRules(context, it) })
      .foldLeft<Set<SolverRule>>(Set.empty<SolverRule>(), { a, b => a.union(b) })
    Tuple(Environment(rules.items().toList()), List.empty<CompilerError>())
  })
}

fun makeSureImplsAreNotConflicting(context: QueryContext<List<CompilerError>>, scope: Package) {
  query<Unit, List<CompilerError>>(context, "makeSureImplsAreNotConflicting", scope as Equals & Hash, {
    for implsForSameTrait in (getAllImplsInScope(context, scope).items() as Iterable<HirImpl>)
      .where({ it.implementedTrait(context) is Some })
      .groupBy<HirInlineType>({ it.implementedTrait(context).unwrap() })
      .values() {
      let implsAndBasesForCurrentTrait = (implsForSameTrait as Iterable<HirImpl>)
        .map<(HirImpl, SolverType)>({
          let result = hirInlineTypeToSolverTypeAndGoalsAndRules(context, it.baseType(context))
          Tuple(it, result.first)
        })
        .toList()
      for implAndBase1 in implsAndBasesForCurrentTrait {
        for implAndBase2 in implsAndBasesForCurrentTrait {
          let impl1 = implAndBase1.first
          let impl2 = implAndBase2.first
          let base1 = implAndBase1.second
          let base2 = implAndBase2.second

          if (impl1 as Equals) == (impl2 as Equals) {
            continue
          }

          let unified = base1.unify(base2)
          if unified is Some {
            // Unifying the impl types succeeded. This means there's a type to which both impls
            // apply. That's bad.
            let conflicting = base1.substituteAll(unified.unwrap())
            return Tuple(
              unit,
              List.of1<CompilerError>(
                ConflictingImplsCompilerError(impl1, impl2, base1, base2, conflicting),
              ),
            )
          }
        }
      }
    }
    return Tuple(unit, List.empty<CompilerError>())
  })
}

public fun isAssignableTo(
  context: QueryContext<List<CompilerError>>,
  base: HirInlineType,
  trait_: HirInlineType,
  scope: Package,
): Bool {
  query<Bool, List<CompilerError>>(context, "isAssignableTo", DataTuple3<HirInlineType, HirInlineType, Package>(base, trait_, scope), {
    Tuple(sourceFor(context, base, trait_, scope) is Some, List.empty<CompilerError>())
  })
}
public fun sourceFor(
  context: QueryContext<List<CompilerError>>,
  base: HirInlineType,
  trait_: HirInlineType,
  scope: Package,
): Maybe<HirTrait | HirType | HirNamedType | HirImpl> {
  query<Maybe<HirTrait | HirType | HirNamedType | HirImpl>, List<CompilerError>>(context, "sourceFor", DataTuple3<HirInlineType, HirInlineType, Package>(base, trait_, scope), {
    Tuple(
      findUniqueSolverSolutionFor(context, base, trait_, scope)
        .map<HirTrait | HirType | HirNamedType | HirImpl>({ it.usedRule.originalImpl as HirTrait | HirType | HirNamedType | HirImpl }),
      List.empty<CompilerError>(),
    )
  })
}
public fun findUniqueSolverSolutionFor(
  context: QueryContext<List<CompilerError>>,
  base: HirInlineType,
  trait_: HirInlineType,
  scope: Package,
): Maybe<SolverSolutionUnique> {
  query<Maybe<SolverSolutionUnique>, List<CompilerError>>(context, "findUniqueSolverSolutionFor", DataTuple3<HirInlineType, HirInlineType, Package>(base, trait_, scope), {
    assert(!(trait_ is HirErrorType), "Can't reveal the impl for the error type")

    let environment = getSolverEnvironmentOfScope(context, scope)
    let baseSolverAndGoals = hirInlineTypeToSolverTypeAndGoalsAndRules(context, base)
    let baseType = baseSolverAndGoals.first
    let baseGoals = baseSolverAndGoals.second
    let traitSolverAndGoals = hirInlineTypeToSolverTypeAndGoalsAndRules(context, trait_)
    let traitType = traitSolverAndGoals.first
    let traitGoals = traitSolverAndGoals.second

    if (traitType is SolverValue) {
      throw "This shouldn't happen. Trait should be lowered to a SolverVariable."
    }
    if !((traitGoals as Iterable).length() == 1) {
      return Tuple(
        None<SolverSolutionUnique>(),
        List.of1<CompilerError>(TryingToFindImplForTraitWithTraitAsParameterCompilerError(trait_)),
      )
    }

    let solution = environment.solve(
      (traitGoals as Iterable<SolverGoal>).single().unwrap().substituteAll(
        Map.of1<SolverVariable, SolverType>(Tuple((traitType as SolverVariable), baseType)),
      ),
      baseGoals,
    )
    if (solution is SolverSolutionUnique) {
      Tuple(
        Some<SolverSolutionUnique>(solution as SolverSolutionUnique),
        List.empty<CompilerError>(),
      )
    } else {
      Tuple(None<SolverSolutionUnique>(), List.empty<CompilerError>())
    }
  })
}

fun getAllTraitsInScope(context: QueryContext<List<CompilerError>>, scope: Package): Set<HirTrait> {
  query<Set<HirTrait>, List<CompilerError>>(context, "getAllTraitsInScope", scope as Equals & Hash, {
    let traits = (scope.getAllPackagesInCompilationOrder(context) as Iterable<Package>)
      .map<Set<HirTrait>>({ package => getAllTraitsOfModule(context, HirTopLevelModule(package)) })
      .foldLeft<Set<HirTrait>>(Set.empty<HirTrait>(), { a, b => a.union(b) })
    Tuple(traits, List.empty<CompilerError>())
  })
}
fun getAllTraitsOfModule(context: QueryContext<List<CompilerError>>, module: HirModule): Set<HirTrait> {
  query<Set<HirTrait>, List<CompilerError>>(context, "getAllTraitsOfModule", module as Equals & Hash, {

    let declarations = (declarationsOfModule(context, module) as Iterable<HirDeclaration>)
    let traits = declarations
      .whereType<HirModule>()
      .expand<HirTrait>({ (getAllTraitsOfModule(context, it) as Iterable<HirTrait>) })
      .followedBy(declarations.whereType<HirTrait>())
      .toSet()
    Tuple(traits, List.empty<CompilerError>())
  })
}

fun getAllImplementedTraitsWithSubstitutionsFor(
  context: QueryContext<List<CompilerError>>,
  base: HirInlineType,
  scope: Package,
): Set<(HirNamedType, Map<HirInlineType, HirInlineType>)> {
  // TODO(never): can this be removed?
  query<Set<(HirNamedType, Map<HirInlineType, HirInlineType>)>, List<CompilerError>>(context, "getAllImplementedTraitsWithSubstitutionsFor", DataTuple2<HirInlineType, Package>(base, scope), {
    let traits = getAllImplsWithSubstitutionsFor(context, base, scope)
      .items()
      .map<(HirNamedType, Map<HirInlineType, HirInlineType>)>({
        Tuple(it.first.baseType(context), it.second)
      })
      .toMutableSet()
    if (base.declaration is HirTrait) {
      let upperBound = (base.declaration as HirTrait).upperBound(context)
      let substitutions = (upperBound.typeParameters(context) as Iterable<HirParameterType>)
        .cast<HirInlineType>()
        .zip<HirInlineType>(base.parameterTypes)
        .unsafeToMap<HirInlineType, HirInlineType>()
      traits.insert(Tuple(upperBound, substitutions))
    }
    Tuple(traits, List.empty<CompilerError>())
  })
}

fun getAllImplsWithSubstitutionsFor(
  context: QueryContext<List<CompilerError>>,
  base: HirInlineType,
  scope: Package,
): Set<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>> {
  query<Set<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>, List<CompilerError>>(context, "getAllImplsWithSubstitutionsFor", DataTuple2<HirInlineType, Package>(base, scope), {
    if (base is HirErrorType) {
      return Set.empty<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>()
    }
    if (base is HirNamedType) {
      return getAllImplsInScope(context, scope).items()
        .maybeMap<SolverSolutionUnique>({
          findUniqueSolverSolutionFor(context, base, it.baseType(context), scope)
        })
        .map<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>({
          let substitutions = hirInlineTypeToSolverTypeAndGoalsAndRules(context, base).first
            .unify(it.refinedGoal)
            .unwrap()
          DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>(it, substitutions)
        })
        .toSet()
    }
    if (base is HirFunctionType) {
      return Set.empty<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>()
    }
    if (base is HirStructType) {
      // TODO(soon): create synthetic impls for struct types
      return Set.empty<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>()
    }
    if (base is HirEnumType) {
      // TODO(soon): create synthetic impls for enum types
      return Set.empty<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>()
    }
    if (base is HirIntersectionType) {
      return ((base as HirIntersectionType).types as Iterable<HirInlineType>)
        .expand<HirFunction>({ it.allFunctions(context, scope)})
        .toSet()
    }
    if (base is HirThisType) {
      return getAllImplsWithSubstitutionsFor(context, (base as HirThisType).resolve(context), scope)
    }
    if (base is HirParameterType) {
      let upperBound = (base as HirParameterType).upperBound(context)
      return getAllImplsWithSubstitutionsFor(context, upperBound, scope)
    }
    if (base is HirReflectionType) {
      // TODO(never): create synthetic impls for reflection types
      return Set.empty<DataTuple2<HirImpl, Map<HirInlineType, HirInlineType>>>()
    }
    throw "Unknown HirInlineType: {base}"
  })
}

impl HirNamedType {
  fun substitutionMap(context: QueryContext<List<CompilerError>>): Map<HirParameterType, HirInlineType> {
    query<
      Map<HirParameterType, HirInlineType>,
      List<CompilerError>,
    >(context, "HirNamedType.substitutionMap", this as Equals & Hash, {
      let typeArguments = this.parameterTypes
      let typeParameters = (this.declaration as HasTypeParameters).typeParameters(context)
      assert((typeArguments as Iterable<HirInlineType>).length() == (typeParameters as Iterable<HirParameterType>).length())

      let substitutionMap = typeParameters
        .zip(typeArguments as Iterable<HirInlineType>)
        .unsafeToMap<HirParameterType, HirInlineType>()
      Tuple(substitutionMap, List.empty<CompilerError>())
    })
  }
}
impl HirThisType {
  fun resolve(context: QueryContext<List<CompilerError>>): HirInlineType {
    query<HirInlineType, List<CompilerError>>(context, "HirThisType.resolve", this, {
      let baseType = if (this.declaration is HirTrait) {
        (this.declaration as HirTrait).thisType(context)
      } else {
        (this.declaration as HirImpl).baseType(context)
      }
      Tuple(baseType, List.empty<CompilerError>())
    })
  }
}

// fun resolveFunctionOnInlineType(
//   context: QueryContext<List<CompilerError>>,
//   base: HirInlineType,
//   functionName: String,
//   scope: Package,
// ): Set<HirFunction> {
//   getAllImplsInScope()
// }

public class ThisTypeCanOnlyBeUsedInImplOrTraitCompilerError {
  public let thisType: AstNamedType
  public let scope: HirDeclaration
}
impl ThisTypeCanOnlyBeUsedInImplOrTraitCompilerError: CompilerError {
  public fun id(): String { "this-type-can-only-be-used-in-impl-or-trait" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement ThisTypeCanOnlyBeUsedInImplOrTraitCompilerError.location")
  }
  public fun title(): String { "The This type can only be used in impls or traits." }
  public fun description(): String { "You can't use the This type in modules or type definitions" }
}

public class CannotImplementTraitOfTraitCompilerError {
  public let theImpl: HirImpl
}
impl CannotImplementTraitOfTraitCompilerError: CompilerError {
  public fun id(): String { "cannot-implement-trait-of-trait" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement CannotImplementTraitOfTraitCompilerError.location")
  }
  public fun title(): String {
    "You cannot implement a trait containing another trait as a generic parameter yet."
  }
  public fun description(): String { "The offending impl: {theImpl}" }
}

public class TryingToFindImplForTraitWithTraitAsParameterCompilerError {
  public let trait_: HirInlineType
}
impl TryingToFindImplForTraitWithTraitAsParameterCompilerError: CompilerError {
  public fun id(): String { "trying-to-find-impl-for-trait-with-trait-as-parameter" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement TryingToFindImplForTraitWithTraitAsParameterCompilerError.location")
  }
  public fun title(): String { "Conflicting impls." }
  public fun description(): String {
    "Trying to find an impl for trait {trait_}, which has another trait as a type parameter. That's not supported yet."
  }
}

public class ConflictingImplsCompilerError {
  public let impl1: HirImpl
  public let impl2: HirImpl
  public let base1: SolverType
  public let base2: SolverType
  public let conflictingType: SolverType
}
impl ConflictingImplsCompilerError: CompilerError {
  public fun id(): String { "conflicting-impls" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement ConflictingImplsCompilerError.location")
  }
  public fun title(): String { "Conflicting impls." }
  public fun description(): String {
    "Impl {impl1} conflicts with {impl2}, because both bases {base1} and {base2} apply to the same type {conflictingType}."
  }
}

public class AmbiguousTypeCompilerError {
  public let candidates: Set<HirModule | HirType | HirTrait | HirParameterType>
}
impl AmbiguousTypeCompilerError: CompilerError {
  public fun id(): String { "ambiguous-type" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement AmbiguousTypeCompilerError.location")
  }
  public fun title(): String { "Ambiguous type. Candidates are {candidates}." }
  public fun description(): String {
    /// TODO(never, marcelgarus): add a description for this error
    ""
  }
}

public class UnknownTypeCompilerError {
  public let astType: AstNamedType
}
impl UnknownTypeCompilerError: CompilerError {
  public fun id(): String { "could-not-resolve-type" }

  public fun location(): Location {
    todo("never, marcelgarus: Implement UnknownTypeCompilerError.location")
  }
  public fun title(): String { "Couldn't resolve type {astType.nameParts}." }
  public fun description(): String {
    /// TODO(never, marcelgarus): add a description for this error
    ""
  }
}
