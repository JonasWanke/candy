use ast
use compiler_utils
use incremental

use ..declarations
use ...declarations
use ...types

// These impls make it possible to resolve identifiers.

impl String {
  fun resolveIdentifier(
    context: QueryContext<List<CompilerError>>,
    scope: HirDeclaration,
  ): Set<HirClass | HirTrait | HirProperty | HirFunction | HirModule> {
    query<Set<HirClass | HirTrait | HirProperty | HirFunction | HirModule>, List<CompilerError>>(
      context,
      "String.resolveIdentifier",
      this as Equals & Hash,
      {
        let candidates = MutableSet.empty<HirClass | HirTrait | HirProperty | HirFunction | HirModule>()
        for declaration in scope.declarations(context) {
          if declaration.name() == this {
            candidates.insert(
              declaration as HirClass | HirTrait | HirProperty | HirFunction | HirModule
            )
          }
        }

        // If the `scope` is directly a file, search the use-lines.
        if scope is HirModule {
          let ast = (scope as HirModule).ast(context) 
          if ast is AstFile {
            // TODO(marcelgarus): Search use-lines and add their candidates here.
            return Tuple(
              candidates as Set<HirClass | HirTrait | HirProperty | HirFunction | HirModule>,
              List.empty<CompilerError>(),
            )
          }
        }

        // Otherwise, visit the parent.
        let parent: Package | HirModule | HirTrait | HirClass = scope.parent
        assert(
          !(parent is Package),
          "Parent is a package, although this is not a file-level module."
        )
        candidates.addAll(
          (resolveIdentifier(context, scope.parent as HirDeclaration) as Iterable<
            HirClass | HirTrait | HirProperty | HirFunction | HirModule>)
        )
        Tuple(
          candidates as Set<HirClass | HirTrait | HirProperty | HirFunction | HirModule>,
          List.empty<CompilerError>()
        )
      }
    )
  }
}
