use ast
use compiler_utils
use incremental

use ..declarations
use ...declarations
use ...types

// These impls make it possible to resolve identifiers.

fun resolveIdentifier(
  context: QueryContext<List<CompilerError>>,
  identifier: String,
  scope: HirDeclaration,
): Set<HirType | HirTrait | HirFunction | HirModule | HirParameterType> {
  query<Set<HirType | HirTrait | HirFunction | HirModule | HirParameterType>, List<CompilerError>>(
    context,
    "resolveIdentifier",
    DataTuple2<String, HirDeclaration>(identifier, scope) as Equals & Hash,
    {
      let candidates = MutableSet.empty<HirType | HirTrait | HirFunction | HirModule | HirParameterType>()
      for declaration in (scope as HasDeclarations).declarations(context) {
        if declaration.name() == identifier {
          candidates.insert(declaration as HirType | HirTrait | HirFunction | HirModule)
        }
      }

      if (scope is HasTypeParameters) {
        ((scope as HasTypeParameters).typeParameters(context) as Iterable<HirParameterType>)
          .singleWhere({ it.name == identifier })
          .do({
            candidates.insert(it)
            unit
          })
      }

      // If the `scope` is directly a file, search the use-lines.
      if scope is HirModule {
        let ast = (scope as HirModule).ast(context)
        if ast is AstFile {
          // TODO(marcelgarus): Search use-lines and add their candidates here.
          return Tuple(
            candidates as Set<HirType | HirTrait | HirFunction | HirModule | HirParameterType>,
            List.empty<CompilerError>(),
          )
        }
      }

      // Otherwise, visit the parent.
      let parent: Package | HirModule | HirTrait | HirType | HirImpl = scope.parent
      assert(
        !(parent is Package),
        "Parent is a package, although this is not a file-level module."
      )
      candidates.addAll(
        resolveIdentifier(context, identifier, scope.parent as HirDeclaration).items() as Iterable<
          HirType | HirTrait | HirFunction | HirModule | HirParameterType,
        >
      )
      Tuple(
        candidates as Set<HirType | HirTrait | HirFunction | HirModule | HirParameterType>,
        List.empty<CompilerError>()
      )
    }
  )
}
