use ..declarations
use ..types

public class HirValueExpressionUri {
  public let declaration: HirFunction
  public let index: Int
}
impl HirValueExpressionUri: Equals & Hash {
  fun equals(other: This): Bool {
    (declaration as Equals) == (other.declaration as Equals)
      && (index as Equals) == (other.index as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    declaration.hash<T>(hasher)
    index.hash<T>(hasher)
  }
}
public trait HirValueExpression {
  public let uri: HirValueExpressionUri
}
impl HirValueExpression: Equals & Hash

public class HirIntValueExpression {
  public let uri: HirValueExpressionUri
  public let value: Int
}
impl HirIntValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals) && (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    value.hash<T>(hasher)
  }
}

public class HirStringValueExpression {
  public let uri: HirValueExpressionUri
  public let value: String
}
impl HirStringValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals) && (value as Equals) == (other.value as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    value.hash<T>(hasher)
  }
}

public class HirLambdaValueExpression {
  public let uri: HirValueExpressionUri
  public let parameters: List<HirLambdaParameter>
  public let expressions: List<HirValueExpressionUri>
  public let returnType: HirInlineType
}
impl HirLambdaValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (parameters as Iterable<HirLambdaParameter>).unsafeEquals(other.parameters)
      && (expressions as Iterable<HirValueExpressionUri>).unsafeEquals(other.expressions)
      && (returnType as Equals) == (other.returnType as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    parameters.unsafeHash<T>(hasher)
    expressions.unsafeHash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
  }
}
public class HirLambdaParameter {
  public let name: String
  public let type: HirInlineType
}
impl HirLambdaParameter: Equals & Hash {
  fun equals(other: This): Bool {
    (name as Equals) == (other.name as Equals) && (type as Equals) == (other.type as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    name.hash<T>(hasher)
    (type as Hash).hash<T>(hasher)
  }
}

public class HirThisValueExpression {
  public let uri: HirValueExpressionUri
  public let type: HirInlineType
}
impl HirThisExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals) && (type as Equals) == (other.type as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    (type as Hash).hash<T>(hasher)
  }
}

public class HirLocalPropertyReferenceValueExpression {
  public let uri: HirValueExpressionUri
  public let value: HirValueExpressionUri
}
impl HirLocalPropertyReferenceExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals) && (target as Equals) == (other.target as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    target.hash<T>(hasher)
  }
}

public class HirFunctionCallValueExpression {
  public let uri: HirValueExpressionUri
  public let receiver: HirValueExpressionUri
  public let function: HirFunction
  public let typeArguments: Map<String, HirInlineType>
  public let valueArguments: Map<String, HirValueExpressionUri>
}
impl HirFunctionCallExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && (function as Equals) == (other.function as Equals)
      && (typeArguments as Iterable<HirInlineType>).unsafeEquals(other.typeArguments)
      && (valueArguments as Iterable<HirValueExpressionUri>).unsafeEquals(other.valueArguments)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (uri as Hash).hash<T>(hasher)
    (receiver as Hash).hash<T>(hasher)
    (function as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
    (valueArguments as Hash).hash<T>(hasher)
  }
}

public class HirExpressionCallValueExpression {
  public let uri: HirValueExpressionUri
  public let receiver: HirValueExpressionUri
  public let typeArguments: List<HirInlineType>
  public let valueArguments: List<HirValueExpressionUri>
}
impl HirExpressionCallValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && (typeArguments as Iterable<HirInlineType>).unsafeEquals(other.typeArguments)
      && (valueArguments as Iterable<HirExpressionUri<HirExpression>>).unsafeEquals(other.valueArguments)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    receiver.hash<T>(hasher)
    typeArguments.unsafeHash<T>(hasher)
    valueArguments.unsafeHash<T>(hasher)
  }
}

public class HirPropertyNavigationValueExpression {
  public let uri: HirValueExpressionUri
  public let receiver: HirValueExpressionUri
  public let name: String
}
impl HirPropertyNavigationValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && (name as Equals) == (other.name as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    receiver.hash<T>(hasher)
    name.hash<T>(hasher)
  }
}

public class HirTypeInstantiationValueExpression {
  public let uri: HirValueExpressionUri
  public let receiver: HirInlineType
  public let typeArguments: Map<String, HirType>
  public let valueArgument: HirValueExpressionUri
}
impl HirTypeInstantiationValueExpression: HirValueExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (receiver as Equals) == (other.receiver as Equals)
      && typeArguments.unsafeEquals(other.typeArguments)
      && (valueArgument as Equals) == (other.valueArgument as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    receiver.hash<T>(hasher)
    typeArguments.unsafeHash<T>(hasher)
    valueArgument.hash<T>(hasher)
  }
}

public class HirTupleValueExpression {
  public let uri: HirValueExpressionUri
  public let valueArguments: List<HirValueExpressionUri>
}
impl HirTupleValueExpression: HirExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (valueArguments as Iterable<HirValueExpressionUri>).unsafeEquals(other.valueArguments)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    valueArguments.unsafeHash<T>(hasher)
  }
}

public class HirNamedTupleValueExpression {
  public let uri: HirValueExpressionUri
  public let valueArguments: Map<String, HirValueExpressionUri>
}
impl HirNamedTupleValueExpression: HirExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals) && valueArguments.unsafeEquals(other.valueArguments)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    valueArguments.unsafeHash<T>(hasher)
  }
}

public class HirReturnValueExpression {
  public let uri: HirValueExpressionUri
  public let scope: HirFunction
  public let expression: HirValueExpressionUri
}
impl HirReturnExpression: HirExpression & Equals & Hash {
  fun equals(other: This): Bool {
    (uri as Equals) == (other.uri as Equals)
      && (scope as Equals) == (other.scope as Equals)
      && (expression as Equals) == (other.expression as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    uri.hash<T>(hasher)
    (scope as Hash).hash<T>(hasher)
    expression.hash<T>(hasher)
  }
}


public class HirTypeExpressionUri {
  public let type: HirInlineType
}
impl HirTypeExpressionUri: Equals & Hash {
  fun equals(other: This): Bool { (type as Equals) == (other.type as Equals) }
  fun hash<T>(hasher: Hasher<T>) { type.hash<T>(hasher) }
}
public trait HirTypeExpression {
  let uri: HirTypeExpressionUri
}
impl HirTypeExpression: Equals & Hash


public class HirModuleExpressionUri {
  public let module: HirModule
}
impl HirTypeExpressionUri: Equals & Hash {
  fun equals(other: This): Bool { (module as Equals) == (other.module as Equals) }
  fun hash<T>(hasher: Hasher<T>) { module.hash<T>(hasher) }
}
public trait HirModuleExpression {
  public let uri: HirModuleExpressionUri
}
impl HirModuleExpression: Equals & Hash
