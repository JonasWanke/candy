use compiler_utils
use incremental

use ..declarations
use ..types

public class HirValueExpressionUri {
  public let declaration: HirFunction
  public let index: Int
}
impl HirValueExpressionUri: Equals & Hash {
  fun equals(other: This): Bool {
    (declaration as Equals) == (other.declaration as Equals)
      && (index as Equals) == (other.index as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    declaration.hash<T>(hasher)
    index.hash<T>(hasher)
  }
}
public trait HirValueExpression {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This { this }
}
fun copyInlineTypeToFunction(
  context: QueryContext,
  inlineType: HirInlineType,
  newFunction: HirFunction,
  implementedType: HirNamedType,
): HirInlineType {
  if (inlineType is HirErrorType) { return inlineType }
  if (inlineType is HirNamedType) {
    return HirNamedType(
      (inlineType as HirNamedType).declaration,
      ((inlineType as HirNamedType).parameterTypes as Iterable<HirInlineType>)
        .map<HirInlineType>({ copyInlineTypeToFunction(context, it, newFunction, implementedType) })
        .toList(),
    )
  }
  if (inlineType is HirFunctionType) {
    let inlineType = (inlineType as HirFunctionType)
    return HirFunctionType(
      inlineType.receiverType.map<HirInlineType>({
        copyInlineTypeToFunction(context, it, newFunction, implementedType)
      }),
      (inlineType.parameterTypes as Iterable<HirInlineType>)
        .map<HirInlineType>({ copyInlineTypeToFunction(context, it, newFunction, implementedType) })
        .toList(),
      copyInlineTypeToFunction(context, inlineType.returnType, newFunction, implementedType),
    )
  }
  if (inlineType is HirStructType) {
    return HirStructType(
      ((inlineType as HirStructType).types as Iterable<(String, HirInlineType)>)
        .map<(String, HirInlineType)>({
          Tuple(
            it.first,
            copyInlineTypeToFunction(context, it.second, newFunction, implementedType),
          )
        })
        .toList(),
    )
  }
  if (inlineType is HirEnumType) {
    return HirEnumType(
      (inlineType as HirEnumType).variants.map<String, Maybe<HirInlineType>>({ key, value =>
        Tuple(
          key,
          value.map<HirInlineType>({
            copyInlineTypeToFunction(context, it, newFunction, implementedType)
          }),
        )
      }),
    )
  }
  if (inlineType is HirIntersectionType) {
    return HirIntersectionType(
      ((inlineType as HirIntersectionType).types as Iterable<HirInlineType>)
        .map<HirInlineType>({
          copyInlineTypeToFunction(context, it.second, newFunction, implementedType)
        })
        .toList(),
    )
  }
  if (inlineType is HirThisType) {
    return newFunction.thisType(context).unwrap()
  }
  if (inlineType is HirParameterType) {
    let inlineType = (inlineType as HirParameterType)
    if (inlineType.declaration is HirTrait) {
      let parentTrait = (implementedType.declaration as HirTrait)
      let parameterIndex = parentTrait.typeParameters(context)
        .singleIndexWhere({ it.name == inlineType.name })
        .unwrap()
      return implementedType.parameterTypes.get(parameterIndex).unwrap()
    }
    if (inlineType.declaration is HirImpl) {
      // TODO(soon)
    }
    if (inlineType.declaration is HirType) {
      throw "Function {newFunction} contains impossible type parameter reference to {inlineType}."
    }
    if (inlineType.declaration is HirFunction) {
      let newFunctionTypeParameters = (newFunction.typeParameters(context) as Iterable<HirParameterType>)
      let newTypeParameter = newFunctionTypeParameters.singleWhere({ it.name == inlineType.name })
      assert(
        newTypeParameter is Some,
        "Overwritten function {newFunction} is missing type parameter {inlineType} of its parent function.",
      )
      return newTypeParameter.unwrap()
    }
    throw "Unknown declaratoin of `HirParameterType`: {inlineType}"
  }
  if (inlineType is HirReflectionType) { return inlineType }
  throw "Unknown inline type: {inlineType}"
}
impl HirValueExpression: Equals & Hash

/// A placeholder for an expression that couldn't be lowered.
public class HirErrorValueExpression {}
impl HirErrorValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType { HirErrorType() }

  fun equals(other: This): Bool { true }
  fun hash<T>(hasher: Hasher<T>) {}
}

/// An `Int` literal.
///
/// Examples:
///
/// * `12`
/// * `42`
public class HirIntValueExpression {
  public let value: Int
}
impl HirIntValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirNamedType.coreInt(context)
  }

  fun equals(other: This): Bool { (value as Equals) == (other.value as Equals) }
  fun hash<T>(hasher: Hasher<T>) { value.hash<T>(hasher) }
}

/// A simple `String` literal. Interpolated `String`s are already split up into more complex
/// expressions in the HIR.
///
/// Example: `"Hello, world!"`
public class HirStringValueExpression {
  public let value: String
}
impl HirStringValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirNamedType.coreString(context)
  }

  fun equals(other: This): Bool { (value as Equals) == (other.value as Equals) }
  fun hash<T>(hasher: Hasher<T>) { value.hash<T>(hasher) }
}

/// A lambda expression.
///
/// Examples:
///
/// * `{ print("Hi!") }`
/// * `{ a, b -> a + b }`
public class HirLambdaValueExpression {
  public let parameters: List<HirLambdaValueParameter>
  public let expressions: List<HirValueExpressionUri>
  public let returnType: HirInlineType
}
impl HirLambdaValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirFunctionType(
      None<HirInlineType>(),
      (this.parameters as Iterable<HirLambdaValueParameter>)
        .map({ type_ })
        .toList(),
      this.returnType,
    )
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirLambdaValueExpression(
      (this.parameters as Iterable<HirLambdaValueParameter>)
        .map<HirLambdaValueParameter>({ it.copyToFunction(context, newFunction) })
        .toList(),
      (this.expressions as Iterable<HirValueExpressionUri>)
        .map<HirValueExpressionUri>({ HirValueExpressionUri(newFunction, it.index) })
        .toList(),
      copyInlineTypeToFunction(context, this.returnType, newFunction),
    )
  }

  fun equals(other: This): Bool {
    (parameters as Equals) == (other.parameters as Equals)
      && (expressions as Equals) == (other.expressions as Equals)
      && (returnType as Equals) == (other.returnType as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parameters as Hash).hash<T>(hasher)
    (expressions as Hash).hash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
  }
}

public class HirLambdaValueParameter {
  public let lambdaUri: HirValueExpressionUri
  public let name: String
  public let type_: HirInlineType

  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): HirLambdaValueParameter {
    HirLambdaValueParameter(
      HirValueExpressionUri(newFunction, this.lambdaUri.index),
      this.name,
      copyInlineTypeToFunction(context, this.type_, newFunction, implementedType),
    )
  }
}
impl HirLambdaValueParameter: Equals & Hash {
  fun equals(other: This): Bool {
    (lambdaUri as Equals) == (other.lambdaUri as Equals)
      && (name as Equals) == (other.name as Equals)
      && (type_ as Equals) == (other.type_ as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (lambdaUri as Hash).hash<T>(hasher)
    (name as Hash).hash<T>(hasher)
    (type_ as Hash).hash<T>(hasher)
  }
}


/// A this expression.
///
/// Example: `this` (and this is the only example)
public class HirThisValueExpression {
  let thisType: HirThisType
}
impl HirThisValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType { this.thisType }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): HirThisValueExpression {
    HirThisValueExpression(copyInlineTypeToFunction(context, this.thisType, newFunction, implementedType))
  }

  fun equals(other: This): Bool { (this.thisType as Equals) == (other.thisType as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (this.thisType as Hash).hash<T>(hasher) }
}

/// An expression that references a parameter.
///
/// Example:
///
/// ```
/// fun foo(a: Bar) {
///   a ## The `a` becomes a `HirParameterReferenceValueExpression`
/// }
/// ```
public class HirParameterReferenceValueExpression {
  public let parameter: HirValueParameter | HirLambdaValueParameter
}
impl HirParameterReferenceValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    if (this.parameter is HirValueParameter) {
      (this.parameter as HirValueParameter).type(context)
    } else {
      (this.parameter as HirLambdaValueParameter).type_
    }
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    if (this.parameter is HirValueParameter) {
      HirParameterReferenceValueExpression(
        HirValueParameter(newFunction, (this.parameter as HirValueParameter).name),
      )
    } else {
      HirParameterReferenceValueExpression(
        (this.parameter as HirLambdaValueParameter).copyToFunction(context, newFunction, implementedType),
      )
    }
  }

  fun equals(other: This): Bool { parameter == other.parameter }
  fun hash<T>(hasher: Hasher<T>) { (parameter as Hash).hash<T>(hasher) }
}

/// A function call expression.
///
/// Examples:
///
/// * `foo()`
/// * `foo.bar()` (the whole `.bar()` is one expression with `foo` as the receiver)
public class HirFunctionCallValueExpression {
  public let receiver: Maybe<HirValueExpressionUri | HirTypeExpression>
  public let function: HirFunction
  public let typeArguments: Map<String, HirInlineType>
  public let valueArguments: Map<String, HirValueExpressionUri>
  public let returnType: HirInlineType

  public static fun coreNothing(
    context: QueryContext<List<CompilerError>>,
  ): HirFunctionCallValueExpression {
    HirFunctionCallValueExpression(
      None<HirValueExpressionUri | HirTypeExpression>(),
      HirFunction(HirModule.corePrimitives(context), "nothing", 0),
      Map.empty<String, HirInlineType>(),
      Map.empty<String, HirValueExpressionUri>(),
    )
  }
}
impl HirFunctionCallValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType { this.returnType }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    // TODO(never): tighten `this.function` if the receiver's type is `This`
    HirFunctionCallValueExpression(
      receiver.map<HirValueExpressionUri | HirTypeExpression>({
        if (it is HirValueExpressionUri) {
          HirValueExpressionUri(newFunction, (it as HirValueExpressionUri).index)
        } else {
          it
        }
      }),
      this.receiver
        .map<HirFunction>({
          if (it is HirValueExpressionUri) {
            if ((it as HirValueExpressionUri).type(context) is HirThisType) {
              let thisType = ((it as HirValueExpressionUri).type(context) as HirThisType)

              // function is already defined on `this` directly
              assert(
                !(this.function.parent is HirModule),
                "Module-level function called on a receiver.",
              )
              if (this.function.parent is HirTrait) {
                if ((this.function.parent as HirTrait).thisType(context).declaration
                  == thisType.declaration) {
                  // TODO(never): tighten this to the synthetic, overwritten variant
                  return this.function
                }
              }
              if (this.function.parent is HirImpl) {
                if ((this.function.parent as HirImpl).baseType(context).declaration
                  == thisType.declaration) {
                  // TODO(never): tighten this to the synthetic, overwritten variant
                  return this.function
                }
              }

              // function is defined in a parent trait
              // TODO(soon)
              // function is defined in some impl
              // TODO(soon)
            }
          }
          this.function
        })
        .orElse({ this.function })
      this.typeArguments.map<String, HirInlineType>({ key, value =>
        Tuple(key, copyInlineTypeToFunction(context, value, newFunction, implementedType))
      }),
      this.valueArguments.map<String, HirValueExpressionUri>({ key, value =>
        Tuple(key, HirValueExpressionUri(function, value.index))
      }),
    )
  }

  fun equals(other: This): Bool {
    (receiver as Equals) == (other.receiver as Equals)
      && (function as Equals) == (other.function as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
      && (valueArguments as Equals) == (other.valueArguments as Equals)
      && (returnType as Equals) == (other.returnType as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (receiver as Hash).hash<T>(hasher)
    (function as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
    (valueArguments as Hash).hash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
  }
}

/// An expression call expression.
///
/// Example:
///
/// * `{ print("Hello!") }()`
/// * ```
///   let a = { ... }
///   a()
///   ```
public class HirValueExpressionCallValueExpression {
  public let receiver: HirValueExpressionUri
  public let returnType: HirInlineType
  public let typeArguments: List<HirInlineType>
  public let valueArguments: List<HirValueExpressionUri>
}
impl HirValueExpressionCallValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType { this.returnType }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirValueExpressionCallValueExpression(
      HirValueExpressionUri(newFunction, this.receiver.index),
      copyInlineTypeToFunction(context, this.returnType, newFunction, implementedType),
      (this.typeArguments as Iterable<HirInlineType>)
        .map<HirInlineType>({ key, value =>
          Tuple(key, copyInlineTypeToFunction(context, value, newFunction, implementedType))
        })
        .toList(),
      (this.valueArguments as Iterable<HirValueExpressionUri>)
        .map<String, HirValueExpressionUri>({ key, value =>
          Tuple(key, HirValueExpressionUri(newFunction, value.index))
        })
        .toList(),
    )
  }

  fun equals(other: This): Bool {
    (receiver as Equals) == (other.receiver as Equals)
      && (returnType as Equals) == (other.returnType as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
      && (valueArguments as Equals) == (other.valueArguments as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    receiver.hash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
    (valueArguments as Hash).hash<T>(hasher)
  }
}

/// A type instantiation expression.
///
/// Examples:
///
/// * `Foo()`
/// * `Bar[Blub](foo, something)`
public class HirTypeInstantiationValueExpression {
  public let receiver: HirType
  public let typeArguments: Map<String, HirInlineType>
  public let valueArgument: HirValueExpressionUri
}
impl HirTypeInstantiationValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirNamedType(
      this.receiver,
      (this.receiver.typeParameters(context) as Iterable<HirParameterType>)
        .map<HirInlineType>({ this.typeArguments.get(it.name).unwrap() })
        .toList(),
    )
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirTypeInstantiationValueExpression(
      this.receiver,
      this.typeArguments.map<String, HirInlineType>({ key, value =>
        Tuple(key, copyInlineTypeToFunction(context, value, newFunction, implementedType))
      }),
      HirValueExpressionUri(newFunction, this.valueArgument.index),
    )
  }

  fun equals(other: This): Bool {
    (receiver as Equals) == (other.receiver as Equals)
      && (typeArguments as Equals) == (other.typeArguments as Equals)
      && (valueArgument as Equals) == (other.valueArgument as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (receiver as Hash).hash<T>(hasher)
    (typeArguments as Hash).hash<T>(hasher)
    (valueArgument as Hash).hash<T>(hasher)
  }
}

/// A struct expression.
///
/// Example: `(foo = "Bar", baz = 42)`
public class HirStructValueExpression {
  public let fields: Map<String, DataTuple2<HirValueExpressionUri, HirInlineType>>
}
impl HirStructValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirStructType(this.fields.entries.map<(String, HirInlineType)>({ it.second }).toList())
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirStructValueExpression(
      this.fields.map<String, DataTuple2<HirValueExpressionUri, HirInlineType>>({ key, value =>
        Tuple(
          key,
          DataTuple2<HirValueExpressionUri, HirInlineType>(
            HirValueExpressionUri(newFunction, value.first.index),
            copyInlineTypeToFunction(context, value.second, newFunction, implementedType),
          ),
        )
      }),
    )
  }

  fun equals(other: This): Bool { (fields as Equals) == (other.fields as Equals) }
  fun hash<T>(hasher: Hasher<T>) { fields.hash<T>(hasher) }
}

/// An access of a `HirType`'s value.
///
/// Example: `foo value` (maybe)
public class HirTypeValueValueExpression {
  public let receiver: HirValueExpressionUri
}
impl HirTypeValueValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    let wrapperType = (resolveHirValueExpressionUri(this.receiver).type(context) as HirNamedType)
    (wrapperType.declaration as HirType)
      .type(context.global.context)
      .map<HirInlineType>({ it.substitute(wrapperType.substitutionMap(context.global.context)) })
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirTypeValueValueExpression(HirValueExpressionUri(newFunction, this.receiver.index))
  }

  fun equals(other: This): Bool { (receiver as Equals) == (other.receiver as Equals) }
  fun hash<T>(hasher: Hasher<T>) { receiver.hash<T>(hasher) }
}

/// An access of a struct's field.
///
/// Examples:
///
/// * `foo bar`
/// * `foo baz`
public class HirStructFieldAccessValueExpression {
  public let receiver: HirValueExpressionUri
  public let name: String
}
impl HirStructFieldAccessValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    let structType = (resolveHirValueExpressionUri(this.receiver).type(context) as HirStructType)
    (structType.types as Iterable<(String, HirInlineType)>)
      .singleWhere({ it.first == this.name })
      .unwrap()
      .second
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirStructFieldAccessValueExpression(
      HirValueExpressionUri(newFunction, this.receiver.index),
      this.name,
    )
  }

  fun equals(other: This): Bool {
    (receiver as Equals) == (other.receiver as Equals)
      && (name as Equals) == (other.name as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    receiver.hash<T>(hasher)
    name.hash<T>(hasher)
  }
}

/// A return expression.
///
/// Example:
///
/// * `return "Foo"`
/// * `return@blub 5`
/// * `return` (implicitly returns `nothing`)
// TODO(never): For now, returns always return to the surrounding function.
public class HirReturnValueExpression {
  public let scope: HirFunction
  public let expression: HirValueExpressionUri
}
impl HirReturnValueExpression: HirValueExpression & Equals & Hash {
  fun type(context: QueryContext<List<CompilerError>>): HirInlineType {
    HirNamedType.coreNever(context)
  }
  fun copyToFunction(
    context: QueryContext,
    newFunction: HirFunction,
    implementedType: HirNamedType,
  ): This {
    HirReturnValueExpression(
      newFunction,
      HirValueExpressionUri(newFunction, this.expression.index),
    )
  }

  fun equals(other: This): Bool {
    (scope as Equals) == (other.scope as Equals)
      && (expression as Equals) == (other.expression as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (scope as Hash).hash<T>(hasher)
    expression.hash<T>(hasher)
  }
}

// Non-value expressions:

/// An expression that references a type.
///
/// Examples:
///
/// * `Foo`
/// * `List[Int]`
public class HirTypeExpression {
  public let type: HirInlineType
}
impl HirTypeExpression: Equals & Hash {
  fun equals(other: This): Bool { (type as Equals) == (other.type as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (type as Hash).hash<T>(hasher) }
}

/// An expression that references a module.
///
/// Examples:
///
/// * `Core`
/// * `GitHub`
public class HirModuleExpression {
  public let moduleHir: HirModule
}
impl HirModuleExpression: Equals & Hash {
  fun equals(other: This): Bool { (moduleHir as Equals) == (other.moduleHir as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (moduleHir as Hash).hash<T>(hasher) }
}
