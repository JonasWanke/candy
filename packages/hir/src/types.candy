use ..declarations

public trait HirInlineType


public class HirNamedType {
  public let declaration: HirTrait | HirType
  public let parameterTypes: List<HirInlineType>
}
impl HirNamedType: HirInlineType & Equals & Hash {
  fun equals(other: HirNamedType): Bool {
    declaration == other.declaration
      && parameterTypes.unsafeEquals(other.parameterTypes)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (declaration as Hash).hash<T>(hasher)
    parameterTypes.unsafeHash<T>(hasher)
  }
}


public class HirTupleType {
  public let types: List<HirInlineType>
}
impl HirTupleType: HirInlineType & Equals & Hash {
  fun equals(other: HirTupleType): Bool { types.unsafeEquals(other.types) }
  fun hash<T>(hasher: Hasher<T>) { types.unsafeHash<T>(hasher) }
}


public class HirNamedTupleType {
  public let types: Map<String, HirInlineType>
}
impl HirNamedTupleType: HirInlineType & Equals & Hash {
  fun equals(other: HirNamedTupleType): Bool { types.unsafeEquals(other.types) }
  fun hash<T>(hasher: Hasher<T>) { types.unsafeHash<T>(hasher) }
}


public class HirEnumType {
  public let types: Map<String, HirInlineType>
}
impl HirEnumType: HirInlineType & Equals & Hash {
  fun equals(other: HirEnumType): Bool { types.unsafeEquals(other.types) }
  fun hash<T>(hasher: Hasher<T>) { types.unsafeHash<T>(hasher) }
}


public class HirFunctionType {
  public let receiverType: Maybe<HirInlineType>
  public let parameterTypes: List<HirInlineType>
  public let returnType: HirInlineType
}
impl HirFunctionType: HirInlineType & Equals & Hash {
  fun equals(other: HirFunctionType): Bool {
    receiverType == other.receiverType
      && parameterTypes.unsafeEquals(other.parameterTypes)
      && returnType == other.returnType
  }
  fun hash<T>(hasher: Hasher<T>) {
    (receiverType as Hash).hash<T>(hasher)
    parameterTypes.unsafeHash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
  }
}


public class HirIntersectionType {
  public let types: List<HirInlineType>
  // TODO(JonasWanke): Use a `Set<HirInlineType>` when we have sets that keep insertion order.
}
impl HirIntersectionType: HirInlineType & Equals & Hash {
  fun equals(other: HirIntersectionType): Bool { types.unsafeEquals(other.types) }
  fun hash<T>(hasher: Hasher<T>) { types.unsafeHash<T>(hasher) }
}


public class HirThisType
impl HirThisType: HirInlineType & Equals & Hash {
  fun equals(other: HirThisType): Bool { true }
  fun hash<T>(hasher: Hasher<T>) {}
}


public class HirParameterType {
  public let declaration: HirTrait | HirType | HirFunction
  public let name: String
}
impl HirParameterType: HirInlineType & Equals & Hash {
  fun equals(other: HirParameterType): Bool { declaration == other.declaration && name == other.name }
  fun hash<T>(hasher: Hasher<T>) {
    declaration.hash<T>(hasher)
    name.hash<T>(hasher)
  }
}


public class HirReflectionType {
  public let target: HirModule | HirTrait | HirType | HirFunction | HirProperty | HirParameterType
}
impl HirReflectionType: HirInlineType & Equals & Hash {
  fun equals(other: HirReflectionType): Bool { target == other.target }
  fun hash<T>(hasher: Hasher<T>) { target.hash<T>(hasher) }
}
