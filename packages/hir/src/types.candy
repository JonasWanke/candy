use compiler_utils
use incremental

use ..declarations

public trait HirInlineType: Equals & Hash {
  fun substitute(substitutions: Map<HirInlineType, HirInlineType>): This {
    substitutions.get(this).orElse({ this.substituteChildren(substitutions) })
  }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This
}


public class HirErrorType {}
impl HirErrorType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool { true }
  fun hash<T>(hasher: Hasher<T>) {}
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This { this }
}


public class HirNamedType {
  public let declaration: HirTrait | HirType
  public let parameterTypes: List<HirInlineType>

  static fun coreAny(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirType.coreAny(context), List.empty<HirInlineType>())
  }
  static fun coreInt(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirType.coreInt(context), List.empty<HirInlineType>())
  }
  static fun coreNever(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirType.coreNever(context), List.empty<HirInlineType>())
  }
  static fun coreNothing(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirType.coreNothing(context), List.empty<HirInlineType>())
  }
  static fun coreString(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirType.coreString(context), List.empty<HirInlineType>())
  }
  static fun coreToString(context: QueryContext<List<CompilerError>>): HirNamedType {
    HirNamedType(HirTrait.coreToString(context), List.empty<HirInlineType>())
  }
}
impl HirNamedType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool {
    declaration == other.declaration
      && (parameterTypes as Equals) == (other.parameterTypes as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (declaration as Hash).hash<T>(hasher)
    (parameterTypes as Hash).hash<T>(hasher)
  }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This {
    HirNamedType(
      declaration,
      (parameterTypes as Iterable<HirInlineType>)
        .map<HirInlineType>({ it.substituteChildren(substitutions) })
        .toList(),
    )
  }
}


public class HirFunctionType {
  public let receiverType: Maybe<HirInlineType>
  public let parameterTypes: List<HirInlineType>
  public let returnType: HirInlineType
}
impl HirFunctionType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool {
    (receiverType as Equals) == (other.receiverType as Equals)
      && (parameterTypes as Equals) == (other.parameterTypes as Equals)
      && (returnType as Equals) == (other.returnType as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    (receiverType as Hash).hash<T>(hasher)
    (parameterTypes as Hash).hash<T>(hasher)
    (returnType as Hash).hash<T>(hasher)
  }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This {
    HirFunctionType(
      receiverType.map<HirInlineType>({ it.substituteChildren(substitutions) }),
      (parameterTypes as Iterable<HirInlineType>)
        .map<HirInlineType>({ it.substituteChildren(substitutions) })
        .toList(),
      returnType.substituteChildren(substitutions),
    )
  }
}


public class HirStructType {
  public let types: List<(String, HirInlineType)>
}
impl HirStructType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool {
    ((types as Iterable<(String, HirInlineType)>)
      .map<DataTuple2<String, HirInlineType>>({
        DataTuple2<String, HirInlineType>(it.first, it.second)
      }) as Equals) == ((other.types as Iterable<(String, HirInlineType)>)
          .map<DataTuple2<String, HirInlineType>>({
            DataTuple2<String, HirInlineType>(it.first, it.second)
          }) as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) {
    ((types as Iterable<(String, HirInlineType)>).map<DataTuple2<String, HirInlineType>>({
      DataTuple2<String, HirInlineType>(it.first, it.second)
    }) as Hash).hash<T>(hasher)
  }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This {
    HirStructType(
      (types as Iterable<(String, HirInlineType)>)
        .map<(String, HirInlineType)>({ Tuple(it.first, it.second.substituteChildren(substitutions)) })
        .toList(),
    )
  }
}


public class HirEnumType {
  public let variants: Map<String, Maybe<HirInlineType>>
}
impl HirEnumType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool { (variants as Equals) == (other.variants as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (variants as Hash).hash<T>(hasher) }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This {
    HirEnumType(
      variants.entries()
        .map<(String, Maybe<HirInlineType>)>({
          Tuple(it.first, it.second.map<HirInlineType>({ it.substituteChildren(substitutions) }))
        })
        .unsafeToMap<String, Maybe<HirInlineType>>(),
    )
  }
}


public class HirIntersectionType {
  public let types: List<HirInlineType>
  // TODO(never, JonasWanke): Use a `Set<HirInlineType>` when we have sets that keep insertion order.
}
impl HirIntersectionType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool {
    (types as Equals) == (other.types as Equals)
  }
  fun hash<T>(hasher: Hasher<T>) { (types as Hash).hash<T>(hasher) }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This {
    HirIntersectionType(
      (types as Iterable<HirInlineType>)
        .map<HirInlineType>({ it.substituteChildren(substitutions) })
        .toList(),
    )
  }
}


public class HirThisType {
  public let declaration: HirTrait | HirImpl
}
impl HirThisType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool { (declaration as Equals).equals(other.declaration as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (declaration as Hash).hash<T>(hasher) }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This { this }
}


public class HirParameterType {
  public let declaration: HirTrait | HirImpl | HirType | HirFunction
  public let name: String
}
impl HirParameterType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool {
    (declaration as Equals) == other.declaration && name == other.name
  }
  fun hash<T>(hasher: Hasher<T>) {
    (declaration as Hash).hash<T>(hasher)
    name.hash<T>(hasher)
  }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This { this }
}


public class HirReflectionType {
  public let target: HirModule | HirTrait | HirType | HirFunction | HirParameterType
}
impl HirReflectionType: Equals & Hash & HirInlineType {
  fun equals(other: This): Bool { (target as Equals) == (other.target as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (target as Hash).hash<T>(hasher) }
  fun substituteChildren(substitutions: Map<HirInlineType, HirInlineType>): This { this }
}
