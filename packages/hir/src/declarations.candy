use compiler_utils

public trait HirDeclaration {
  let parent: Package | HirModule | HirTrait | HirClass
  fun name(): String
}

public trait HirModule: HirDeclaration & Equals & Hash {
  let parent: Package | HirModule
  fun innerModule(name: String): HirInnerModule { HirInnerModule(this, name) }
}
public class HirTopLevelModule {
  public let parent: Package
}
impl HirTopLevelModule: HirDeclaration & Equals & Hash & HirModule {
  fun name(): String { "<{parent}>" }
  fun toString(): String { "{parent.path}" }
  fun equals(other: This): Bool { (parent as Equals) == (other.parent as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (parent as Hash).hash<T>(hasher) }
}
public class HirInnerModule {
  public let parent: HirModule
  public let name_: String
}
impl HirInnerModule: HirDeclaration & Equals & Hash & HirModule {
  fun name(): String { name_ }
  fun toString(): String { "{parent}/{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirTrait {
  public let parent: HirModule | HirTrait | HirClass
  public let name_: String
}
impl HirTrait: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirImpl {
  public let parent: HirModule
  public let disambiguator: Int
}
impl HirImpl: HirDeclaration & Equals & Hash {
  fun name(): String { "impl#{disambiguator}" }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && disambiguator == other.disambiguator
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (disambiguator as Hash).hash<T>(hasher)
  }
}

public class HirClass {
  public let parent: HirModule | HirTrait | HirClass
  public let name_: String
}
impl HirClass: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirConstructor {
  public let parent: HirClass
  public let disambiguator: Int
}
impl HirConstructor: HirDeclaration & Equals & Hash {
  fun name(): String { "constructor" }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && disambiguator == other.disambiguator
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (disambiguator as Hash).hash<T>(hasher)
  }
}

public class HirFunction {
  public let parent: HirModule | HirTrait | HirImpl | HirClass
  public let name_: String
  public let disambiguator: Int
}
impl HirFunction: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  fun toString(): String { "{parent}:{name()}#{disambiguator}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals)
      && name_ == other.name_
      && disambiguator == other.disambiguator
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
    (disambiguator as Hash).hash<T>(hasher)
  }
}

public class HirProperty {
  public let parent: HirModule | HirTrait | HirImpl | HirClass
  public let name_: String
}
impl HirProperty: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}
