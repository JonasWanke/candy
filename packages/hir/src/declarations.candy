use compiler_utils
use incremental

use ..expressions
use ..types

public trait HirDeclaration {
  let parent: Package | HirModule | HirTrait | HirImpl
  fun name(): String
  let isSynthetic(): Bool
}

public trait HirModule: HirDeclaration & Equals & Hash {
  static fun core(context: QueryContext<List<CompilerError>>): HirTopLevelModule {
    query<HirTopLevelModule, List<CompilerError>>(context, "HirModule.core", unit, {
      Tuple(HirTopLevelModule(Package.core(context)), List.empty<CompilerError>())
    })
  }
  static fun coreInt(context: QueryContext<List<CompilerError>>): HirModule {
    core(context).innerModule("Int")
  }
  static fun corePrimitives(context: QueryContext<List<CompilerError>>): HirModule {
    core(context).innerModule("Primitives")
  }
  static fun coreString(context: QueryContext<List<CompilerError>>): HirModule {
    core(context).innerModule("String")
  }

  static fun synthetic(context: QueryContext<List<CompilerError>>): HirTopLevelModule {
    query<HirTopLevelModule, List<CompilerError>>(context, "HirModule.synthetic", unit, {
      Tuple(HirTopLevelModule(Package.synthetic(context)), List.empty<CompilerError>())
    })
  }
  static fun syntheticEnums(context: QueryContext<List<CompilerError>>): HirModule {
    synthetic(context).innerModule("Enums")
  }
  static fun syntheticStructs(context: QueryContext<List<CompilerError>>): HirModule {
    synthetic(context).innerModule("Structs")
  }
  static fun syntheticError(context: QueryContext<List<CompilerError>>): HirModule {
    synthetic(context).innerModule("Error")
  }

  let parent: Package | HirModule
  fun innerModule(name: String): HirInnerModule { HirInnerModule(this, name) }
}
public class HirTopLevelModule {
  public let parent: Package
}
impl HirTopLevelModule: HirDeclaration & Equals & Hash & HirModule {
  fun name(): String { "<{parent}>" }
  let isSynthetic(): Bool { false }
  fun toString(): String { "{parent.path}" }
  fun equals(other: This): Bool { (parent as Equals) == (other.parent as Equals) }
  fun hash<T>(hasher: Hasher<T>) { (parent as Hash).hash<T>(hasher) }
}
public class HirInnerModule {
  public let parent: HirModule
  public let name_: String
  public let isSynthetic_: Bool
}
impl HirInnerModule: HirDeclaration & Equals & Hash & HirModule {
  fun name(): String { name_ }
  fun toString(): String { "{parent}/{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirTrait {
  public let parent: HirModule
  public let name_: String
  public let isSynthetic_: Bool

  static fun coreAny(context: QueryContext<List<CompilerError>>): HirTrait {
    HirTrait(HirModule.corePrimitives(context), "Any")
  }
  static fun coreToString(context: QueryContext<List<CompilerError>>): HirTrait {
    HirTrait(HirModule.coreString(context), "ToString")
  }
}
impl HirTrait: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  let isSynthetic(): Bool { this.isSynthetic_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirImpl {
  public let parent: HirModule
  public let disambiguator: Int
  public let isSynthetic_: Bool
}
impl HirImpl: HirDeclaration & Equals & Hash {
  fun name(): String { "impl#{disambiguator}" }
  let isSynthetic(): Bool { this.isSynthetic_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals) && disambiguator == other.disambiguator
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (disambiguator as Hash).hash<T>(hasher)
  }
}

public class HirType {
  public let parent: HirModule
  public let name_: String
  public let isSynthetic_: Bool

  static fun coreInt(context: QueryContext<List<CompilerError>>): HirType {
    HirType(HirModule.coreInt(context), "Int")
  }
  static fun coreNever(context: QueryContext<List<CompilerError>>): HirType {
    HirType(HirModule.corePrimitives(context), "Never")
  }
  static fun coreNothing(context: QueryContext<List<CompilerError>>): HirType {
    HirType(HirModule.corePrimitives(context), "Nothing")
  }
  static fun coreString(context: QueryContext<List<CompilerError>>): HirType {
    HirType(HirModule.coreString(context), "String")
  }
  static fun syntheticError(context: QueryContext<List<CompilerError>>): HirType {
    HirType(HirModule.syntheticError(context), "Error")
  }
}
impl HirType: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  let isSynthetic(): Bool { this.isSynthetic_ }
  fun toString(): String { "{parent}:{name()}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals)
      && name_ == other.name_
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
  }
}

public class HirFunction {
  public let parent: HirModule | HirTrait | HirImpl
  public let name_: String
  public let disambiguator: Int
  public let isSynthetic_: Bool

  public static fun coreToString(context: QueryContext<List<CompilerError>>): HirFunction {
    HirFunction(HirTrait.coreToString(context), "toString", 0)
  }
  public static fun infixEqualEqual(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixEqualEqual", "infixEqualEqual")
  }
  public static fun infixExclamationEqual(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixExclamationEqual", "infixExclamationEqual")
  }
  public static fun infixLess(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixLess", "infixLess")
  }
  public static fun infixLessEqual(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixLessEqual", "infixLessEqual")
  }
  public static fun infixGreater(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixGreater", "infixGreater")
  }
  public static fun infixGreaterEqual(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixGreaterEqual", "infixGreaterEqual")
  }
  public static fun infixPlus(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixPlus", "infixPlus")
  }
  public static fun infixMinus(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixMinus", "infixMinus")
  }
  public static fun infixStar(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixStar", "infixStar")
  }
  public static fun infixSlash(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixSlash", "infixSlash")
  }
  public static fun infixSlashSlash(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixSlashSlash", "infixSlashSlash")
  }
  public static fun infixPercent(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixPercent", "infixPercent")
  }
  public static fun infixAmpersand(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixAmpersand", "infixAmpersand")
  }
  public static fun infixBar(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixBar", "infixBar")
  }
  public static fun infixEqualGreater(context: QueryContext<List<CompilerError>>): HirFunction {
    infix(context, "InfixEqualGreater", "infixEqualGreater")
  }
  public static fun prefixMinus(context: QueryContext<List<CompilerError>>): HirFunction {
    prefix(context, "PrefixMinus", "prefixMinus")
  }

  static fun infix(
    context: QueryContext<List<CompilerError>>,
    traitName: String,
    functionName: String,
  ): HirFunction {
    let module_ = HirTopLevelModule(Package.core(context))
        .innerModule("Operators")
        .innerModule("Raw")
        .innerModule("Infix")
    HirFunction(HirTrait(module_, traitName), functionName, 0)
  }

  static fun prefix(
    context: QueryContext<List<CompilerError>>,
    traitName: String,
    functionName: String,
  ): HirFunction {
    let module_ = HirTopLevelModule(Package.core(context))
        .innerModule("Operators")
        .innerModule("Raw")
        .innerModule("Prefix")
    HirFunction(HirTrait(module_, traitName), functionName, 0)
  }
}
impl HirFunction: HirDeclaration & Equals & Hash {
  fun name(): String { name_ }
  let isSynthetic(): Bool { this.isSynthetic_ }
  fun toString(): String { "{parent}:{name()}#{disambiguator}" }
  fun equals(other: This): Bool {
    (parent as Equals) == (other.parent as Equals)
      && name_ == other.name_
      && disambiguator == other.disambiguator
  }
  fun hash<T>(hasher: Hasher<T>) {
    (parent as Hash).hash<T>(hasher)
    (name_ as Hash).hash<T>(hasher)
    (disambiguator as Hash).hash<T>(hasher)
  }
}

public class HirValueParameter {
  public let scope: HirFunction
  /// The function that the parameter is a part of.
  public let name: String
}
impl HirValueParameter: Equals & Hash {
  fun equals(other: This): Bool {
    (scope as Equals) == (other.scope as Equals) && name == other.name
  }
  fun hash<T>(hasher: Hasher<T>) {
    (scope as Hash).hash<T>(hasher)
    name.hash<T>(hasher)
  }
}
