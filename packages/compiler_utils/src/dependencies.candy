use incremental
use petit_parser
use ..error
use ..file
use ..location
use ..package

class Candyspec {
  public let package: Package
  public let name: String
  public let dependencies: Map<String, Path>
}

impl Package {
  public fun getAllDependencies(context: QueryContext<List<CompilerError>>): Set<Package> {
    /// Returns all dependencies (without this package itself).

    query<Set<Package>, List<CompilerError>>(context, "Package.getAllDependencies", (this as Equals & Hash), {
      Tuple(getAllDependenciesHelper(context, List.empty<Package>()), List.empty<CompilerError>())
    })
  }
  fun getAllDependenciesHelper(
    context: QueryContext<List<CompilerError>>,
    stack: List<Package>,
  ): Set<Package> {
    /// Helper for `getAllDependencies` that checks for cycles.
    query<Set<Package>, List<CompilerError>>(context, "Package.getAllDependenciesHelper", (this as Equals & Hash), {
      if (stack as Iterable<Package>).any({ it == this }) {
        let cycle = (stack as Iterable<Package>).skipWhile({ !(it == this) }).toMutableList()
        cycle.append(this)
        return Tuple(
          List.empty<Package>(),
          List.of1<CompilerError>(
            CyclicDependenciesCompilerError(
              Location(getCandyspecFile(context), Span(0, 1)),
              cycle,
            ),
          ),
        )
      }

      let newStack = (stack as Iterable<Package>).toMutableList()
      newStack.append(this)
      let result = MutableSet.empty<Package>()
      for directDependency in getCandyspec(context).dependencies.values() {
        if (result as Set<Package>).contains(this) { continue }

        for transitiveDependency in directDependency.getAllDependenciesHelper(context, newStack).items() {
          result.insert(transitiveDependency)
        }
      }
      newStack.removeLast()
      Tuple(result, List.empty<CompilerError>())
    })
  }
}
