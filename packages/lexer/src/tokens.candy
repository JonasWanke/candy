public trait Token {
  public let span: Span
}

public data class Span {
  public let start: Int
  /// Start offset, inclusive.

  public let end: Int
  /// End offset, exclusive.
}


public class KeywordToken {
  public let span: Span

  public let keyword: String
  /// May be one of the following:
  ///
  /// * directives: use, crate
  /// * declarations: module, trait, impl, class, fun, let, var, get, set
  /// * control flow: if, else, loop, while, for, return, break, continue
  ///
  /// TODO(JonasWanke): convert this to an enum when we support these
}
impl KeywordToken: Token


public class IdentifierToken {
  public let span: Span
  public let identifier: String
}
impl IdentifierToken: Token


public class LiteralToken<T> {
  public let span: Span
  public let value: T
}
impl<T> LiteralToken<T>: Token


public class PunctuationToken {
  public let span: Span

  public let punctuation: String
  /// May be one of the following:
  ///
  /// `-`, `->`, `,`, `:`, `!=`, `"`, `(`, `)`, `{`, `}`, `*`, `/`, `&`, `%`,
  /// `+`, `<`, `<=`, `=`, `==`, `=>`, `>`, `>=`, `|`, `~/`, `.`
  ///
  /// TODO(JonasWanke): convert this to an enum when we support these
}
impl PunctuationToken: Token


public class CommentToken {
  public let span: Span
  public let content: String

  public let type: String
  /// May be one of the following:
  ///
  /// * "line": `// foo`
  /// * "doc": `/// foo`
  /// * "block": `/* foo\nbar */`
}
impl CommentToken: Token


public class WhitespaceToken {
  public let span: Span
  public let content: String
}
impl WhitespaceToken: Token
