use ..tokens

public fun lex(source: String): List<Token> {
  Lexer(source, 0, 0).lex()
}

class Lexer {
  let source: String
  mut let offset: Int
  mut let length: Int

  fun lex(): List<Token> {
    let tokens = MutableList.empty<Token>()

    loop {
      let char = peek()
      if (char is None<String>) { return tokens }
      let char = char.unwrap()

      let token = comment()
      if token is Some<CommentToken> {
        tokens.append(token.unwrap())
        continue
      }

      let token = punctuation()
      if token is Some<PunctuationToken> {
        tokens.append(token.unwrap())
        continue
      }

      let token = number()
      if token is Some<LiteralToken<Int>> {
        tokens.append(token.unwrap())
        continue
      }

      let token = keywordOrIdentifier()
      if token is Some<KeywordToken | IdentifierToken> {
        tokens.append(token.unwrap())
        continue
      }

      let token = whitespace()
      if token is Some<WhitespaceToken> {
        tokens.append(token.unwrap())
        continue
      }

      let char = advance()
      if char is None<String> {
        print("Invalid char: None<String>()")
      } else {
        print("Invalid char: Some<String>({char.unwrap()})")
      }
      currentLexeme()
    }
  }

  fun keywordOrIdentifier(): Maybe<KeywordToken | IdentifierToken> {
    let peeked = peek()
    if peeked is None<String> { return None<KeywordToken | IdentifierToken>() }
    let peeked = peeked.unwrap()

    let isFirstValid = "a" <= peeked && peeked <= "z"
        || "A" <= peeked && peeked <= "Z"
        || peeked == "_"
    if (!isFirstValid) { return None<KeywordToken | IdentifierToken>() }

    let lexeme = advanceWhile({
      "a" <= it && it <= "z"
        || "A" <= it && it <= "Z"
        || it == "_"
        || "0" <= it && it <= "9"
    })

    if lexeme.second == "use"
        || lexeme.second == "crate"
        || lexeme.second == "module"
        || lexeme.second == "trait"
        || lexeme.second == "impl"
        || lexeme.second == "class"
        || lexeme.second == "fun"
        || lexeme.second == "let"
        || lexeme.second == "var"
        || lexeme.second == "get"
        || lexeme.second == "set"
        || lexeme.second == "return" {
      Some<KeywordToken | IdentifierToken>(KeywordToken(lexeme.first, lexeme.second))
    } else {
      Some<KeywordToken | IdentifierToken>(IdentifierToken(lexeme.first, lexeme.second))
    }
  }

  fun number(): Maybe<LiteralToken<Int>> {
    let peeked = peek()
    if peeked is None<String> { return None<LiteralToken<Int>>() }
    let peeked = peeked.unwrap()

    let isFirstValid = "0" <= peeked && peeked <= "9"
    if (!isFirstValid) { return None<LiteralToken<Int>>() }

    let lexeme = advanceWhile({
      "0" <= it && it <= "9"
    })
    Some<LiteralToken<Int>>(LiteralToken<Int>(lexeme.first, Int.parse(lexeme.second)))
  }

  fun punctuation(): Maybe<PunctuationToken> {
    let operator = peekMulti(2)
    if operator is Some<String> {
      // TODO(JonasWanke): rename this to operator once that doesn't cause a compiler bug
      let unwrapped = operator.unwrap()
      if unwrapped == "<="
          || unwrapped == "=="
          || unwrapped == "=>"
          || unwrapped == ">="
          || unwrapped == "~/"
          || unwrapped == "->"
          || unwrapped == "!=" {
            let lexeme = advanceMulti(2)
            return Some<PunctuationToken>(PunctuationToken(lexeme.first, lexeme.second))
          }
    }
    
    let operator = peek()
    if operator is Some<String> {
      // TODO(JonasWanke): rename this to operator once that doesn't cause a compiler bug
      let unwrapped = operator.unwrap()
      if unwrapped == "+"
          || unwrapped == "<"
          || unwrapped == "-"
          || unwrapped == ","
          || unwrapped == ":"
          || unwrapped == "\🦄"
          || unwrapped == "("
          || unwrapped == ")"
          || unwrapped == "\👍"
          || unwrapped == "}"
          || unwrapped == "*"
          || unwrapped == "/"
          || unwrapped == "&"
          || unwrapped == "%"
          || unwrapped == ">"
          || unwrapped == "|"
          || unwrapped == "="
          || unwrapped == "." {
        let lexeme = advanceMulti(1)
        return Some<PunctuationToken>(PunctuationToken(lexeme.first, lexeme.second))
      }
    }
    None<PunctuationToken>()
  }

  fun comment(): Maybe<CommentToken> {
    let peeked = peek()
    if peeked is None<String> { return None<CommentToken>() }
    let peeked = peeked.unwrap()

    if peekMulti(3) is Some<String> && peekMulti(3).unwrap() == "///" {
      advanceMulti(3)
      let lexeme = advanceWhile({ !isLineBreak(it) })
      Some<CommentToken>(CommentToken(lexeme.first, lexeme.second, "doc"))
    } else {
      if peekMulti(2) is Some<String> && peekMulti(2).unwrap() == "//" {
        advanceMulti(2)
        let lexeme = advanceWhile({ !isLineBreak(it) })
        Some<CommentToken>(CommentToken(lexeme.first, lexeme.second, "line"))
      } else {
        if peekMulti(2) is Some<String> && peekMulti(2).unwrap() == "/*" {
          advanceMulti(2)
          mut let previous = ""
          mut let lexeme = advanceWhile({
            if previous == "*" && it == "/" { return false }
            previous = it
            true
          })
          if advance() is Some<String> {
            // The result can be discarded: We know the characters from the fact that this is a
            // block comment.
            currentLexeme()
            lexeme = Tuple(
              Span(lexeme.first.start, lexeme.first.end - 1),
              lexeme.second.substring(0, lexeme.second.length() - 1)
            )
          }
          Some<CommentToken>(CommentToken(lexeme.first, lexeme.second, "block"))
        } else {
          None<CommentToken>()
        }
      }
    }
  }
  fun whitespace(): Maybe<WhitespaceToken> {
    let peeked = peek()
    if peeked is None<String> { return None<WhitespaceToken>() }
    let peeked = peeked.unwrap()

    if (!isWhitespace(peeked)) { return None<WhitespaceToken>() }

    let lexeme = advanceWhile(isWhitespace)
    return Some<WhitespaceToken>(WhitespaceToken(lexeme.first, lexeme.second))
  }

  fun isLineBreak(char: String): Bool { char == "\r" || char == "\n" }
  fun isWhitespace(char: String): Bool { char == " " || char == "\t" || isLineBreak(char) }

  fun advance(): Maybe<String> {
    let removed = peek()
    if removed is Some<String> { length = length + 1 }
    removed
  }
  fun advanceMulti(length: Int): (Span, String) {
    mut let i = 0
    while i < length {
      advance()
      i = i + 1
    }
    currentLexeme()
  }
  fun advanceWhile(tester: (String) => Bool): (Span, String) {
    while peek().map<Bool>(tester).orElse({ false }) { advance() }
    currentLexeme()
  }

  fun isAtEnd(): Bool { remaining().chars().isEmpty() }
  fun peek(): Maybe<String> {
    if isAtEnd() { return None<String>() }
    Some<String>(remaining().substring(0, 1))
  }
  fun peekMulti(length: Int): Maybe<String> {
    if offset + length > source.length() { return None<String>() }
    Some<String>(remaining().substring(0, length))
  }
  fun remaining(): String { source.substring(offset + length, source.length()) }
  fun currentLexeme(): (Span, String) {
    let result = Tuple(Span(offset, offset + length), source.substring(offset, offset + length))
    offset = offset + length
    length = 0
    result
  }
}
