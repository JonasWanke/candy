bool = use "..bool"
ifElse = (use "..conditionals").ifElse
equals = (use "..equality").equals
function = use "..function"
int = use "..int"
result = use "..result"
list = use "..list"

# An iterable is a `() => Result[(Item, Iterable[Item]), Any]`.
# isWithItemType value checkItem :=
#   result.is value | bool.lazyAnd {
#     value
#     | result.map { current ->
#       list.is current
#       | bool.lazyAnd { equals (current | list.length) 2 }
#       | bool.lazyAnd { checkItem (current | list.get 0) }
#       | bool.lazyAnd (function.is0 (current | list.get 1))
#     }
#     | result.unwrapOr True
#   }
# is value := isWithItemType value { _ -> True }
is value := function.is0 value

next iterable :=
  needs (is iterable)
  iterable | function.run
isEmpty iterable :=
  needs (is iterable)
  iterable | next | result.isOk

newWithStateHelper = { newWithStateHelper state mapper ->
  {
    (mapper state) | result.map { result ->
      ✨.print ("Result:", result)
      newItem = result | list.get 0
      newState = result | list.get 1
      ✨.print ("New state:", newState)
      (newItem, newWithStateHelper newWithStateHelper newState mapper)
    }
  }
}
newWithState initialState mapper :=
  # Creates a new iterator from a state and mapper. The `mapper` receives the
  # current state and returns either one of these:
  #
  # - a `result.ok` containing the item to emit and the new state
  # - a `result.err`, indicating that the iterator is done
  needs (function.is1 mapper)
  newWithStateHelper newWithStateHelper initialState mapper

## Mapping Transformation
##
## These return an iterable with the same length, but different items.

map iterable mapper :=
  needs (is iterable)
  needs (function.is1 mapper)
  newWithState iterable { previousState ->
    previousState | next | result.map { itemAndRest ->
      ✨.print ("Item and rest", itemAndRest)
      item = itemAndRest | list.get 0
      rest = itemAndRest | list.get 1
      (mapper item, rest)
    }
  }

withIndex iterable :=
  needs (is iterable)
  (iterable, 0) | newWithState { previousState ->
    iterable = previousState | list.get 0
    index = previousState | list.get 1
    iterable | next | result.map { itemAndRest ->
      item = itemAndRest | list.get 0
      rest = itemAndRest | list.get 1
      ((item, index), (rest, index | int.add 1))
    }
  }

## Reduction

# TODO: ensure this works with tail recursion
foldLeftHelper = { foldLeftHelper iterable value combine ->
  iterable
  | next
  | result.map { it ->
    currentItem = it | list.get 0
    remainingIterable = it | list.get 1
    newValue = combine value currentItem
    foldLeftHelper foldLeftHelper remainingIterable newValue combine
  }
  | result.unwrapOr value
}
foldLeft iterable initialValue combine :=
  needs (is iterable)
  needs (function.is2 combine)
  foldLeftHelper foldLeftHelper iterable initialValue combine
# TODO: `foldRight`

reduceLeft iterable combine :=
  needs (is iterable)
  needs (function.is2 combine)
  iterable
  | next
  | result.mapError { _ -> "Can't `reduceLeft` an empty iterable" }
  | result.map { it ->
    currentItem = it | list.get 0
    remainingIterable = it | list.get 1
    remainingIterable | foldLeft currentItem combine
  }
# TODO: `reduceRight`

sum iterableOfInt :=
  needs (is iterableOfInt)
  iterableOfInt | reduceLeft { a b ->
    needs (int.is a)
    needs (int.is b)
    a | int.add b
  }
length iterable :=
  needs (is iterable)
  iterable | map { _ -> 1 } | sum | result.unwrapOr 0

all iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft True { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.and itemResult
  }
  # TODO: stop after the first `False`
any iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft False { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.or itemResult
  }
  # TODO: stop after the first `True`

## Filtering

# whereWithStateHelper = { whereWithStateHelper iterable state tester ->
#   iterable | result.map { it ->
#     currentItem = it | list.get 0
#     remainingIterable = it | list.get 1
#     (
#       mapper currentItem,
#       mapHelper mapHelper remainingIterable mapper,
#     )
#   }
# }
# whereWithState iterable initialState tester :=
#   needs (is iterable)
#   needs (function.is2 tester)
#   whereWithStateHelper whereWithStateHelper iterable initialState tester
# where iterable tester :=
#   needs (is iterable)
#   needs (function.is1 tester)

## Action

forEach iterable action :=
  needs (is iterable)
  needs (function.is1 action)
  iterable | map action

## Conversion

fromList l :=
  needs (list.is l)
  # () => Result[(Item, Iterable[Item]), Any]
  # iterable | function.run | result.map { it -> it | list.get 0 }
  # The state contains the list and an index.
  newWithState (l, 0) { state ->
    l = state | list.get 0
    index = state | list.get 1
    ifElse (l | list.isValidIndex index) {
      result.ok (list.get l index, (l, index | int.add 1))
    } {
      result.error Empty
    }
  }

toList iterable :=
  needs (is iterable)
  iterable | foldLeft (,) { result item -> result | list.append item }
