bool = use "..bool"
[ifElse] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
int = use "..int"
result = use "..result"
list = use "..list"

# An iterable is a `() => Result[(Item, Iterable[Item]), Any]`.
# isWithItemType value checkItem :=
#   result.is value | bool.lazyAnd {
#     value
#     | result.map { current ->
#       list.is current
#       | bool.lazyAnd { equals (current | list.length) 2 }
#       | bool.lazyAnd { checkItem (current | list.get 0) }
#       | bool.lazyAnd (function.is0 (current | list.get 1))
#     }
#     | result.unwrapOr True
#   }
# is value := isWithItemType value { _ -> True }
is value := function.is0 value

next iterable :=
  needs (is iterable)
  iterable | function.run
isEmpty iterable :=
  needs (is iterable)
  iterable | next | result.isOk

generateWithStateHelper = { generateWithStateHelper state mapper ->
  {
    mapper state | result.map { result ->
      [newItem, newState] = result
      (newItem, generateWithStateHelper generateWithStateHelper newState mapper)
    }
  }
}
generateWithState initialState mapper :=
  # Creates a new iterator from a state and mapper. The `mapper` receives the
  # current state and returns either one of these:
  #
  # - a `result.ok` containing the item to emit and the new state
  # - a `result.err`, indicating that the iterator is done
  needs (function.is1 mapper)
  generateWithStateHelper generateWithStateHelper initialState mapper

## Mapping Transformation
##
## These return an iterable with the same length, but different items.

map iterable mapper :=
  needs (is iterable)
  needs (function.is1 mapper)
  generateWithState iterable { previousState ->
    previousState | next | result.map { itemAndRest ->
      [item, rest] = itemAndRest
      (mapper item, rest)
    }
  }

withIndex iterable :=
  needs (is iterable)
  generateWithState (iterable, 0) { previousState ->
    [iterable, index] = previousState
    iterable | next | result.map { itemAndRest ->
      [item, rest] = itemAndRest
      ((item, index), (rest, index | int.add 1))
    }
  }

## Reduction

# TODO: ensure this works with tail recursion
foldLeftHelper = { foldLeftHelper iterable value combine ->
  iterable
  | next
  | result.map { it ->
    [currentItem, remainingIterable] = it
    newValue = combine value currentItem
    foldLeftHelper foldLeftHelper remainingIterable newValue combine
  }
  | result.unwrapOr value
}
foldLeft iterable initialValue combine :=
  needs (is iterable)
  needs (function.is2 combine)
  foldLeftHelper foldLeftHelper iterable initialValue combine
# TODO: `foldRight`

reduceLeft iterable combine :=
  needs (is iterable)
  needs (function.is2 combine)
  iterable
  | next
  | result.mapError { _ -> "Can't `reduceLeft` an empty iterable" }
  | result.map { it ->
    [currentItem, remainingIterable] = it
    remainingIterable | foldLeft currentItem combine
  }
# TODO: `reduceRight`

sum iterableOfInt :=
  needs (is iterableOfInt)
  iterableOfInt | reduceLeft { a b ->
    needs (int.is a)
    needs (int.is b)
    a | int.add b
  }
length iterable :=
  needs (is iterable)
  iterable | map { _ -> 1 } | sum | result.unwrapOr 0

all iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft True { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.and itemResult
  }
  # TODO: stop after the first `False`
any iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft False { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.or itemResult
  }
  # TODO: stop after the first `True`

## Filtering

whereHelper = { whereHelper iterable tester ->
  generateWithState iterable { iterable ->
    iterable
    | next
    | result.flatMap { itemAndRest ->
      [item, rest] = itemAndRest
      ifElse (tester item) { result.ok itemAndRest } { whereHelper rest tester | next }
    }
  }
}
where iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  whereHelper whereHelper iterable tester

takeWhile iterable tester = generateWithState iterable { iterable ->
  iterable
  | next
  | result.flatMap { itemAndRest ->
    [item, _] = itemAndRest
    ifElse (tester item) { result.ok itemAndRest } { result.error Empty }
  }
}

takeUntil iterable tester = iterable | takeWhile { item -> tester item | bool.not }

skip iterable n :=
  needs (is iterable)
  needs (int.is n)
  needs (int.isNonNegative n)
  ifElse (equals n 0) { iterable } { skip iterable (int.subtract n 1) }

## Action

forEach iterable action :=
  needs (is iterable)
  needs (function.is1 action)
  iterable | foldLeft Nothing { _ item ->
    action item
    Nothing
  }

## Conversion

fromList l :=
  needs (list.is l)
  # () => Result[(Item, Iterable[Item]), Any]
  # iterable | function.run | result.map { it -> it | list.get 0 }
  # The state contains the list and an index.
  generateWithState (l, 0) { state ->
    [l, index] = state
    ifElse (l | list.isValidIndex index) {
      result.ok (l | list.get index, (l, index | int.add 1))
    } {
      result.error Empty
    }
  }

toList iterable :=
  needs (is iterable)
  iterable | foldLeft (,) { result item -> result | list.append item }
