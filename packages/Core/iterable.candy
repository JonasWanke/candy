bool = use "..bool"
[ifElse, recursive] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
int = use "..int"
result = use "..result"
list = use "..list"
text = use "..text"

# An iterable is a `() -> Result[[Item, Rest: Iterable[Item]], Any]`.
# isWithItemType value checkItem :=
#   result.is value | bool.lazyAnd {
#     value
#     | result.map { current ->
#       list.is current
#       | bool.lazyAnd { equals (current | list.length) 2 }
#       | bool.lazyAnd { checkItem (current | list.get 0) }
#       | bool.lazyAnd (function.is0 (current | list.get 1))
#     }
#     | result.unwrapOr True
#   }
# is value := isWithItemType value { _ -> True }
is value := function.is0 value

next iterable :=
  needs (is iterable)
  iterable | function.run
isEmpty iterable :=
  needs (is iterable)
  iterable | next | result.isError

generateWithState initialState mapper :=
  # Creates a new iterator from a state and mapper. The `mapper` receives the
  # current state and returns either one of these:
  #
  # - an `Ok` of a struct containing the item to emit (`Item`) and the new
  #   state (`State`)
  # - an `Error`, indicating that the iterator is done
  needs (function.is1 mapper)
  recursive initialState { recurse state ->
    {
      mapper state | result.map { result ->
        [item, state] = result
        [item, Rest: recurse state]
      }
    }
  }
generate length valueGetter :=
  # Creates a new iterable of the given `length`, where each slot is filled by calling `valueGetter`
  # with the index.
  needs (int.is length)
  needs (int.isNonNegative length)
  needs (int.fitsInRustU32 length)
  needs (function.is1 valueGetter)

  generateWithState 0 { index ->
    ifElse (index | equals length) { Error Empty } {
      item = valueGetter index
      Ok [item, State: index | int.add 1]
    }
  }

## Mapping Transformation
##
## These return an iterable with the same length, but different items.

map iterable mapper :=
  needs (is iterable)
  needs (function.is1 mapper)
  generateWithState iterable { previousState ->
    previousState | next | result.map { itemAndRest ->
      [item, rest] = itemAndRest
      [Item: mapper item, State: rest]
    }
  }

withIndex iterable :=
  needs (is iterable)
  generateWithState [iterable, Index: 0] { previousState ->
    [iterable, index] = previousState
    iterable | next | result.map { itemAndRest ->
      [item, rest] = itemAndRest
      [Item: [item, index], State: [Iterable: rest, Index: index | int.add 1]]
    }
  }

## Reduction

# TODO: ensure this works with tail recursion
foldLeftHelper = { foldLeftHelper iterable value combine ->
  iterable | next | result.map { it ->
    [item, rest] = it
    newValue = combine value item
    foldLeftHelper foldLeftHelper rest newValue combine
  }
  | result.unwrapOr value
}
foldLeft iterable initialValue combine :=
  needs (is iterable)
  needs (function.is2 combine)
  foldLeftHelper foldLeftHelper iterable initialValue combine
# TODO: `foldRight`

reduceLeft iterable combine :=
  needs (is iterable)
  needs (function.is2 combine)
  iterable | next | result.mapError { _ -> "Can't `reduceLeft` an empty iterable" }
  | result.map { it ->
    [item, rest] = it
    rest | foldLeft item combine
  }
# TODO: `reduceRight`

sum iterableOfInt :=
  needs (is iterableOfInt)
  iterableOfInt | reduceLeft { a b ->
    needs (int.is a)
    needs (int.is b)
    a | int.add b
  }
  | result.unwrapOr 0
length iterable :=
  needs (is iterable)
  iterable | map { _ -> 1 } | sum | result.unwrapOr 0

all iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft True { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.and itemResult
  }
  # TODO: stop after the first `False`
any iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  iterable | foldLeft False { result item ->
    itemResult = tester item
    needs (bool.is itemResult)
    result | bool.or itemResult
  }
  # TODO: stop after the first `True`

joinToText iterable :=
  needs (is iterable)

  iterable | foldLeft "" { result item ->
    needs (text.is item)
    result | text.concatenate item
  }

## Filtering

whereHelper = { whereHelper iterable tester ->
  generateWithState iterable { iterable ->
    iterable | next | result.flatMap { itemAndRest ->
      [item, rest] = itemAndRest
      ifElse (tester item) { Ok [item, State: rest] } { whereHelper rest tester | next }
    }
  }
}
where iterable tester :=
  needs (is iterable)
  needs (function.is1 tester)
  whereHelper whereHelper iterable tester

takeWhile iterable tester := generateWithState iterable { iterable ->
  iterable | next | result.flatMap { itemAndRest ->
    [item, rest] = itemAndRest
    ifElse (tester item) { Ok [item, State: rest] } { Error Empty }
  }
}

takeUntil iterable tester := iterable | takeWhile { item -> tester item | bool.not }

take iterable n :=
  needs (is iterable)
  needs (int.is n)
  needs (int.isNonNegative n)

  iterable | withIndex | takeWhile { it ->
    [item, index] = it
    index | int.isLessThan n
  }
  | map { it -> it.item }

skipHelper = { skipHelper iterable n ->
  ifElse (equals n 0) { iterable } {
    remaining = iterable | next | result.map { it -> it.rest } | result.unwrapOr { }
    skipHelper skipHelper remaining (n | int.subtract 1)
  }
}
skip iterable n :=
  needs (is iterable)
  needs (int.is n)
  needs (int.isNonNegative n)
  skipHelper skipHelper iterable n

## Action

forEach iterable action :=
  needs (is iterable)
  needs (function.is1 action)
  iterable | foldLeft Nothing { _ item ->
    action item
    Nothing
  }

## Conversion

fromList l :=
  needs (list.is l)
  # () => Result[(Item, Iterable[Item]), Any]
  # iterable | function.run | result.map { it -> it | list.get 0 }
  # The state contains the list and an index.
  generateWithState [l, Index: 0] { state ->
    [l, index] = state
    ifElse
      l | list.isValidIndex index
      { Ok [Item: l | list.get index, State: [l, Index: index | int.add 1]] }
      { Error Empty }
  }

toList iterable :=
  needs (is iterable)
  iterable | foldLeft (,) { result item -> result | list.append item }

## Partitioning

windowed iterable size step allowPartialWindows :=
  needs (is iterable)
  needs (int.is size)
  needs (int.isPositive size)
  needs (int.is step)
  needs (int.isPositive step)
  needs (bool.is allowPartialWindows)

  generateWithState iterable { iterable ->
    items = iterable | take size | toList
    length = items | list.length
    isLongEnough = ifElse allowPartialWindows { length | int.isPositive } { length | equals size }
    ifElse isLongEnough { Ok [Item: items, State: iterable | skip step] } { Error Empty }
  }
chunked iterable size :=
  needs (is iterable)
  needs (int.is size)
  needs (int.isPositive size)

  iterable | windowed size size True
