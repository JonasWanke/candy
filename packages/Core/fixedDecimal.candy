bool = use "..bool"
[check] = use "..check"
[ifElse, recursive] = use "..controlFlow"
[equals] = use "..equality"
[run] = use "..function"
int = use "..int"
struct = use "..struct"
tag = use "..tag"
text = use "..text"
[toDebugText] = use "..toDebugText"

isScale scale = int.is scale | bool.lazyAnd { int.isNonNegative scale }
scaleFactor scale =
  needs (scale | isScale)
  10 | int.pow scale

is a := 
  tag.is a | bool.lazyAnd { a | tag.withoutValue | equals FixedDecimal } | bool.lazyAnd {
    value = a | tag.getValue
    struct.is value | bool.lazyAnd { value | struct.hasKey MinorUnits }
    | bool.lazyAnd { int.is value.minorUnits }
    | bool.lazyAnd { value | struct.hasKey Scale }
    | bool.lazyAnd { value.scale | isScale }
  }

minorUnits a :=
  needs (is a)
  (a | tag.getValue).minorUnits
scale a :=
  needs (is a)
  (a | tag.getValue).scale

fromInt a :=
  needs (int.is a)
  FixedDecimal [MinorUnits: a, Scale: 0]
fromIntScaled minorUnits scale :=
  needs (int.is minorUnits)
  needs (scale | isScale)
  FixedDecimal [minorUnits, scale]
floorToInt a :=
  needs (is a)
  a | minorUnits | int.divideTruncating (a | scale | scaleFactor)

rescaledMinorUnits a targetScale =
  needs (is a)
  needs (targetScale | isScale)
  ifElse
    a | scale | int.isGreaterThan targetScale
    { a | minorUnits | int.divideTruncating (scaleFactor (a | scale | int.subtract targetScale)) }
    { a | minorUnits | int.multiply (scaleFactor (targetScale | int.subtract (a | scale))) }
rescale a targetScale :=
  needs (is a)
  needs (targetScale | isScale)
  fromIntScaled (rescaledMinorUnits a targetScale) targetScale
comparableMinorUnits valueA valueB =
  needs (is valueA)
  needs (is valueB)
  targetScale = int.max (valueA | scale) (valueA | scale)
  [
    ValueA: rescaledMinorUnits valueA targetScale,
    ValueB: rescaledMinorUnits valueB targetScale,
    targetScale,
  ]

add summandA summandB :=
  needs (is summandA)
  needs (is summandB)
  [valueA, valueB, targetScale] = comparableMinorUnits summandA summandB
  fromIntScaled (valueA | int.add valueB) targetScale
subtract minuend subtrahend :=
  needs (is minuend)
  needs (is subtrahend)
  [valueA, valueB, targetScale] = comparableMinorUnits minuend subtrahend
  fromIntScaled (valueA | int.subtract valueB) targetScale
negate value :=
  needs (is value)
  fromIntScaled (value | minorUnits | int.negate) (value | scale)
multiply factorA factorB :=
  needs (is factorA)
  needs (is factorB)
  targetScale = factorA | scale | int.add (factorB | scale)
  fromIntScaled
    rescaledMinorUnits factorA targetScale | int.multiply (rescaledMinorUnits factorB targetScale)
    | int.divideTruncating (scaleFactor targetScale)
    targetScale
divide dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  needs (divisor | minorUnits | equals 0 | bool.not) "You can't divide by zero."
  [valueA, valueB, targetScale] = comparableMinorUnits dividend divisor
  fromIntScaled (valueA | int.multiply (targetScale | scaleFactor) | int.divideTruncating (valueB)) targetScale

compareTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  [valueA, valueB] = comparableMinorUnits valueA valueB
  result = valueA | int.compareTo valueB
  check (equals result Equal | bool.implies (equals valueA valueB))
  result
isLessThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Less
isGreaterThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Greater
isLessThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isGreaterThan valueB | bool.not
isGreaterThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isLessThan valueB | bool.not

isPositive value :=
  needs (is value)
  value | minorUnits | int.isGreaterThan 0
isNonPositive value :=
  needs (is value)
  value | isPositive | bool.not
isNegative value :=
  needs (is value)
  value | minorUnits | int.isLessThan 0
isNonNegative value :=
  needs (is value)
  value | isNegative | bool.not
absolute value :=
  needs (is value)
  ifElse (isNegative value) { negate value } { value }

approxEquals a b delta :=
  needs (is a)
  needs (is b)
  needs (is delta)
  needs (isNonNegative delta)
  a | subtract b | absolute | isLessThanOrEqualTo delta

min valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ifElse (valueA | isLessThanOrEqualTo valueB) { valueA } { valueB }
max valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ifElse (valueA | isGreaterThanOrEqualTo valueB) { valueA } { valueB }
coerceAtLeast value minimum :=
  needs (is value)
  needs (is minimum)
  max value minimum
coerceAtMost value maximum :=
  needs (is value)
  needs (is maximum)
  min value maximum
coerceIn value minimum maximum :=
  needs (is value)
  needs (is minimum)
  needs (is maximum)
  needs (minimum | isLessThanOrEqualTo maximum)
  value | coerceAtLeast minimum | coerceAtMost maximum

toText a :=
  needs (is a)
  beforeDot = a | floorToInt | toDebugText
  afterDot = run {
    scaleFactor = a | scale | scaleFactor
    tmp = a | minorUnits | int.remainder scaleFactor
    ifElse (int.isNonNegative tmp) { tmp | int.add scaleFactor | toDebugText | text.removePrefix "1" } {
      tmp | int.subtract scaleFactor | toDebugText | text.removePrefix "-1"
    }
  }
  "{beforeDot}.{afterDot}"
