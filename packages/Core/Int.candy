bool = use "..Bool"
check = use "..Check"
controlFlow = use "..ControlFlow"
equals = (use "..Equality").equals
type = use "..Type"

is value := type.is value Int

add summandA summandB :=
  needs (is summandA)
  needs (is summandB)
  ✨.intAdd summandA summandB
subtract minuend subtrahend :=
  needs (is minuend)
  needs (is subtrahend)
  ✨.intSubtract minuend subtrahend
negate value :=
  needs (is value)
  subtract 0 value
multiply factorA factorB :=
  needs (is factorA)
  needs (is factorB)
  ✨.intMultiply factorA factorB
divideTruncating dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  ✨.intDivideTruncating dividend divisor
modulo dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  ✨.intModulo dividend divisor

compareTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  result = ✨.intCompareTo valueA valueB
  bool.implies (equals result Equal) (equals valueA valueB)
  result
isLessThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Less
isGreaterThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Greater
isLessThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  bool.not (isGreaterThan valueA valueB)
isGreaterThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  bool.not (isLessThan valueA valueB)

isPositive value :=
  needs (is value)
  isGreaterThan value 0
isNonPositive value :=
  needs (is value)
  bool.not (isPositive value)
isNegative value :=
  needs (is value)
  isLessThan value 0
isNonNegative value :=
  needs (is value)
  bool.not (isNegative value)
absolute value :=
  needs (is value)
  controlFlow.ifElse isNegative (negate value) value

fitsInRustU128 value =
  needs (is value)
  needs (isNonNegative value)
  rustU128Max = 340282366920938463463374607431768211455
  isLessThan value rustU128Max
shiftLeft value amount :=
  needs (is value)
  needs (is amount)
  needs (isNonNegative amount)
  needs (fitsInRustU128 amount) "shifts by that much are not yet supported"
  ✨.intShiftLeft value amount
shiftRightArithmetic value amount :=
  needs (is value)
  needs (is amount)
  needs (isNonNegative amount)
  needs (fitsInRustU128 amount) "shifts by that much are not yet supported"
  ✨.intShiftRightArithmetic value amount
shiftRightLogical value amount :=
  needs (is value)
  needs (is amount)
  needs (isNonNegative amount)
  needs (fitsInRustU128 amount) "shifts by that much are not yet supported"
  ✨.intShiftRightLogical value amount

bitLength value :=
  # Determines the fewest bits necessary to express this integer, not including
  # the sign.
  needs (is value)
  ✨.intBitLength value

bitwiseAnd valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ✨.intBitwiseAnd valueA valueB
bitwiseOr valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ✨.intBitwiseOr valueA valueB
bitwiseXor valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  ✨.intBitwiseXor valueA valueB

min valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  controlFlow.ifElse
    (isLessThanOrEqualTo valueA valueB)
    { valueA }
    { valueB }
max valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  controlFlow.ifElse
    (isGreaterThanOrEqualTo valueA valueB)
    { valueA }
    { valueB }
coerceAtLeast value minimum :=
  needs (is value)
  needs (is minimum)
  max value minimum
coerceAtMost value maximum :=
  needs (is value)
  needs (is maximum)
  min value maximum
coerceIn value minimum maximum :=
  needs (is value)
  needs (is minimum)
  needs (is maximum)
  needs (isLessThanOrEqualTo minimum maximum)
  coerceAtMost (coerceAtLeast value minimum) maximum

parse text :=
  needs (type.is text Text)
  ✨.intParse text
