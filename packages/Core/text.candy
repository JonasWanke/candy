bool = use "..bool"
[ifElse] = use "..controlFlow"
[equals] = use "..equality"
int = use "..int"
# iterable = use "..iterable"
list = use "..list"
struct = use "..struct"
type = use "..type"

is value := type.is value Text

fromUtf8 bytes :=
  needs (list.is bytes)
  # TODO: Add this when it runs faster.
  # needs (bytes | iterable.fromList | iterable.all { byte ->
  #   bool.lazyAnd (int.is byte) {
  #     bool.and (byte | int.isNonNegative) (byte | int.isLessThan 256)
  #   }
  # })

  bytes | ✨.textFromUtf8

isEmpty text :=
  needs (is text)
  text | ✨.textIsEmpty
length text :=
  # Returns the number of Unicode grapheme clusters in this text.
  needs (is text)
  text | ✨.textLength

characters text :=
  needs (is text)
  text | ✨.textCharacters
characterAt text index :=
  needs (is text)
  needs (int.is index)
  needs (int.isNonNegative index)
  needs (int.isLessThan index (length text))
  text | characters | list.get index

getRange text startInclusive endExclusive :=
  needs (is text)

  needs (int.is startInclusive)
  needs (int.isNonNegative startInclusive)

  needs (int.is endExclusive)
  needs (int.isNonNegative endExclusive)

  needs (int.isLessThanOrEqualTo startInclusive endExclusive)
  needs (int.isLessThanOrEqualTo endExclusive (length text))

  # TODO: Support ranges when we have them.
  text | ✨.textGetRange startInclusive endExclusive

concatenate textA textB :=
  needs (is textA)
  needs (is textB)
  textA | ✨.textConcatenate textB

startsWith text pattern :=
  needs (is text)
  needs (is pattern)
  text | ✨.textStartsWith pattern
endsWith text pattern :=
  needs (is text)
  needs (is pattern)
  text | ✨.textEndsWith pattern
contains text pattern :=
  needs (is text)
  needs (is pattern)
  text | ✨.textContains pattern

removePrefix text prefix :=
  needs (is text)
  needs (is prefix)
  ifElse
    (text | startsWith prefix)
    { text | getRange (prefix | length) (text | length) }
    { text }
removeSuffix text suffix :=
  needs (is text)
  needs (is suffix)
  textLength = text | length
  ifElse
    endsWith text suffix
    { text | getRange (textLength | int.subtract (suffix | length)) textLength }
    { text }

trimStart text :=
  needs (is text)
  text | ✨.textTrimStart
trimEnd text :=
  needs (is text)
  text | ✨.textTrimEnd
trim text :=
  needs (is text)
  text | trimStart | trimEnd
