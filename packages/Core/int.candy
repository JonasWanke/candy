bool = use "..bool"
check = (use "..check").check
conditionals = use "..conditionals"
equals = (use "..equality").equals
type = use "..type"

is value := type.is value Int

add summandA summandB :=
  needs (is summandA)
  needs (is summandB)
  summandA | ✨.intAdd summandB
subtract minuend subtrahend :=
  needs (is minuend)
  needs (is subtrahend)
  minuend | ✨.intSubtract subtrahend
negate value :=
  needs (is value)
  subtract 0 value
multiply factorA factorB :=
  needs (is factorA)
  needs (is factorB)
  factorA | ✨.intMultiply factorB
divideTruncating dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  dividend | ✨.intDivideTruncating divisor
remainder dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  dividend | ✨.intRemainder divisor
modulo dividend divisor :=
  needs (is dividend)
  needs (is divisor)
  dividend | ✨.intModulo divisor

compareTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  result = valueA | ✨.intCompareTo valueB
  check (equals result Equal | bool.implies (equals valueA valueB))
  # check ((equals result Equal) | bool.implies (equals valueA valueB))
  result
isLessThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Less
isGreaterThan valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  equals (compareTo valueA valueB) Greater
isLessThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isGreaterThan valueB | bool.not
isGreaterThanOrEqualTo valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | isLessThan valueB | bool.not

isPositive value :=
  needs (is value)
  value | isGreaterThan 0
isNonPositive value :=
  needs (is value)
  value | isPositive | bool.not
isNegative value :=
  needs (is value)
  value | isLessThan 0
isNonNegative value :=
  needs (is value)
  value | isNegative | bool.not
absolute value :=
  needs (is value)
  conditionals.ifElse (isNegative value) (negate value) value

fitsInRustU32 value :=
  needs (is value)
  needs (isNonNegative value)

  rustU32Max = 4294967295
  # https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX
  value | isLessThan rustU32Max
fitsInRustU128 value :=
  needs (is value)
  needs (isNonNegative value)

  rustU128Max = 340282366920938463463374607431768211455
  # https://doc.rust-lang.org/std/primitive.u128.html#associatedconstant.MAX
  value | isLessThan rustU128Max

shiftLeft value amount :=
  needs (is value)
  needs (is amount)
  needs (isNonNegative amount) "The shift `amount` is negative. You might want to call `shiftRight` instead."
  # TODO: Add the negated value in the error message as soon as we support string interpolation.
  needs (fitsInRustU128 amount) "Shifts by that much are not yet supported."
  value | ✨.intShiftLeft amount
shiftRight value amount :=
  needs (is value)
  needs (is amount)
  needs (isNonNegative amount) "The shift `amount` is negative. You might want to call `shiftLeft` instead."
  # TODO: Add the negated value in the error message as soon as we support string interpolation.
  needs (fitsInRustU128 amount) "Shifts by that much are not yet supported."
  value | ✨.intShiftRight amount

bitLength value :=
  # Determines the fewest bits necessary to express this integer, not including
  # the sign.
  needs (is value)
  value | ✨.intBitLength

bitwiseAnd valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | ✨.intBitwiseAnd valueB
bitwiseOr valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | ✨.intBitwiseOr valueB
bitwiseXor valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  valueA | ✨.intBitwiseXor valueB

isEven value :=
  needs (is value)
  equals (bitwiseAnd value 1) 0
isOdd value :=
  needs (is value)
  isOdd = equals (bitwiseAnd value 1) 1
  check (value | isEven | equals (isOdd | bool.not))
  isOdd

min valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  conditionals.ifElse
    (valueA | isLessThanOrEqualTo valueB)
    { valueA }
    { valueB }
max valueA valueB :=
  needs (is valueA)
  needs (is valueB)
  conditionals.ifElse
    (valueA | isGreaterThanOrEqualTo valueB)
    { valueA }
    { valueB }
coerceAtLeast value minimum :=
  needs (is value)
  needs (is minimum)
  max value minimum
coerceAtMost value maximum :=
  needs (is value)
  needs (is maximum)
  min value maximum
coerceIn value minimum maximum :=
  needs (is value)
  needs (is minimum)
  needs (is maximum)
  needs (minimum | isLessThanOrEqualTo maximum)
  value | coerceAtLeast minimum | coerceAtMost maximum

parse text :=
  needs (type.is text Text)
  text | ✨.intParse
