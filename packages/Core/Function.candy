equals = (use "..Equality").equals
type = use "..Type"

is value := type.is value Function

getArgumentCount function :=
  needs (is function)
  ✨.getArgumentCount function

is0 value := ✨.ifElse (is value) { equals (getArgumentCount value) 0 } { False }
is1 value := ✨.ifElse (is value) { equals (getArgumentCount value) 1 } { False }
is2 value := ✨.ifElse (is value) { equals (getArgumentCount value) 2 } { False }
is3 value := ✨.ifElse (is value) { equals (getArgumentCount value) 3 } { False }
is4 value := ✨.ifElse (is value) { equals (getArgumentCount value) 4 } { False }
is5 value := ✨.ifElse (is value) { equals (getArgumentCount value) 5 } { False }

run body =
  # A function that runs the given `body` with no arguments and returns its result.
  #
  # ```
  # a = run {
  #   ## Some code that can create local variables without cluttering the surrounding namespace.
  # }
  # ```
  needs (is body)
  ✨.functionRun body

doNotRun body =
  # A function that doesn't run the given `body`.
  #
  # This function is useful during development to mark code that's not ready to run yet. In contrast
  # to commenting out the code, the code is still part of the analyzed program.
  #
  # These are some of the benefits over commenting code out:
  #
  # * Refactorings, like renaming of functions, also affect the code.
  # * Candy doesn't report linter warnings for fields and functions in the outer scope that are
  #   only used in the code.
  # * Making the code invalid (for example, by deleting needed functions) results in compiler
  #   errors.
  needs (is body)
  Nothing
