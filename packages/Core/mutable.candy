# Sometimes, the most intuitive way to express an algorithm involves mutable
# state. In Candy, most values are immutable â€“ only fibers and channels allow
# changing the state over time.

## How does this work? The `inScope` function spawns a fiber that keeps track of
## the value. You can request it to get and set the current value.

channel = use "..channel"
[async, await, parallel] = use "..concurrency"
[recursive] = use "..controlFlow"
function = use "..function"

inScope initialValue body :=
  needs (function.is1 body)
  parallel { nursery ->
    requests = channel.create 1
    nursery | async {
      body requests.sendPort
      requests.sendPort | channel.send Quit
    }
    recursive initialValue { recurse value ->
      requests.receivePort | channel.receive %
        (Get, answerPort) ->
          needs (channel.isSendPort answerPort)
          answerPort | channel.send value
          recurse value
        (Set, newValue) -> recurse newValue
        Quit -> value
    }
  }

set mutable newValue :=
  needs (channel.isSendPort mutable)
  mutable | channel.send (Set, newValue)

get mutable :=
  needs (channel.isSendPort mutable)
  answerChannel = channel.create 1
  mutable | channel.send (Get, answerChannel.sendPort)
  channel.receive answerChannel.receivePort
