bool = use "..bool"
[ifElse] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
struct = use "..struct"
tag = use "..tag"
type = use "..type"

is value := value %
  Ok _ | Error _ -> True
  _ -> False

getValue result :=
  needs (is result)
  result | tag.getValue

isOk result :=
  needs (is result)
  result | tag.withoutValue | equals Ok
unwrap result :=
  needs (is result)
  needs (isOk result)
  result | getValue
expect result message :=
  needs (is result)
  needs (type.is message Text)
  needs (isOk result) message
  result | getValue

isError result :=
  needs (is result)
  result | tag.withoutValue | equals Error
unwrapError result :=
  needs (is result)
  needs (isError result)
  result | getValue
expectError result message :=
  needs (is result)
  needs (type.is message Text)
  needs (isError result) message
  result | getValue

mapOrElse result okMapper errorMapper :=
  # Returns `okMapper result.value` if `isOk result` and
  # `errorMapper result.value` if `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  needs (function.is1 errorMapper)
  result %
    Ok value -> okMapper value
    Error value -> errorMapper value
mapOr result okMapper errorValue :=
  # Returns `okMapper result.value` if `isOk result` and `errorValue` if
  # `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  result | mapOrElse okMapper { value -> errorValue }

flatMap result okMapper :=
  # Returns `okMapper result.value` if `isOk result` and `result` if it
  # `isError`.
  #
  # `okMapper` can also return a result. This is useful for chaining together
  # multiple computations that may fail.
  needs (is result)
  needs (function.is1 okMapper)
  result | mapOr { value -> okMapper value } result
map result okMapper :=
  # Returns `Ok (okMapper result.value)` if it `isOk` and `result` if it
  # `isError`.
  needs (is result)
  needs (function.is1 okMapper)
  result | flatMap { value -> Ok (okMapper value) }
and resultA resultB :=
  # Returns `resultA` if it `isError` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMap { value -> resultB }

flatMapError result errorMapper :=
  # Returns `result` if it `isOk` and `errorMapper result.value` if it
  # `isError`.
  #
  # `errorMapper` can also return a result.
  needs (is result)
  needs (function.is1 errorMapper)
  result | mapOrElse { value -> result } { value -> errorMapper value }
mapError result errorMapper :=
  # Returns `result` if it `isOk` and `Error (errorMapper result.value)` if it
  # `isError`.
  needs (is result)
  needs (function.is1 errorMapper)
  result | flatMapError { value -> Error (errorMapper value) }
or resultA resultB :=
  # Returns `resultA` if it `isOk` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMapError { value -> resultB }

unwrapOrElse result defaultGetter :=
  needs (is result)
  needs (function.is0 defaultGetter)
  result | mapOrElse { value -> value } { value -> function.run defaultGetter }
unwrapOr result default :=
  needs (is result)
  unwrapOrElse result { default }

flatten resultOfResult :=
  needs (is resultOfResult)
  resultOfResult | flatMap { innerResult ->
    needs (is innerResult)
    innerResult
  }

test =
  [checkEquals] = use "..check"
  int = use "..int"

  checkEquals (is (Ok 4)) True
  checkEquals (is (Error 4)) True
  checkEquals (is 4) False

  checkEquals (getValue (Ok 4)) 4
  checkEquals (getValue (Error 4)) 4

  checkEquals (isOk (Error 4)) False
  checkEquals (isOk (Ok 4)) True

  checkEquals (unwrap (Ok 4)) 4
  checkEquals (expect (Ok 4) "blub") 4

  checkEquals (isError (Error 4)) True
  checkEquals (isError (Ok 4)) False

  checkEquals (unwrapError (Error 4)) 4
  checkEquals (expectError (Error 4) "blub") 4

  checkEquals (mapOrElse (Ok 4) { a -> int.add a 1 } { a -> int.add a 2 }) 5
  checkEquals (mapOrElse (Error 4) { a -> int.add a 1 } { a -> int.add a 2 }) 6

  checkEquals (mapOr (Ok 4) { a -> int.add a 1 } 2) 5
  checkEquals (mapOr (Error 4) { a -> int.add a 1 } 2) 2

  checkEquals (flatMap (Ok 1) { a -> Ok (int.add a 1) }) (Ok 2)
  checkEquals (flatMap (Error 1) { a -> Ok (int.add a 1) }) (Error 1)
  checkEquals (flatMap (Ok 1) { a -> Error 3 }) (Error 3)

  checkEquals (map (Ok 1) { a -> int.add a 1 }) (Ok 2)
  checkEquals (map (Error 1) { a -> int.add a 1 }) (Error 1)

  checkEquals (and (Ok 1) (Ok 2)) (Ok 2)
  checkEquals (and (Ok 1) (Error 2)) (Error 2)
  checkEquals (and (Error 1) (Ok 2)) (Error 1)
  checkEquals (and (Error 1) (Error 2)) (Error 1)

  checkEquals (flatMapError (Ok 1) { a -> Ok (int.add a 1) }) (Ok 1)
  checkEquals (flatMapError (Error 1) { a -> Ok (int.add a 1) }) (Ok 2)
  checkEquals (flatMapError (Error 1) { a -> Error (int.add a 1) }) (Error 2)

  checkEquals (mapError (Ok 1) { a -> int.add a 1 }) (Ok 1)
  checkEquals (mapError (Error 1) { a -> int.add a 1 }) (Error 2)

  checkEquals (or (Ok 1) (Ok 2)) (Ok 1)
  checkEquals (or (Ok 1) (Error 2)) (Ok 1)
  checkEquals (or (Error 1) (Ok 2)) (Ok 2)
  checkEquals (or (Error 1) (Error 2)) (Error 2)

  checkEquals (unwrapOrElse (Ok 1) { 2 }) 1
  checkEquals (unwrapOrElse (Error 1) { 2 }) 2

  checkEquals (unwrapOr (Ok 1) 2) 1
  checkEquals (unwrapOr (Error 1) 2) 2

  checkEquals (flatten (Error 1)) (Error 1)
  checkEquals (flatten (Ok (Error 1))) (Error 1)
  checkEquals (flatten (Ok (Ok 1))) (Ok 1)
