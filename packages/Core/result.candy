bool = use "..bool"
[ifElse] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
struct = use "..struct"
tag = use "..tag"

is value := value %
  Ok _ | Error _ -> True
  _ -> False

getValue result :=
  needs (is result)
  result | tag.getValue

isOk result :=
  needs (is result)
  result | tag.withoutValue | equals Ok
unwrap result :=
  needs (is result)
  needs (isOk result)
  result | result.getValue
expect result message :=
  needs (is result)
  needs (isOk result) message
  result | result.getValue

isError result :=
  needs (is result)
  result | tag.withoutValue | equals Error
unwrapError result :=
  needs (is result)
  needs (isError result)
  result | result.getValue
expectError result message :=
  needs (is result)
  needs (isError result) message
  result | result.getValue

mapOrElse result okMapper errorMapper :=
  # Returns `okMapper result.value` if `isOk result` and
  # `errorMapper result.value` if `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  needs (function.is1 errorMapper)
  result %
    Ok value -> okMapper value
    Error value -> errorMapper value
mapOr result okMapper errorValue :=
  # Returns `okMapper result.value` if `isOk result` and `errorValue` if
  # `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  result | mapOrElse okMapper { value -> errorValue }

flatMap result okMapper :=
  # Returns `okMapper result.value` if `isOk result` and `result` if it
  # `isError`.
  #
  # `okMapper` can also return a result. This is useful for chaining together
  # multiple computations that may fail.
  needs (is result)
  needs (function.is1 okMapper)
  result | mapOr { value -> okMapper value } result
map result okMapper :=
  # Returns `Ok (okMapper result.value)` if it `isOk` and `result` if it
  # `isError`.
  needs (is result)
  needs (function.is1 okMapper)
  result | flatMap { value -> Ok (okMapper value) }
and resultA resultB :=
  # Returns `resultA` if it `isError` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMap { value -> resultB }

flatMapError result errorMapper :=
  # Returns `result` if it `isOk` and `errorMapper result.value` if it
  # `isError`.
  #
  # `errorMapper` can also return a result.
  needs (is result)
  needs (function.is1 errorMapper)
  result | mapOrElse { value -> result } { value -> errorMapper value }
mapError result errorMapper :=
  # Returns `result` if it `isOk` and `Error (errorMapper result.value)` if it
  # `isError`.
  needs (is result)
  needs (function.is1 errorMapper)
  result | flatMapError { value -> Error (errorMapper value) }
or resultA resultB :=
  # Returns `resultA` if it `isOk` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMapError { value -> resultB }

unwrapOrElse result defaultGetter :=
  needs (is result)
  result | mapOrElse { value -> value } { value -> function.run defaultGetter }
unwrapOr result default :=
  needs (is result)
  unwrapOrElse result { default }

flatten resultOfResult :=
  needs (is resultOfResult)
  resultOfResult | flatMap { innerResult ->
    needs (is innerResult)
    innerResult
  }
