bool = use "..bool"
equals = (use "..equality").equals
function = use "..function"
ifElse = (use "..controlFlow").ifElse
struct = use "..struct"

is value :=
  struct.is value | bool.lazyAnd {
    value
    | struct.hasKey Type
    | bool.and (value | struct.hasKey Value)
    | bool.lazyAnd {
      type = value.type
      equals type Ok | bool.or (equals type Error)
    }
  }

ok value := [Type: Ok, Value: value]
isOk result :=
  needs (is result)
  equals result.type Ok
unwrap result :=
  needs (is result)
  needs (isOk result)
  result.value
expect result message :=
  needs (is result)
  needs (isOk result) message
  result.value

error value := [Type: Error, Value: value]
isError result :=
  needs (is result)
  equals result.type Error
unwrapError result :=
  needs (is result)
  needs (isError result)
  result.value
expectError result message :=
  needs (is result)
  needs (isError result) message
  result.value

mapOrElse result okMapper errorMapper :=
  # Returns `okMapper result.value` if `isOk result` and
  # `errorMapper result.value` if `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  needs (function.is1 errorMapper)
  ifElse
    equals result.type Ok
    { okMapper result.value }
    { errorMapper result.value }
mapOr result okMapper errorValue :=
  # Returns `okMapper result.value` if `isOk result` and `errorValue` if
  # `isError result`.
  needs (is result)
  needs (function.is1 okMapper)
  result | mapOrElse okMapper { value -> errorValue }

flatMap result okMapper :=
  # Returns `okMapper result.value` if `isOk result` and `result` if it
  # `isError`.
  #
  # `okMapper` can also return a result. This is useful for chaining together
  # multiple computations that may fail.
  needs (is result)
  needs (is function.is1 okMapper)
  result | mapOr { value -> okMapper value } result
map result okMapper :=
  # Returns `ok (okMapper result.value)` if it `isOk` and `result` if it
  # `isError`.
  needs (is result)
  needs (function.is1 okMapper)
  result | flatMap { value -> ok (okMapper value) }
and resultA resultB :=
  # Returns `resultA` if it `isError` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMap { value -> resultB }

flatMapError result errorMapper :=
  # Returns `result` if it `isOk` and `errorMapper result.value` if it
  # `isError`.
  #
  # `errorMapper` can also return a result.
  needs (is result)
  needs (is function.is1 errorMapper)
  result | mapOr { value -> result } { value -> errorMapper value }
mapError result errorMapper :=
  # Returns `result` if it `isOk` and `error (errorMapper result.value)` if it
  # `isError`.
  needs (is result)
  needs (function.is1 errorMapper)
  result | flatMapError { value -> error (errorMapper value) }
or resultA resultB :=
  # Returns `resultA` if it `isOk` and `resultB` otherwise.
  needs (is resultA)
  needs (is resultB)
  resultA | flatMapError { value -> resultB }

unwrapOrElse result defaultGetter :=
  needs (is result)
  result | mapOrElse { value -> value } { value -> function.call defaultGetter }
unwrapOr result default :=
  needs (is result)
  unwrapOrElse result { default }

flatten resultOfResult :=
  needs (is resultOfResult)
  resultOfResult | flatMap { innerResult ->
    needs (is innerResult)
    innerResult
  }
