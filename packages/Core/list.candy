bool = use "..bool"
[ifElse] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
int = use "..int"
result = use "..result"
type = use "..type"

filled length item :=
  needs (int.is length)
  needs (int.isNonNegative length)
  needs (int.fitsInRustU32 length)
  ✨.listFilled length item
# TODO: `generate length valueGetter` when we have loops

is value := type.is value List

length list :=
  needs (is list)
  list | ✨.listLength
isEmpty list :=
  needs (is list)
  equals (length list) 0

lastIndex list :=
  needs (is list)
  ifElse
    (list | isEmpty)
    { result.error "Can't get the last index of an empty list." }
    { list | length | int.subtract 1 | result.ok }
isValidIndex list index :=
  needs (is list)
  needs (int.is index)
  ifElse
    (list | isEmpty)
    { False }
    { index | int.isNonNegative }
  | bool.lazyAnd { index | int.isLessThanOrEqualTo (list | lastIndex | result.unwrap) }

get list index :=
  needs (is list)
  needs (list | isValidIndex index)
  list | ✨.listGet index

# TODO: add `single list` when we have pattern matching
last list :=
  needs (is list)
  list | lastIndex
  | result.mapError "Can't get the last item of an empty list."
  | result.map { index -> list | get index }

insert list index item :=
  needs (is list)

  needs (int.is index)
  needs (int.isNonNegative index)
  needs (index | int.isLessThanOrEqualTo (length list))

  list | ✨.listInsert index item

prepend list item :=
  needs (is list)
  list | insert 0 item
append list item :=
  needs (is list)
  list | insert (length list) item

replace list index newValue :=
  needs (is list)
  needs (isValidIndex index)
  list | ✨.listReplace index newValue
update list index updater :=
  needs (is list)
  needs (isValidIndex index)
  needs (function.is1 updater)
  oldValue = list | get index
  newValue = updater oldValue
  list | replace index newValue

removeAt list index :=
  needs (is list)
  needs (isValidIndex index)
  list | ✨.listRemoveAt index
