builtins = use "Builtins"
bool = use "..bool"
[ifElse, recursive] = use "..controlFlow"
[equals] = use "..equality"
function = use "..function"
int = use "..int"
result = use "..result"
type = use "..type"

is value := type.is value List

length := builtins.listLength
isEmpty list :=
  needs (is list)
  equals (length list) 0

lastIndex list :=
  needs (is list)
  ifElse (list | isEmpty) { Error Empty } {
    Ok (list | length | int.subtract 1)
  }
isValidIndex list index :=
  needs (is list)
  needs (int.is index)
  ifElse (list | isEmpty) { False } { index | int.isNonNegative }
  | bool.lazyAnd { index | int.isLessThanOrEqualTo (list | lastIndex | result.unwrap) }
isValidInsertIndex list index :=
  needs (is list)
  needs (int.is index)
  ifElse (list | isEmpty) { False } { index | int.isNonNegative }
  | bool.lazyAnd { index | int.isLessThanOrEqualTo (list | length) }

get := builtins.listGet

single list :=
  needs (is list)
  list %
    (,) -> Error Empty
    (item,) -> Ok item
    _ -> Error MoreThanOneItem
first list :=
  needs (is list)
  list %
    (,) -> Error Empty
    _ -> Ok (list | get 0)
last list :=
  needs (is list)
  list | lastIndex | result.mapError { _ -> Empty }
  | result.map { index -> list | get index }

insert := builtins.listInsert

prepend list item :=
  needs (is list)
  list | insert 0 item
append list item :=
  needs (is list)
  list | insert (length list) item

replace := builtins.listReplace
update list index updater :=
  needs (is list)
  needs (int.is index)
  needs (list | isValidIndex index)
  needs (function.is1 updater)
  oldValue = list | get index
  newValue = updater oldValue
  list | replace index newValue

removeAt := builtins.listRemoveAt

filled := builtins.listFilled
generate length valueGetter :=
  # Creates a new list of the given `length`, where each slot is filled by calling `valueGetter`
  # with the index.
  needs (int.is length)
  needs (int.isNonNegative length)
  needs (int.fitsInRustU32 length)
  needs (function.is1 valueGetter)

  list = filled length Placeholder
  recursive [list, Index: 0] { recurse [list, index] ->
    ifElse (index | equals length) { list } {
      item = valueGetter index
      list = list | replace index item
      recurse [list, Index: int.add index 1]
    }
  }

getRange list startInclusive endExclusive :=
  needs (is list)
  needs (int.is startInclusive)
  needs (startInclusive | int.isNonNegative)
  needs (startInclusive | int.isLessThanOrEqualTo (list | length))
  needs (int.is endExclusive)
  needs (endExclusive | int.isNonNegative)
  needs (endExclusive | int.isLessThanOrEqualTo (list | length))
  needs (startInclusive | int.isLessThanOrEqualTo endExclusive)
  generate (endExclusive | int.subtract startInclusive) { index ->
    list | get (startInclusive | int.add index)
  }

concatenate listA listB :=
  needs (is listA)
  needs (is listB)
  generate (listA | length | int.add (listB | length)) { index ->
    ifElse (index | int.isLessThan (listA | length)) { listA | get index } {
      listB | get (index | int.subtract (listA | length))
    }
  }

test =
  [checkEquals] = use "..check"

  checkEquals (is (1, 2, 3)) True
  checkEquals (is Hello) False

  checkEquals (length (1, 2, 3)) 3
  checkEquals (length (3, 3)) 2

  checkEquals (isEmpty (,)) True

  checkEquals (lastIndex (1, 2, 3)) (Ok 2)
  checkEquals (lastIndex (3, 3)) (Ok 1)
  checkEquals (lastIndex (,)) (Error Empty)

  checkEquals (isValidIndex (1, 2, 3) (int.negate 1)) False
  checkEquals (isValidIndex (1, 2, 3) 0) True
  checkEquals (isValidIndex (1, 2, 3) 1) True
  checkEquals (isValidIndex (1, 2, 3) 2) True
  checkEquals (isValidIndex (1, 2, 3) 3) False
  checkEquals (isValidIndex (1, 2, 3) 4) False
  checkEquals (isValidIndex (1, 2, 3) 100) False

  checkEquals (isValidInsertIndex (1, 2, 3) (int.negate 1)) False
  checkEquals (isValidInsertIndex (1, 2, 3) 0) True
  checkEquals (isValidInsertIndex (1, 2, 3) 1) True
  checkEquals (isValidInsertIndex (1, 2, 3) 2) True
  checkEquals (isValidInsertIndex (1, 2, 3) 3) True
  checkEquals (isValidInsertIndex (1, 2, 3) 4) False
  checkEquals (isValidInsertIndex (1, 2, 3) 100) False

  checkEquals (get (Foo, Bar, Baz) 0) Foo
  checkEquals (get (Foo, Bar, Baz) 1) Bar
  checkEquals (get (Foo, Bar, Baz) 2) Baz

  checkEquals (single (,)) (Error Empty)
  checkEquals (single (Foo,)) (Ok Foo)
  checkEquals (single (Foo, Bar)) (Error TooLong)

  checkEquals (first (,)) (Error Empty)
  checkEquals (first (Foo,)) (Ok Foo)
  checkEquals (first (Foo, Bar)) (Ok Foo)

  checkEquals (last (,)) (Error Empty)
  checkEquals (last (Foo,)) (Ok Foo)
  checkEquals (last (Foo, Bar)) (Ok Bar)

  checkEquals (insert (Foo, Bar) 0 Baz) (Baz, Foo, Bar)
  checkEquals (insert (Foo, Bar) 1 Baz) (Foo, Baz, Bar)
  checkEquals (insert (Foo, Bar) 2 Baz) (Foo, Bar, Baz)

  checkEquals (prepend (Foo, Bar) Baz) (Baz, Foo, Bar)

  checkEquals (append (Foo, Bar) Baz) (Foo, Bar, Baz)

  checkEquals (replace (Foo, Bar) 0 Baz) (Baz, Bar)
  checkEquals (replace (Foo, Bar) 1 Baz) (Foo, Baz)

  checkEquals (update (1, 2) 0 { a -> int.add a 1 }) (2, 2)

  checkEquals (removeAt (Foo, Bar) 0) (Bar,)
  checkEquals (removeAt (Foo, Bar) 1) (Foo,)

  checkEquals (filled 2 Foo) (Foo, Foo)
  checkEquals (filled 10 1) (1, 1, 1, 1, 1, 1, 1, 1, 1, 1)

  checkEquals (generate 5 { a -> a }) (0, 1, 2, 3, 4)

  checkEquals (getRange (1, 2, 3, 4, 5) 1 4) (2, 3, 4)

  checkEquals (concatenate (1, 2, 3) (4, 5)) (1, 2, 3, 4, 5)
