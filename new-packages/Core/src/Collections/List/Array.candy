use ...Int
use ...Panic
use ..Iterate
use ..List

public builtin type Array[Item]
# A structure that holds a fixed number of `Item`s.

impl[Item] Array[Item] {
  public static fun filled[Item](length: Int /* UInt */, item: Item): Array[Item] {
    # Creates a new `Array` of the given `length`, where every slot is filled with the same `item`.

    generate[Item](length, { item })
  }

  public static builtin fun generate[Item](length: Int, generator: (Int) -> Item): Array[Item]
  # Creates a new `Array` of the given `length` where the `generator` is invoked with indices to
  # generate items to fill the slots.

  public static fun empty[Item](): Array[Item] {
    generate[Item](0, { panic("Generation of an empty `Array` called the generator function.") })
  }
  public static fun of[Item](first: Item): Array[Item] { generate[Item](1, { first }) }
  public static fun of[Item](first: Item, second: Item): Array[Item] {
    generate[Item](2, { if(it == 0, { first }).else({ second }) })
  }
  public static fun of[Item](first: Item, second: Item, third: Item): Array[Item] {
    generate[Item](3, { if(it == 0, { first }).else({ if(it == 1, ({ second }).else({ third }) }) })
  }
}

impl[Item] Array[Item]: List[Item] {
  public builtin fun length(): Int

  public builtin fun get(index: Int /* UInt */): Maybe[Item]
}

impl[Item] Array[Item]: Iterate[Item] {
  fun iterate(): Maybe[(Item, Iterate[Item])] { ArrayIterate[Item](this, 0).iterate() }

  fun toList(): List[Item] { this }
}
type ArrayIterate[Item] = (array: Array[Item], cursor: Int = 0)
impl[Item] ArrayIterate[Item]: Iterate[Item] {
  fun iterate(): Maybe[(Item, Iterate[Item])] {
    if(this.cursor == this.array.length(), {
      Maybe[(Item, Iterate[Item])].None()
    }).else({
      Maybe[(Item, Iterate[Item])].Some((
        this.array.get(this.cursor),
        ArrayIterate[Item](this.array, this.cursor + 1),
      ))
    })
  }
}
