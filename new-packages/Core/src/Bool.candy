use ..Maybe
use ..Operators

public type Bool = True | False

public fun true(): Bool { Bool.True() }
public fun false(): Bool { Bool.False() }

impl Bool {
  fun not(): Bool { this.match[Bool](true = { false() }, false = { true() }) }
}

impl Bool: And {
  fun and(other: Bool): Bool { this.match[Bool](true = { other }, false = { false() }) }
}

impl Bool: Or {
  fun or(other: Bool): Bool { this.match[Bool](true = { true() }, false = { other }) }
}

impl Bool: Equals {
  fun equals(other: Bool): Bool { this.match[Bool](true = { other }, false = { other.not() }) }
}

impl Bool: Implies {
  fun implies(other: Bool): Bool { this.match[Bool](true = { other }, false = { true() }) }
}

impl Bool {
  public fun lazyAnd(other: () -> Bool): Bool {
    ## TODO(marcelgarus): Rename this to just `and` as soon as we support overloading.
    this.match[Bool](true = other, false = { false() })
  }
  
  public fun lazyOr(other: () -> Bool): Bool {
    ## TODO(marcelgarus): Rename this to just `or` as soon as we support overloading.
    this.match[Bool](true = { true() }, false = other)
  }
}

impl Bool {
  public fun then[T](body: () -> T): Maybe[T] { if[T](this, body) }
}

public fun if[T](condition: Bool, thenBody: () -> T): Maybe[T] {
  condition.match[Maybe[T]](true = { Maybe[T].Some(thenBody()) }, false = { Maybe[T].None() })
}
