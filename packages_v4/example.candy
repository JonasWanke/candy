# use("Core")
# use(".utils")

# Structural Types
let intType = int
let textType = text
let structType = [name: text, color: int]
# let enumType = Foo(int) | Bar
# let arrayType = array(int)
# let functionType = (int, text) -> int

# Expressions
let intExpression = 42
let textExpression = "Hello, World!"
## let textExpressionWithInterpolation = "The answer is {intExpression}!"
## let identifierExpression = intExpression
## let symbolExpression = SomeSymbol
## let parenthesizedExpression = (intExpression)
let structExpression = [name: "Banana", color: 12345]
# let lambdaExpression = { x: int -> x }

# Assignments
## let valueWithExplicitType: int = 42
# let someFunction(x: int) -> int = { x }

# Nominal Types
# let wrappedInt = createType(int)
# let uint = createType(
#   int,
#   { value ->
#     needs(value.isNonNegative())
#   },
# )
# let date = createType(
#   [year: int, month: int, day: int],
#   { value ->
#     needs(month.isBetween(1, 12))
#     needs(day.isBetween(1, 31))
#   },
# )

# Uniform Function Call Syntax
# Functions can also be overloaded
# let add(aDate: Date, duration: [days: int]) -> Date = {
#   needs(days.isNonNegative())
#   date([
#     year: aDate.year,
#     month: aDate.month,
#     day: aDate.day.add(duration.days),
#   ])
# }
# aDate.add([days: 1]) # is equivalent to `add(aDate, [days: 1])`

let main() -> int = {
  let helloWorld = "Hello, World!"
  print(helloWorld)

  let theAnswer = intAdd(40, 2)
  let theAnswerText = "42"
  print("The answer is {theAnswerText}!")

  let aStruct = [foo: theAnswer, bar: helloWorld]

  theAnswer
}
